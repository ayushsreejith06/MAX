"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   acceptDiscussion: function() { return /* binding */ acceptDiscussion; },\n/* harmony export */   acceptRejection: function() { return /* binding */ acceptRejection; },\n/* harmony export */   addDiscussionMessage: function() { return /* binding */ addDiscussionMessage; },\n/* harmony export */   archiveDiscussion: function() { return /* binding */ archiveDiscussion; },\n/* harmony export */   clearAllDiscussions: function() { return /* binding */ clearAllDiscussions; },\n/* harmony export */   clearDecisionLogs: function() { return /* binding */ clearDecisionLogs; },\n/* harmony export */   closeDiscussion: function() { return /* binding */ closeDiscussion; },\n/* harmony export */   createAgent: function() { return /* binding */ createAgent; },\n/* harmony export */   createDiscussion: function() { return /* binding */ createDiscussion; },\n/* harmony export */   createSector: function() { return /* binding */ createSector; },\n/* harmony export */   deleteAgent: function() { return /* binding */ deleteAgent; },\n/* harmony export */   deleteDiscussion: function() { return /* binding */ deleteDiscussion; },\n/* harmony export */   deleteSector: function() { return /* binding */ deleteSector; },\n/* harmony export */   depositSector: function() { return /* binding */ depositSector; },\n/* harmony export */   executeManagerExecutionList: function() { return /* binding */ executeManagerExecutionList; },\n/* harmony export */   fetchAgentById: function() { return /* binding */ fetchAgentById; },\n/* harmony export */   fetchAgents: function() { return /* binding */ fetchAgents; },\n/* harmony export */   fetchAllExecutionLogs: function() { return /* binding */ fetchAllExecutionLogs; },\n/* harmony export */   fetchChecklist: function() { return /* binding */ fetchChecklist; },\n/* harmony export */   fetchDiscussionById: function() { return /* binding */ fetchDiscussionById; },\n/* harmony export */   fetchDiscussionMessages: function() { return /* binding */ fetchDiscussionMessages; },\n/* harmony export */   fetchDiscussions: function() { return /* binding */ fetchDiscussions; },\n/* harmony export */   fetchExecutionLogs: function() { return /* binding */ fetchExecutionLogs; },\n/* harmony export */   fetchFinalizedRejections: function() { return /* binding */ fetchFinalizedRejections; },\n/* harmony export */   fetchRejectedItems: function() { return /* binding */ fetchRejectedItems; },\n/* harmony export */   fetchSectorById: function() { return /* binding */ fetchSectorById; },\n/* harmony export */   fetchSectors: function() { return /* binding */ fetchSectors; },\n/* harmony export */   fetchValuationHistory: function() { return /* binding */ fetchValuationHistory; },\n/* harmony export */   getManagerExecutionList: function() { return /* binding */ getManagerExecutionList; },\n/* harmony export */   getRejectedItemsForDiscussion: function() { return /* binding */ getRejectedItemsForDiscussion; },\n/* harmony export */   getUserBalance: function() { return /* binding */ getUserBalance; },\n/* harmony export */   isRateLimitError: function() { return /* binding */ isRateLimitError; },\n/* harmony export */   isSkippedResult: function() { return /* binding */ isSkippedResult; },\n/* harmony export */   rejectDiscussion: function() { return /* binding */ rejectDiscussion; },\n/* harmony export */   runConfidenceTick: function() { return /* binding */ runConfidenceTick; },\n/* harmony export */   sendMessageToManager: function() { return /* binding */ sendMessageToManager; },\n/* harmony export */   startDiscussionRounds: function() { return /* binding */ startDiscussionRounds; },\n/* harmony export */   submitRevision: function() { return /* binding */ submitRevision; },\n/* harmony export */   updateAgent: function() { return /* binding */ updateAgent; },\n/* harmony export */   withdrawSector: function() { return /* binding */ withdrawSector; }\n/* harmony export */ });\n/* harmony import */ var _desktopEnv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./desktopEnv */ \"(app-pages-browser)/./lib/desktopEnv.ts\");\n/* harmony import */ var _rateLimit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rateLimit */ \"(app-pages-browser)/./lib/rateLimit.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n/**\r\n * Check if an error is a rate limit error from the server (HTTP 429 or server_rate_limit code)\r\n * This should ONLY be used for actual server rate limit errors, NOT internal throttle errors\r\n */ function isRateLimitError(error) {\n    var _error_response;\n    // Only check for actual HTTP 429 status or server_rate_limit code\n    return (error === null || error === void 0 ? void 0 : (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 429 || (error === null || error === void 0 ? void 0 : error.code) === \"server_rate_limit\" || (error === null || error === void 0 ? void 0 : error.status) === 429;\n}\n/**\r\n * Check if a result indicates a skipped request (rate-limited)\r\n */ function isSkippedResult(result) {\n    return result !== null && typeof result === \"object\" && \"skipped\" in result && result.skipped === true;\n}\n// Use desktop-aware base URL\nconst getApiBase = ()=>{\n    if (true) {\n        // Client-side: use dynamic detection\n        return (0,_desktopEnv__WEBPACK_IMPORTED_MODULE_0__.getApiBaseUrl)();\n    }\n    // Server-side: use environment variable or default\n    // Support NEXT_PUBLIC_API_URL (full API URL) or NEXT_PUBLIC_MAX_BACKEND_URL/NEXT_PUBLIC_BACKEND_URL (base URL)\n    const apiUrl = \"http://localhost:8000/api\";\n    if (apiUrl) {\n        return apiUrl.replace(/\\/$/, \"\");\n    }\n    const backend = process.env.NEXT_PUBLIC_MAX_BACKEND_URL || process.env.NEXT_PUBLIC_BACKEND_URL || \"http://localhost:8000\";\n    return \"\".concat(backend.replace(/\\/$/, \"\"), \"/api\");\n};\nconst API_BASE = getApiBase();\nconst BACKEND = (0,_desktopEnv__WEBPACK_IMPORTED_MODULE_0__.getBackendBaseUrl)();\nfunction unwrapPayload(payload) {\n    if (payload && typeof payload === \"object\" && \"data\" in payload) {\n        return payload.data;\n    }\n    return payload;\n}\n/**\r\n * Normalize agent ID: ensure it's a string and trim whitespace\r\n * @param id - Agent ID (can be string, number, or undefined)\r\n * @returns Normalized string ID or empty string if invalid\r\n */ function normalizeAgentId(id) {\n    if (!id) return \"\";\n    const normalized = String(id).trim();\n    return normalized || \"\";\n}\nasync function request(path, init) {\n    let bypassRateLimit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    try {\n        // Get API base URL dynamically (handles desktop vs web mode)\n        const apiBase =  true ? (0,_desktopEnv__WEBPACK_IMPORTED_MODULE_0__.getApiBaseUrl)() : 0;\n        const backendUrl =  true ? (0,_desktopEnv__WEBPACK_IMPORTED_MODULE_0__.getBackendBaseUrl)() : 0;\n        const fullUrl = \"\".concat(apiBase).concat(path);\n        // Debug logging (always log to help debug issues)\n        if (true) {\n            console.log(\"[API Request] \".concat((init === null || init === void 0 ? void 0 : init.method) || \"GET\", \" \").concat(fullUrl));\n            console.log(\"[API Request] Backend base URL: \".concat(backendUrl));\n        }\n        const response = await (0,_rateLimit__WEBPACK_IMPORTED_MODULE_1__.rateLimitedFetch)(fullUrl, 500, {\n            cache: \"no-store\",\n            credentials: \"omit\",\n            ...init,\n            // Add timeout to prevent hanging\n            signal: AbortSignal.timeout(10000)\n        }, {\n            bypass: bypassRateLimit\n        });\n        if (!response.ok) {\n            let errorMessage = \"Request failed: \".concat(response.status);\n            let errorResponse = null;\n            try {\n                const errorData = await response.json();\n                errorResponse = errorData;\n                if (errorData.error) {\n                    errorMessage = errorData.error;\n                } else if (typeof errorData === \"string\") {\n                    errorMessage = errorData;\n                }\n                // Preserve success: false format if present\n                if (errorData.success === false) {\n                    errorResponse = {\n                        success: false,\n                        error: errorMessage\n                    };\n                }\n            } catch (e) {\n                const text = await response.text();\n                if (text) {\n                    errorMessage = text;\n                }\n            }\n            const error = new Error(errorMessage);\n            if (errorResponse) {\n                error.response = errorResponse;\n            }\n            throw error;\n        }\n        const payload = await response.json();\n        return unwrapPayload(payload);\n    } catch (error) {\n        if (error instanceof Error) {\n            // Check if it's a network error or timeout\n            const isNetworkError = error.message.includes(\"fetch\") || error.message.includes(\"Failed to fetch\") || error.message.includes(\"NetworkError\") || error.message.includes(\"timeout\") || error.message.includes(\"aborted\") || error.name === \"TypeError\" && error.message.includes(\"fetch\");\n            if (isNetworkError) {\n                // Always use dynamic detection for error messages\n                const apiBase =  true ? (0,_desktopEnv__WEBPACK_IMPORTED_MODULE_0__.getApiBaseUrl)() : 0;\n                const backendUrl =  true ? (0,_desktopEnv__WEBPACK_IMPORTED_MODULE_0__.getBackendBaseUrl)() : 0;\n                const fullUrl = \"\".concat(apiBase).concat(path);\n                // Log more details\n                console.error(\"[API Connection Error]\", {\n                    error: error.message,\n                    name: error.name,\n                    attemptedUrl: fullUrl,\n                    backendUrl,\n                    apiBase,\n                    envApiUrl: \"http://localhost:8000/api\",\n                    envBackendUrl: process.env.NEXT_PUBLIC_MAX_BACKEND_URL || process.env.NEXT_PUBLIC_BACKEND_URL,\n                    isDesktop:  true ? (0,_desktopEnv__WEBPACK_IMPORTED_MODULE_0__.isDesktopApp)() : 0\n                });\n                // Try to check if backend health endpoint is reachable\n                if (true) {\n                    try {\n                        const healthUrl = \"\".concat(backendUrl, \"/health\");\n                        console.log(\"[API] Checking backend health at: \".concat(healthUrl));\n                        const healthCheck = await fetch(healthUrl, {\n                            method: \"GET\",\n                            cache: \"no-store\",\n                            signal: AbortSignal.timeout(2000) // 2 second timeout for health check\n                        });\n                        if (healthCheck.ok) {\n                            console.log(\"[API] Backend health check passed, but API request failed. This might be a CORS or routing issue.\");\n                        } else {\n                            console.error(\"[API] Backend health check failed with status: \".concat(healthCheck.status));\n                        }\n                    } catch (healthError) {\n                        console.error(\"[API] Backend health check also failed:\", healthError);\n                    }\n                }\n                throw new Error(\"Cannot connect to backend server. Please ensure the backend is running on \".concat(backendUrl, \". Attempted URL: \").concat(fullUrl));\n            }\n            throw error;\n        }\n        throw new Error(\"An unknown error occurred\");\n    }\n}\nfunction normalizeCandleData(entry, index, fallbackPrice) {\n    if (entry && typeof entry.time === \"string\" && typeof entry.value === \"number\") {\n        return entry;\n    }\n    const valueCandidate = typeof (entry === null || entry === void 0 ? void 0 : entry.value) === \"number\" ? entry.value : typeof (entry === null || entry === void 0 ? void 0 : entry.close) === \"number\" ? entry.close : typeof fallbackPrice === \"number\" ? fallbackPrice : 0;\n    const hours = index * 2 % 24;\n    const minutes = index * 5 % 60;\n    const time = \"\".concat(hours.toString().padStart(2, \"0\"), \":\").concat(minutes.toString().padStart(2, \"0\"));\n    if (!Number.isFinite(valueCandidate)) {\n        return null;\n    }\n    return {\n        time,\n        value: Number(valueCandidate.toFixed(2))\n    };\n}\nfunction normalizeAgent(raw) {\n    var _raw_performance, _raw_personality, _raw_personality1, _raw_personality2, _raw_personality3;\n    const performanceValue = typeof (raw === null || raw === void 0 ? void 0 : raw.performance) === \"number\" ? raw.performance : typeof (raw === null || raw === void 0 ? void 0 : (_raw_performance = raw.performance) === null || _raw_performance === void 0 ? void 0 : _raw_performance.pnl) === \"number\" ? raw.performance.pnl : 0;\n    const tradesCount = Array.isArray(raw === null || raw === void 0 ? void 0 : raw.trades) ? raw.trades.length : typeof (raw === null || raw === void 0 ? void 0 : raw.trades) === \"number\" ? raw.trades : 0;\n    var _raw_riskTolerance, _ref, _ref1;\n    const riskTolerance = (_ref1 = (_ref = (_raw_riskTolerance = raw === null || raw === void 0 ? void 0 : raw.riskTolerance) !== null && _raw_riskTolerance !== void 0 ? _raw_riskTolerance : raw === null || raw === void 0 ? void 0 : (_raw_personality = raw.personality) === null || _raw_personality === void 0 ? void 0 : _raw_personality.riskTolerance) !== null && _ref !== void 0 ? _ref : raw === null || raw === void 0 ? void 0 : (_raw_personality1 = raw.personality) === null || _raw_personality1 === void 0 ? void 0 : _raw_personality1.risk_tolerance) !== null && _ref1 !== void 0 ? _ref1 : \"Unknown\";\n    const displayName = typeof (raw === null || raw === void 0 ? void 0 : raw.displayName) === \"string\" && raw.displayName.trim().length > 0 ? raw.displayName.trim() : typeof (raw === null || raw === void 0 ? void 0 : raw.name) === \"string\" ? raw.name : \"Unnamed Agent\";\n    const style = typeof (raw === null || raw === void 0 ? void 0 : raw.style) === \"string\" ? raw.style : undefined;\n    const initialConfidence = typeof (raw === null || raw === void 0 ? void 0 : raw.initialConfidence) === \"number\" ? raw.initialConfidence : typeof (raw === null || raw === void 0 ? void 0 : raw.confidence) === \"number\" ? raw.confidence : undefined;\n    var _raw_role, _raw_status, _raw_sectorId, _ref2, _raw_sectorSymbol, _ref3, _raw_sectorName, _ref4, _raw_personality_decisionStyle, _ref5, _raw_createdAt, _ref6;\n    return {\n        id: normalizeAgentId(raw === null || raw === void 0 ? void 0 : raw.id),\n        name: displayName,\n        displayName,\n        role: String((_raw_role = raw === null || raw === void 0 ? void 0 : raw.role) !== null && _raw_role !== void 0 ? _raw_role : \"agent\"),\n        style,\n        riskTolerance,\n        shortBio: typeof (raw === null || raw === void 0 ? void 0 : raw.shortBio) === \"string\" ? raw.shortBio : undefined,\n        initialConfidence,\n        performance: Number(performanceValue || 0),\n        trades: Number(tradesCount || 0),\n        status: (_raw_status = raw === null || raw === void 0 ? void 0 : raw.status) !== null && _raw_status !== void 0 ? _raw_status : \"idle\",\n        sectorId: (_ref2 = (_raw_sectorId = raw === null || raw === void 0 ? void 0 : raw.sectorId) !== null && _raw_sectorId !== void 0 ? _raw_sectorId : raw === null || raw === void 0 ? void 0 : raw.sector_id) !== null && _ref2 !== void 0 ? _ref2 : null,\n        sectorSymbol: (_ref3 = (_raw_sectorSymbol = raw === null || raw === void 0 ? void 0 : raw.sectorSymbol) !== null && _raw_sectorSymbol !== void 0 ? _raw_sectorSymbol : raw === null || raw === void 0 ? void 0 : raw.sector_symbol) !== null && _ref3 !== void 0 ? _ref3 : undefined,\n        sectorName: (_ref4 = (_raw_sectorName = raw === null || raw === void 0 ? void 0 : raw.sectorName) !== null && _raw_sectorName !== void 0 ? _raw_sectorName : raw === null || raw === void 0 ? void 0 : raw.sector_name) !== null && _ref4 !== void 0 ? _ref4 : undefined,\n        personality: {\n            riskTolerance,\n            decisionStyle: (_ref5 = (_raw_personality_decisionStyle = raw === null || raw === void 0 ? void 0 : (_raw_personality2 = raw.personality) === null || _raw_personality2 === void 0 ? void 0 : _raw_personality2.decisionStyle) !== null && _raw_personality_decisionStyle !== void 0 ? _raw_personality_decisionStyle : raw === null || raw === void 0 ? void 0 : (_raw_personality3 = raw.personality) === null || _raw_personality3 === void 0 ? void 0 : _raw_personality3.decision_style) !== null && _ref5 !== void 0 ? _ref5 : \"Unknown\"\n        },\n        prompt: typeof (raw === null || raw === void 0 ? void 0 : raw.prompt) === \"string\" ? raw.prompt : undefined,\n        preferences: (raw === null || raw === void 0 ? void 0 : raw.preferences) ? {\n            riskWeight: typeof raw.preferences.riskWeight === \"number\" ? raw.preferences.riskWeight : undefined,\n            profitWeight: typeof raw.preferences.profitWeight === \"number\" ? raw.preferences.profitWeight : undefined,\n            speedWeight: typeof raw.preferences.speedWeight === \"number\" ? raw.preferences.speedWeight : undefined,\n            accuracyWeight: typeof raw.preferences.accuracyWeight === \"number\" ? raw.preferences.accuracyWeight : undefined\n        } : undefined,\n        morale: typeof (raw === null || raw === void 0 ? void 0 : raw.morale) === \"number\" ? raw.morale : undefined,\n        rewardPoints: typeof (raw === null || raw === void 0 ? void 0 : raw.rewardPoints) === \"number\" ? raw.rewardPoints : undefined,\n        confidence: typeof (raw === null || raw === void 0 ? void 0 : raw.confidence) === \"number\" ? raw.confidence : typeof initialConfidence === \"number\" ? initialConfidence : 0,\n        createdAt: (_ref6 = (_raw_createdAt = raw === null || raw === void 0 ? void 0 : raw.createdAt) !== null && _raw_createdAt !== void 0 ? _raw_createdAt : raw === null || raw === void 0 ? void 0 : raw.created_at) !== null && _ref6 !== void 0 ? _ref6 : new Date().toISOString(),\n        rawTrades: Array.isArray(raw === null || raw === void 0 ? void 0 : raw.trades) ? raw.trades : undefined,\n        rawPerformance: typeof (raw === null || raw === void 0 ? void 0 : raw.performance) === \"object\" ? raw.performance : undefined\n    };\n}\nfunction normalizeDiscussion(raw) {\n    const messages = Array.isArray(raw === null || raw === void 0 ? void 0 : raw.messages) ? raw.messages.map((message, index)=>{\n        var _raw_id, _message_id, _message_agentId, _ref, _message_agentName, _ref1, _message_content, _message_timestamp, _ref2, _message_role;\n        return {\n            id: String((_message_id = message === null || message === void 0 ? void 0 : message.id) !== null && _message_id !== void 0 ? _message_id : \"\".concat((_raw_id = raw === null || raw === void 0 ? void 0 : raw.id) !== null && _raw_id !== void 0 ? _raw_id : \"disc\", \"-msg-\").concat(index)),\n            agentId: (_ref = (_message_agentId = message === null || message === void 0 ? void 0 : message.agentId) !== null && _message_agentId !== void 0 ? _message_agentId : message === null || message === void 0 ? void 0 : message.agent_id) !== null && _ref !== void 0 ? _ref : undefined,\n            agentName: String((_ref1 = (_message_agentName = message === null || message === void 0 ? void 0 : message.agentName) !== null && _message_agentName !== void 0 ? _message_agentName : message === null || message === void 0 ? void 0 : message.agent_name) !== null && _ref1 !== void 0 ? _ref1 : \"Unknown Agent\"),\n            content: String((_message_content = message === null || message === void 0 ? void 0 : message.content) !== null && _message_content !== void 0 ? _message_content : \"\"),\n            timestamp: (_ref2 = (_message_timestamp = message === null || message === void 0 ? void 0 : message.timestamp) !== null && _message_timestamp !== void 0 ? _message_timestamp : message === null || message === void 0 ? void 0 : message.createdAt) !== null && _ref2 !== void 0 ? _ref2 : new Date().toISOString(),\n            role: (_message_role = message === null || message === void 0 ? void 0 : message.role) !== null && _message_role !== void 0 ? _message_role : undefined\n        };\n    }) : [];\n    const checklistDraft = Array.isArray(raw === null || raw === void 0 ? void 0 : raw.checklistDraft) ? raw.checklistDraft.map((item)=>{\n        var _item_id, _item_text, _item_agentId, _ref, _item_agentName, _ref1;\n        return {\n            id: String((_item_id = item === null || item === void 0 ? void 0 : item.id) !== null && _item_id !== void 0 ? _item_id : \"\"),\n            text: String((_item_text = item === null || item === void 0 ? void 0 : item.text) !== null && _item_text !== void 0 ? _item_text : \"\"),\n            agentId: (_ref = (_item_agentId = item === null || item === void 0 ? void 0 : item.agentId) !== null && _item_agentId !== void 0 ? _item_agentId : item === null || item === void 0 ? void 0 : item.agent_id) !== null && _ref !== void 0 ? _ref : undefined,\n            agentName: (_ref1 = (_item_agentName = item === null || item === void 0 ? void 0 : item.agentName) !== null && _item_agentName !== void 0 ? _item_agentName : item === null || item === void 0 ? void 0 : item.agent_name) !== null && _ref1 !== void 0 ? _ref1 : undefined,\n            round: typeof (item === null || item === void 0 ? void 0 : item.round) === \"number\" ? item.round : undefined\n        };\n    }) : undefined;\n    const checklist = Array.isArray(raw === null || raw === void 0 ? void 0 : raw.checklist) ? raw.checklist.map((item)=>{\n        var _item_id, _item_text, _item_agentId, _ref, _ref1, _item_agentName, _ref2, _item_action, _item_symbol, _item_reason, _ref3, _item_reasoning, _ref4, _item_rationale, _ref5, _ref6, _item_approvalStatus, _item_approvalReason, _item_status;\n        return {\n            id: String((_item_id = item === null || item === void 0 ? void 0 : item.id) !== null && _item_id !== void 0 ? _item_id : \"\"),\n            text: String((_item_text = item === null || item === void 0 ? void 0 : item.text) !== null && _item_text !== void 0 ? _item_text : \"\"),\n            agentId: (_ref1 = (_ref = (_item_agentId = item === null || item === void 0 ? void 0 : item.agentId) !== null && _item_agentId !== void 0 ? _item_agentId : item === null || item === void 0 ? void 0 : item.agent_id) !== null && _ref !== void 0 ? _ref : item === null || item === void 0 ? void 0 : item.sourceAgentId) !== null && _ref1 !== void 0 ? _ref1 : undefined,\n            agentName: (_ref2 = (_item_agentName = item === null || item === void 0 ? void 0 : item.agentName) !== null && _item_agentName !== void 0 ? _item_agentName : item === null || item === void 0 ? void 0 : item.agent_name) !== null && _ref2 !== void 0 ? _ref2 : undefined,\n            round: typeof (item === null || item === void 0 ? void 0 : item.round) === \"number\" ? item.round : undefined,\n            action: (_item_action = item === null || item === void 0 ? void 0 : item.action) !== null && _item_action !== void 0 ? _item_action : undefined,\n            amount: typeof (item === null || item === void 0 ? void 0 : item.amount) === \"number\" ? item.amount : undefined,\n            allocationPercent: typeof (item === null || item === void 0 ? void 0 : item.allocationPercent) === \"number\" ? item.allocationPercent : undefined,\n            symbol: (_item_symbol = item === null || item === void 0 ? void 0 : item.symbol) !== null && _item_symbol !== void 0 ? _item_symbol : undefined,\n            reason: (_ref3 = (_item_reason = item === null || item === void 0 ? void 0 : item.reason) !== null && _item_reason !== void 0 ? _item_reason : item === null || item === void 0 ? void 0 : item.reasoning) !== null && _ref3 !== void 0 ? _ref3 : undefined,\n            reasoning: (_ref4 = (_item_reasoning = item === null || item === void 0 ? void 0 : item.reasoning) !== null && _item_reasoning !== void 0 ? _item_reasoning : item === null || item === void 0 ? void 0 : item.reason) !== null && _ref4 !== void 0 ? _ref4 : undefined,\n            rationale: (_ref6 = (_ref5 = (_item_rationale = item === null || item === void 0 ? void 0 : item.rationale) !== null && _item_rationale !== void 0 ? _item_rationale : item === null || item === void 0 ? void 0 : item.reasoning) !== null && _ref5 !== void 0 ? _ref5 : item === null || item === void 0 ? void 0 : item.reason) !== null && _ref6 !== void 0 ? _ref6 : undefined,\n            confidence: typeof (item === null || item === void 0 ? void 0 : item.confidence) === \"number\" ? item.confidence : undefined,\n            approvalStatus: (_item_approvalStatus = item === null || item === void 0 ? void 0 : item.approvalStatus) !== null && _item_approvalStatus !== void 0 ? _item_approvalStatus : undefined,\n            approvalReason: (_item_approvalReason = item === null || item === void 0 ? void 0 : item.approvalReason) !== null && _item_approvalReason !== void 0 ? _item_approvalReason : undefined,\n            status: (_item_status = item === null || item === void 0 ? void 0 : item.status) !== null && _item_status !== void 0 ? _item_status : undefined\n        };\n    }) : undefined;\n    const finalizedChecklist = Array.isArray(raw === null || raw === void 0 ? void 0 : raw.finalizedChecklist) ? raw.finalizedChecklist.map((item)=>{\n        var _item_id, _item_text, _item_agentId, _ref, _ref1, _item_agentName, _ref2, _item_action, _item_symbol, _item_reason, _ref3, _item_reasoning, _ref4, _item_rationale, _ref5, _ref6, _item_approvalStatus, _item_approvalReason, _item_status;\n        return {\n            id: String((_item_id = item === null || item === void 0 ? void 0 : item.id) !== null && _item_id !== void 0 ? _item_id : \"\"),\n            text: String((_item_text = item === null || item === void 0 ? void 0 : item.text) !== null && _item_text !== void 0 ? _item_text : \"\"),\n            agentId: (_ref1 = (_ref = (_item_agentId = item === null || item === void 0 ? void 0 : item.agentId) !== null && _item_agentId !== void 0 ? _item_agentId : item === null || item === void 0 ? void 0 : item.agent_id) !== null && _ref !== void 0 ? _ref : item === null || item === void 0 ? void 0 : item.sourceAgentId) !== null && _ref1 !== void 0 ? _ref1 : undefined,\n            agentName: (_ref2 = (_item_agentName = item === null || item === void 0 ? void 0 : item.agentName) !== null && _item_agentName !== void 0 ? _item_agentName : item === null || item === void 0 ? void 0 : item.agent_name) !== null && _ref2 !== void 0 ? _ref2 : undefined,\n            round: typeof (item === null || item === void 0 ? void 0 : item.round) === \"number\" ? item.round : undefined,\n            action: (_item_action = item === null || item === void 0 ? void 0 : item.action) !== null && _item_action !== void 0 ? _item_action : undefined,\n            amount: typeof (item === null || item === void 0 ? void 0 : item.amount) === \"number\" ? item.amount : undefined,\n            allocationPercent: typeof (item === null || item === void 0 ? void 0 : item.allocationPercent) === \"number\" ? item.allocationPercent : undefined,\n            symbol: (_item_symbol = item === null || item === void 0 ? void 0 : item.symbol) !== null && _item_symbol !== void 0 ? _item_symbol : undefined,\n            reason: (_ref3 = (_item_reason = item === null || item === void 0 ? void 0 : item.reason) !== null && _item_reason !== void 0 ? _item_reason : item === null || item === void 0 ? void 0 : item.reasoning) !== null && _ref3 !== void 0 ? _ref3 : undefined,\n            reasoning: (_ref4 = (_item_reasoning = item === null || item === void 0 ? void 0 : item.reasoning) !== null && _item_reasoning !== void 0 ? _item_reasoning : item === null || item === void 0 ? void 0 : item.reason) !== null && _ref4 !== void 0 ? _ref4 : undefined,\n            rationale: (_ref6 = (_ref5 = (_item_rationale = item === null || item === void 0 ? void 0 : item.rationale) !== null && _item_rationale !== void 0 ? _item_rationale : item === null || item === void 0 ? void 0 : item.reasoning) !== null && _ref5 !== void 0 ? _ref5 : item === null || item === void 0 ? void 0 : item.reason) !== null && _ref6 !== void 0 ? _ref6 : undefined,\n            confidence: typeof (item === null || item === void 0 ? void 0 : item.confidence) === \"number\" ? item.confidence : undefined,\n            approvalStatus: (_item_approvalStatus = item === null || item === void 0 ? void 0 : item.approvalStatus) !== null && _item_approvalStatus !== void 0 ? _item_approvalStatus : \"accepted\",\n            approvalReason: (_item_approvalReason = item === null || item === void 0 ? void 0 : item.approvalReason) !== null && _item_approvalReason !== void 0 ? _item_approvalReason : undefined,\n            status: (_item_status = item === null || item === void 0 ? void 0 : item.status) !== null && _item_status !== void 0 ? _item_status : \"APPROVED\"\n        };\n    }) : undefined;\n    // Normalize checklistItems - primary field (unified array)\n    // If checklistItems is provided, use it; otherwise combine checklist and finalizedChecklist\n    const checklistItems = Array.isArray(raw === null || raw === void 0 ? void 0 : raw.checklistItems) ? raw.checklistItems.map((item)=>{\n        var _item_id, _item_text, _item_agentId, _ref, _ref1, _item_agentName, _ref2, _item_action, _item_symbol, _item_reason, _ref3, _item_reasoning, _ref4, _item_rationale, _ref5, _ref6, _item_approvalStatus, _item_approvalReason, _item_status;\n        return {\n            id: String((_item_id = item === null || item === void 0 ? void 0 : item.id) !== null && _item_id !== void 0 ? _item_id : \"\"),\n            text: String((_item_text = item === null || item === void 0 ? void 0 : item.text) !== null && _item_text !== void 0 ? _item_text : \"\"),\n            agentId: (_ref1 = (_ref = (_item_agentId = item === null || item === void 0 ? void 0 : item.agentId) !== null && _item_agentId !== void 0 ? _item_agentId : item === null || item === void 0 ? void 0 : item.agent_id) !== null && _ref !== void 0 ? _ref : item === null || item === void 0 ? void 0 : item.sourceAgentId) !== null && _ref1 !== void 0 ? _ref1 : undefined,\n            agentName: (_ref2 = (_item_agentName = item === null || item === void 0 ? void 0 : item.agentName) !== null && _item_agentName !== void 0 ? _item_agentName : item === null || item === void 0 ? void 0 : item.agent_name) !== null && _ref2 !== void 0 ? _ref2 : undefined,\n            round: typeof (item === null || item === void 0 ? void 0 : item.round) === \"number\" ? item.round : undefined,\n            action: (_item_action = item === null || item === void 0 ? void 0 : item.action) !== null && _item_action !== void 0 ? _item_action : undefined,\n            amount: typeof (item === null || item === void 0 ? void 0 : item.amount) === \"number\" ? item.amount : undefined,\n            allocationPercent: typeof (item === null || item === void 0 ? void 0 : item.allocationPercent) === \"number\" ? item.allocationPercent : undefined,\n            symbol: (_item_symbol = item === null || item === void 0 ? void 0 : item.symbol) !== null && _item_symbol !== void 0 ? _item_symbol : undefined,\n            reason: (_ref3 = (_item_reason = item === null || item === void 0 ? void 0 : item.reason) !== null && _item_reason !== void 0 ? _item_reason : item === null || item === void 0 ? void 0 : item.reasoning) !== null && _ref3 !== void 0 ? _ref3 : undefined,\n            reasoning: (_ref4 = (_item_reasoning = item === null || item === void 0 ? void 0 : item.reasoning) !== null && _item_reasoning !== void 0 ? _item_reasoning : item === null || item === void 0 ? void 0 : item.reason) !== null && _ref4 !== void 0 ? _ref4 : undefined,\n            rationale: (_ref6 = (_ref5 = (_item_rationale = item === null || item === void 0 ? void 0 : item.rationale) !== null && _item_rationale !== void 0 ? _item_rationale : item === null || item === void 0 ? void 0 : item.reasoning) !== null && _ref5 !== void 0 ? _ref5 : item === null || item === void 0 ? void 0 : item.reason) !== null && _ref6 !== void 0 ? _ref6 : undefined,\n            confidence: typeof (item === null || item === void 0 ? void 0 : item.confidence) === \"number\" ? item.confidence : undefined,\n            approvalStatus: (_item_approvalStatus = item === null || item === void 0 ? void 0 : item.approvalStatus) !== null && _item_approvalStatus !== void 0 ? _item_approvalStatus : undefined,\n            approvalReason: (_item_approvalReason = item === null || item === void 0 ? void 0 : item.approvalReason) !== null && _item_approvalReason !== void 0 ? _item_approvalReason : undefined,\n            status: (_item_status = item === null || item === void 0 ? void 0 : item.status) !== null && _item_status !== void 0 ? _item_status : undefined\n        };\n    }) : checklist && finalizedChecklist ? [\n        ...checklist || [],\n        ...finalizedChecklist || []\n    ] : checklist || finalizedChecklist || undefined;\n    var _raw_status;\n    // Normalize status: only 'in_progress' or 'decided' are valid\n    let normalizedStatus = (_raw_status = raw === null || raw === void 0 ? void 0 : raw.status) !== null && _raw_status !== void 0 ? _raw_status : \"in_progress\";\n    if (normalizedStatus === \"active\" || normalizedStatus === \"open\" || normalizedStatus === \"OPEN\" || normalizedStatus === \"created\" || normalizedStatus === \"in_progress\") {\n        normalizedStatus = \"in_progress\";\n    } else if (normalizedStatus === \"closed\" || normalizedStatus === \"CLOSED\" || normalizedStatus === \"archived\" || normalizedStatus === \"finalized\" || normalizedStatus === \"accepted\" || normalizedStatus === \"completed\" || normalizedStatus === \"decided\") {\n        normalizedStatus = \"decided\";\n    }\n    var _raw_id, _raw_sectorId, _ref, _raw_title, _raw_createdAt, _ref1, _raw_updatedAt, _ref2, _raw_sectorSymbol, _ref3, _raw_sectorName, _ref4;\n    return {\n        id: String((_raw_id = raw === null || raw === void 0 ? void 0 : raw.id) !== null && _raw_id !== void 0 ? _raw_id : \"\"),\n        sectorId: String((_ref = (_raw_sectorId = raw === null || raw === void 0 ? void 0 : raw.sectorId) !== null && _raw_sectorId !== void 0 ? _raw_sectorId : raw === null || raw === void 0 ? void 0 : raw.sector_id) !== null && _ref !== void 0 ? _ref : \"\"),\n        title: String((_raw_title = raw === null || raw === void 0 ? void 0 : raw.title) !== null && _raw_title !== void 0 ? _raw_title : \"Untitled discussion\"),\n        status: normalizedStatus,\n        agentIds: Array.isArray(raw === null || raw === void 0 ? void 0 : raw.agentIds) ? raw.agentIds.map((agentId)=>String(agentId)) : Array.isArray(raw === null || raw === void 0 ? void 0 : raw.agent_ids) ? raw.agent_ids.map((agentId)=>String(agentId)) : [],\n        messages,\n        messagesCount: typeof (raw === null || raw === void 0 ? void 0 : raw.messagesCount) === \"number\" ? raw.messagesCount : typeof (raw === null || raw === void 0 ? void 0 : raw.messageCount) === \"number\" ? raw.messageCount : undefined,\n        createdAt: (_ref1 = (_raw_createdAt = raw === null || raw === void 0 ? void 0 : raw.createdAt) !== null && _raw_createdAt !== void 0 ? _raw_createdAt : raw === null || raw === void 0 ? void 0 : raw.created_at) !== null && _ref1 !== void 0 ? _ref1 : new Date().toISOString(),\n        updatedAt: (_ref2 = (_raw_updatedAt = raw === null || raw === void 0 ? void 0 : raw.updatedAt) !== null && _raw_updatedAt !== void 0 ? _raw_updatedAt : raw === null || raw === void 0 ? void 0 : raw.updated_at) !== null && _ref2 !== void 0 ? _ref2 : new Date().toISOString(),\n        sectorSymbol: (_ref3 = (_raw_sectorSymbol = raw === null || raw === void 0 ? void 0 : raw.sectorSymbol) !== null && _raw_sectorSymbol !== void 0 ? _raw_sectorSymbol : raw === null || raw === void 0 ? void 0 : raw.sector_symbol) !== null && _ref3 !== void 0 ? _ref3 : undefined,\n        sectorName: (_ref4 = (_raw_sectorName = raw === null || raw === void 0 ? void 0 : raw.sectorName) !== null && _raw_sectorName !== void 0 ? _raw_sectorName : raw === null || raw === void 0 ? void 0 : raw.sector_name) !== null && _ref4 !== void 0 ? _ref4 : undefined,\n        round: typeof (raw === null || raw === void 0 ? void 0 : raw.round) === \"number\" ? raw.round : undefined,\n        checklistItems: checklistItems && checklistItems.length > 0 ? checklistItems : undefined,\n        checklistDraft: checklistDraft && checklistDraft.length > 0 ? checklistDraft : undefined,\n        checklist: checklist && checklist.length > 0 ? checklist : undefined,\n        finalizedChecklist: finalizedChecklist && finalizedChecklist.length > 0 ? finalizedChecklist : undefined\n    };\n}\nfunction normalizeSector(raw) {\n    var _raw_currentPrice, _ref;\n    const basePrice = Number((_ref = (_raw_currentPrice = raw === null || raw === void 0 ? void 0 : raw.currentPrice) !== null && _raw_currentPrice !== void 0 ? _raw_currentPrice : raw === null || raw === void 0 ? void 0 : raw.price) !== null && _ref !== void 0 ? _ref : 0);\n    const agents = Array.isArray(raw === null || raw === void 0 ? void 0 : raw.agents) ? raw.agents.map((agent)=>{\n        var _agent_sectorId, _agent_sectorSymbol, _ref, _agent_sectorName, _ref1;\n        return normalizeAgent({\n            ...agent,\n            sectorId: (_agent_sectorId = agent === null || agent === void 0 ? void 0 : agent.sectorId) !== null && _agent_sectorId !== void 0 ? _agent_sectorId : raw === null || raw === void 0 ? void 0 : raw.id,\n            sectorSymbol: (_ref = (_agent_sectorSymbol = agent === null || agent === void 0 ? void 0 : agent.sectorSymbol) !== null && _agent_sectorSymbol !== void 0 ? _agent_sectorSymbol : raw === null || raw === void 0 ? void 0 : raw.symbol) !== null && _ref !== void 0 ? _ref : raw === null || raw === void 0 ? void 0 : raw.sectorSymbol,\n            sectorName: (_ref1 = (_agent_sectorName = agent === null || agent === void 0 ? void 0 : agent.sectorName) !== null && _agent_sectorName !== void 0 ? _agent_sectorName : raw === null || raw === void 0 ? void 0 : raw.name) !== null && _ref1 !== void 0 ? _ref1 : raw === null || raw === void 0 ? void 0 : raw.sectorName\n        });\n    }) : [];\n    const candleData = Array.isArray(raw === null || raw === void 0 ? void 0 : raw.candleData) ? raw.candleData.map((entry, index)=>normalizeCandleData(entry, index, basePrice)).filter((point)=>Boolean(point)) : [];\n    const discussions = Array.isArray(raw === null || raw === void 0 ? void 0 : raw.discussions) ? raw.discussions.map((discussion)=>{\n        var _discussion_sectorId, _discussion_sectorSymbol, _ref, _discussion_sectorName, _ref1;\n        return normalizeDiscussion({\n            ...discussion,\n            sectorId: (_discussion_sectorId = discussion === null || discussion === void 0 ? void 0 : discussion.sectorId) !== null && _discussion_sectorId !== void 0 ? _discussion_sectorId : raw === null || raw === void 0 ? void 0 : raw.id,\n            sectorSymbol: (_ref = (_discussion_sectorSymbol = discussion === null || discussion === void 0 ? void 0 : discussion.sectorSymbol) !== null && _discussion_sectorSymbol !== void 0 ? _discussion_sectorSymbol : raw === null || raw === void 0 ? void 0 : raw.symbol) !== null && _ref !== void 0 ? _ref : raw === null || raw === void 0 ? void 0 : raw.sectorSymbol,\n            sectorName: (_ref1 = (_discussion_sectorName = discussion === null || discussion === void 0 ? void 0 : discussion.sectorName) !== null && _discussion_sectorName !== void 0 ? _discussion_sectorName : raw === null || raw === void 0 ? void 0 : raw.name) !== null && _ref1 !== void 0 ? _ref1 : raw === null || raw === void 0 ? void 0 : raw.sectorName\n        });\n    }) : [];\n    // Calculate activeAgents if not provided\n    const activeAgents = typeof (raw === null || raw === void 0 ? void 0 : raw.activeAgents) === \"number\" ? raw.activeAgents : typeof (raw === null || raw === void 0 ? void 0 : raw.active_agents) === \"number\" ? raw.active_agents : agents.filter((agent)=>agent.status === \"active\").length;\n    var _raw_id, _raw_name, _ref1, _raw_symbol, _ref2, _raw_sectorName, _ref3, _raw_sectorSymbol, _ref4, _raw_change, _raw_changePercent, _ref5, _raw_volume, _raw_statusPercent, _ref6, _raw_createdAt, _ref7;\n    return {\n        id: String((_raw_id = raw === null || raw === void 0 ? void 0 : raw.id) !== null && _raw_id !== void 0 ? _raw_id : \"\"),\n        // Primary standardized fields (prefer name/symbol, fallback to sectorName/sectorSymbol)\n        name: String((_ref1 = (_raw_name = raw === null || raw === void 0 ? void 0 : raw.name) !== null && _raw_name !== void 0 ? _raw_name : raw === null || raw === void 0 ? void 0 : raw.sectorName) !== null && _ref1 !== void 0 ? _ref1 : \"Unknown Sector\"),\n        symbol: String((_ref2 = (_raw_symbol = raw === null || raw === void 0 ? void 0 : raw.symbol) !== null && _raw_symbol !== void 0 ? _raw_symbol : raw === null || raw === void 0 ? void 0 : raw.sectorSymbol) !== null && _ref2 !== void 0 ? _ref2 : \"N/A\"),\n        // Backward compatibility fields (include if present)\n        sectorName: (_ref3 = (_raw_sectorName = raw === null || raw === void 0 ? void 0 : raw.sectorName) !== null && _raw_sectorName !== void 0 ? _raw_sectorName : raw === null || raw === void 0 ? void 0 : raw.name) !== null && _ref3 !== void 0 ? _ref3 : undefined,\n        sectorSymbol: (_ref4 = (_raw_sectorSymbol = raw === null || raw === void 0 ? void 0 : raw.sectorSymbol) !== null && _raw_sectorSymbol !== void 0 ? _raw_sectorSymbol : raw === null || raw === void 0 ? void 0 : raw.symbol) !== null && _ref4 !== void 0 ? _ref4 : undefined,\n        // Core market data fields\n        currentPrice: Number.isFinite(basePrice) ? Number(basePrice.toFixed(2)) : 0,\n        change: Number((_raw_change = raw === null || raw === void 0 ? void 0 : raw.change) !== null && _raw_change !== void 0 ? _raw_change : 0),\n        changePercent: Number((_ref5 = (_raw_changePercent = raw === null || raw === void 0 ? void 0 : raw.changePercent) !== null && _raw_changePercent !== void 0 ? _raw_changePercent : raw === null || raw === void 0 ? void 0 : raw.change_percent) !== null && _ref5 !== void 0 ? _ref5 : 0),\n        volume: Number((_raw_volume = raw === null || raw === void 0 ? void 0 : raw.volume) !== null && _raw_volume !== void 0 ? _raw_volume : 0),\n        // Risk and volatility\n        volatility: typeof (raw === null || raw === void 0 ? void 0 : raw.volatility) === \"number\" ? Number(raw.volatility.toFixed(4)) : undefined,\n        riskScore: typeof (raw === null || raw === void 0 ? void 0 : raw.riskScore) === \"number\" ? Number(raw.riskScore) : undefined,\n        // Agent and activity fields\n        agents,\n        activeAgents: Number(activeAgents),\n        buyAgents: typeof (raw === null || raw === void 0 ? void 0 : raw.buyAgents) === \"number\" ? Number(raw.buyAgents) : typeof (raw === null || raw === void 0 ? void 0 : raw.buy_agents) === \"number\" ? Number(raw.buy_agents) : undefined,\n        sellAgents: typeof (raw === null || raw === void 0 ? void 0 : raw.sellAgents) === \"number\" ? Number(raw.sellAgents) : typeof (raw === null || raw === void 0 ? void 0 : raw.sell_agents) === \"number\" ? Number(raw.sell_agents) : undefined,\n        statusPercent: Number((_ref6 = (_raw_statusPercent = raw === null || raw === void 0 ? void 0 : raw.statusPercent) !== null && _raw_statusPercent !== void 0 ? _raw_statusPercent : raw === null || raw === void 0 ? void 0 : raw.status_percent) !== null && _ref6 !== void 0 ? _ref6 : 0),\n        // Performance and balance\n        performance: (raw === null || raw === void 0 ? void 0 : raw.performance) && typeof raw.performance === \"object\" ? raw.performance : undefined,\n        balance: typeof (raw === null || raw === void 0 ? void 0 : raw.balance) === \"number\" ? Number(raw.balance.toFixed(2)) : 0,\n        // Additional fields\n        lastSimulatedPrice: typeof (raw === null || raw === void 0 ? void 0 : raw.lastSimulatedPrice) === \"number\" ? Number(raw.lastSimulatedPrice.toFixed(2)) : (raw === null || raw === void 0 ? void 0 : raw.lastSimulatedPrice) === null ? null : undefined,\n        initialPrice: typeof (raw === null || raw === void 0 ? void 0 : raw.initialPrice) === \"number\" && raw.initialPrice > 0 ? Number(raw.initialPrice.toFixed(2)) : undefined,\n        discussions,\n        candleData,\n        description: typeof (raw === null || raw === void 0 ? void 0 : raw.description) === \"string\" ? raw.description : undefined,\n        createdAt: (_ref7 = (_raw_createdAt = raw === null || raw === void 0 ? void 0 : raw.createdAt) !== null && _raw_createdAt !== void 0 ? _raw_createdAt : raw === null || raw === void 0 ? void 0 : raw.created_at) !== null && _ref7 !== void 0 ? _ref7 : new Date().toISOString()\n    };\n}\nasync function fetchSectors() {\n    try {\n        const result = await request(\"/sectors\");\n        // Handle rate limiting - return empty array when skipped\n        if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n            return [];\n        }\n        const payload = result;\n        if (!payload) {\n            return [];\n        }\n        return Array.isArray(payload) ? payload.map(normalizeSector) : [];\n    } catch (error) {\n        console.error(\"Error fetching sectors:\", error);\n        throw error;\n    }\n}\nasync function fetchSectorById(id) {\n    if (!id) {\n        return null;\n    }\n    // Normalize ID to lowercase for consistent case-sensitivity\n    const normalizedId = String(id).trim().toLowerCase();\n    const result = await request(\"/sectors/\".concat(normalizedId));\n    // Handle rate limiting - return null when skipped\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        return null;\n    }\n    const payload = result;\n    return payload ? normalizeSector(payload) : null;\n}\n/**\r\n * Fetch valuation history for a sector\r\n * @param sectorId - Sector ID\r\n * @param window - Time window ('1d', '1w', '1m', '3m', '6m', '1y', 'max', or hours like '6h', '24h')\r\n * @returns Array of valuation history points\r\n */ async function fetchValuationHistory(sectorId) {\n    let window = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"1m\";\n    if (!sectorId) {\n        return [];\n    }\n    // Normalize ID to lowercase for consistent case-sensitivity\n    const normalizedId = String(sectorId).trim().toLowerCase();\n    const result = await request(\"/price-history/\".concat(normalizedId, \"?window=\").concat(encodeURIComponent(window)));\n    // Handle rate limiting - return empty array when skipped\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        return [];\n    }\n    // Handle both direct array response and wrapped response\n    if (Array.isArray(result)) {\n        return result;\n    }\n    if (result && typeof result === \"object\" && \"data\" in result && Array.isArray(result.data)) {\n        return result.data;\n    }\n    return [];\n}\n// Manager Agent API functions\nasync function fetchAgents() {\n    const result = await request(\"/agents\");\n    // Handle rate limiting - return empty array when skipped\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        return [];\n    }\n    const payload = result;\n    return Array.isArray(payload) ? payload.map((agent)=>normalizeAgent(agent)) : [];\n}\nasync function fetchAgentById(id) {\n    // Normalize and validate ID before making request\n    const normalizedId = normalizeAgentId(id);\n    if (!normalizedId) {\n        console.warn(\"[fetchAgentById] Invalid or empty agent ID provided\");\n        return null;\n    }\n    const result = await request(\"/agents/\".concat(encodeURIComponent(normalizedId)));\n    // Handle rate limiting - return null when skipped\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        return null;\n    }\n    const payload = result;\n    return payload ? normalizeAgent(payload) : null;\n}\nasync function fetchDiscussions() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, pageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20, sectorId = arguments.length > 2 ? arguments[2] : void 0, status = arguments.length > 3 ? arguments[3] : void 0;\n    const params = new URLSearchParams({\n        page: page.toString(),\n        pageSize: pageSize.toString()\n    });\n    if (sectorId) {\n        params.append(\"sectorId\", sectorId);\n    }\n    if (status && status !== \"all\") {\n        params.append(\"status\", status);\n    }\n    const result = await request(\"/discussions?\".concat(params.toString()));\n    // Handle rate limiting - return empty result when skipped\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        return {\n            discussions: [],\n            pagination: {\n                page,\n                pageSize,\n                total: 0,\n                totalPages: 0\n            }\n        };\n    }\n    const payload = result;\n    return payload || {\n        discussions: [],\n        pagination: {\n            page,\n            pageSize,\n            total: 0,\n            totalPages: 0\n        }\n    };\n}\nasync function fetchDiscussionMessages(discussionId) {\n    if (!discussionId) {\n        return [];\n    }\n    const result = await request(\"/discussions/\".concat(discussionId, \"/messages\"));\n    // Handle rate limiting - return empty array when skipped\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        return [];\n    }\n    const payload = result;\n    if (payload && Array.isArray(payload.messages)) {\n        return payload.messages.map((message, index)=>{\n            var _message_id, _message_agentId, _ref, _message_agentName, _ref1, _message_content, _message_timestamp, _ref2, _message_role;\n            return {\n                id: String((_message_id = message === null || message === void 0 ? void 0 : message.id) !== null && _message_id !== void 0 ? _message_id : \"\".concat(discussionId, \"-msg-\").concat(index)),\n                agentId: (_ref = (_message_agentId = message === null || message === void 0 ? void 0 : message.agentId) !== null && _message_agentId !== void 0 ? _message_agentId : message === null || message === void 0 ? void 0 : message.agent_id) !== null && _ref !== void 0 ? _ref : undefined,\n                agentName: String((_ref1 = (_message_agentName = message === null || message === void 0 ? void 0 : message.agentName) !== null && _message_agentName !== void 0 ? _message_agentName : message === null || message === void 0 ? void 0 : message.agent_name) !== null && _ref1 !== void 0 ? _ref1 : \"Unknown Agent\"),\n                content: String((_message_content = message === null || message === void 0 ? void 0 : message.content) !== null && _message_content !== void 0 ? _message_content : \"\"),\n                timestamp: (_ref2 = (_message_timestamp = message === null || message === void 0 ? void 0 : message.timestamp) !== null && _message_timestamp !== void 0 ? _message_timestamp : message === null || message === void 0 ? void 0 : message.createdAt) !== null && _ref2 !== void 0 ? _ref2 : new Date().toISOString(),\n                role: (_message_role = message === null || message === void 0 ? void 0 : message.role) !== null && _message_role !== void 0 ? _message_role : undefined\n            };\n        });\n    }\n    return [];\n}\nasync function fetchDiscussionById(id) {\n    if (!id) {\n        return null;\n    }\n    const result = await request(\"/discussions/\".concat(id));\n    // Handle rate limiting - return null when skipped\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        return null;\n    }\n    // Handle rate limiting - return null when skipped\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        return null;\n    }\n    const payload = result;\n    return payload ? normalizeDiscussion(payload) : null;\n}\nasync function fetchRejectedItems() {\n    const result = await request(\"/discussions/rejected-items\");\n    // Handle rate limiting - return empty array when skipped\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        return {\n            rejected: []\n        };\n    }\n    const payload = result;\n    return payload || {\n        rejected: []\n    };\n}\nasync function fetchChecklist(discussionId) {\n    if (!discussionId) {\n        return null;\n    }\n    const result = await request(\"/discussions/\".concat(discussionId, \"/checklist\"));\n    // Handle rate limiting - return null when skipped\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        return null;\n    }\n    return result;\n}\nasync function getRejectedItemsForDiscussion(discussionId) {\n    if (!discussionId) {\n        return null;\n    }\n    const result = await request(\"/discussions/\".concat(discussionId, \"/rejected-items\"));\n    // Handle rate limiting - return null when skipped\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        return null;\n    }\n    return result;\n}\nasync function submitRevision(discussionId, params) {\n    if (!discussionId || !params.itemId) {\n        throw new Error(\"discussionId and itemId are required\");\n    }\n    const result = await request(\"/discussions/\".concat(discussionId, \"/submit-revision\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            itemId: params.itemId,\n            newContent: params.newContent\n        })\n    });\n    // Handle rate limiting - throw generic error for mutations\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        throw new Error(\"Request was skipped. Please try again.\");\n    }\n    return result;\n}\nasync function acceptRejection(discussionId, itemId) {\n    if (!discussionId || !itemId) {\n        throw new Error(\"discussionId and itemId are required\");\n    }\n    const result = await request(\"/discussions/\".concat(discussionId, \"/accept-rejection\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            itemId: itemId\n        })\n    });\n    // Handle rate limiting - throw generic error for mutations\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        throw new Error(\"Request was skipped. Please try again.\");\n    }\n    return result;\n}\nasync function createDiscussion(sectorId, title) {\n    let agentIds = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    const result = await request(\"/discussions\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            sectorId,\n            title,\n            agentIds\n        })\n    });\n    // Handle rate limiting - throw generic error for mutations\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        throw new Error(\"Request was skipped. Please try again.\");\n    }\n    const payload = result;\n    return normalizeDiscussion(payload);\n}\nasync function addDiscussionMessage(discussionId, message) {\n    const result = await request(\"/discussions/\".concat(discussionId, \"/message\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(message)\n    });\n    // Handle rate limiting - throw generic error for mutations\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        throw new Error(\"Request was skipped. Please try again.\");\n    }\n    const payload = result;\n    return normalizeDiscussion(payload);\n}\nasync function closeDiscussion(discussionId) {\n    const result = await request(\"/discussions/\".concat(discussionId, \"/close\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        }\n    });\n    // Handle rate limiting - throw generic error for mutations\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        throw new Error(\"Request was skipped. Please try again.\");\n    }\n    const payload = result;\n    return normalizeDiscussion(payload);\n}\nasync function startDiscussionRounds(discussionId) {\n    let numRounds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;\n    const result = await request(\"/discussions/\".concat(discussionId, \"/start-rounds\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            numRounds\n        })\n    });\n    // Handle rate limiting - throw generic error for mutations\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        throw new Error(\"Request was skipped. Please try again.\");\n    }\n    const payload = result;\n    return normalizeDiscussion(payload);\n}\nasync function deleteDiscussion(discussionId) {\n    const result = await request(\"/discussions/\".concat(discussionId), {\n        method: \"DELETE\"\n    });\n    // Handle rate limiting - throw generic error for mutations\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        throw new Error(\"Request was skipped. Please try again.\");\n    }\n    if (result && typeof result === \"object\" && \"success\" in result && !result.success) {\n        throw new Error(result.error || \"Failed to delete discussion\");\n    }\n}\nasync function archiveDiscussion(discussionId) {\n    const result = await request(\"/discussions/\".concat(discussionId, \"/archive\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        }\n    });\n    // Handle rate limiting - throw generic error for mutations\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        throw new Error(\"Request was skipped. Please try again.\");\n    }\n    const payload = result;\n    return normalizeDiscussion(payload);\n}\nasync function acceptDiscussion(discussionId) {\n    const result = await request(\"/discussions/\".concat(discussionId, \"/accept\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        }\n    });\n    // Handle rate limiting - throw generic error for mutations\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        throw new Error(\"Request was skipped. Please try again.\");\n    }\n    const payload = result;\n    return normalizeDiscussion(payload);\n}\nasync function rejectDiscussion(discussionId) {\n    const result = await request(\"/discussions/\".concat(discussionId, \"/reject\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        }\n    });\n    // Handle rate limiting - throw generic error for mutations\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        throw new Error(\"Request was skipped. Please try again.\");\n    }\n    const payload = result;\n    return normalizeDiscussion(payload);\n}\nasync function createSector(sectorName, sectorSymbol) {\n    // Bypass rate limiting for user-triggered actions - always execute immediately\n    const result = await request(\"/sectors\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            sectorName,\n            sectorSymbol\n        })\n    }, true); // bypassRateLimit = true\n    // Handle rate limiting - throw generic error for mutations\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        throw new Error(\"Request was skipped. Please try again.\");\n    }\n    const payload = result;\n    return normalizeSector(payload);\n}\nasync function createAgent(prompt, sectorId, role) {\n    try {\n        const result = await request(\"/agents\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                prompt,\n                sectorId,\n                role: role || null\n            })\n        });\n        // Handle rate limiting - throw generic error for mutations\n        if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n            throw new Error(\"Request was skipped. Please try again.\");\n        }\n        const payload = result;\n        // Handle both `{ success: true, data: Agent }` and direct `Agent`\n        let rawAgent;\n        if (payload && typeof payload === \"object\" && \"success\" in payload && payload.success === true && \"data\" in payload) {\n            rawAgent = payload.data;\n        } else {\n            rawAgent = payload;\n        }\n        // At this point we expect `rawAgent` to be an Agent-like object\n        const agent = normalizeAgent(rawAgent);\n        return agent;\n    } catch (error) {\n        // Preserve error structure (including error.response) for proper error handling in modals\n        // Extract error message from various possible formats\n        const message = error && error.message || \"Failed to create agent. Please try again.\";\n        // Re-throw with preserved structure\n        const newError = new Error(message);\n        if (error === null || error === void 0 ? void 0 : error.response) {\n            newError.response = error.response;\n        }\n        throw newError;\n    }\n}\nasync function depositSector(sectorId, amount) {\n    const payload = await request(\"/sectors/\".concat(sectorId, \"/deposit\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            amount\n        })\n    });\n    // Handle both wrapped and unwrapped responses\n    let sectorData = payload;\n    if (payload && typeof payload === \"object\" && \"success\" in payload && \"data\" in payload) {\n        sectorData = payload.data;\n    }\n    return normalizeSector(sectorData);\n}\nasync function withdrawSector(sectorId, amount) {\n    const payload = await request(\"/sectors/\".concat(sectorId, \"/withdraw\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            amount: amount !== null && amount !== void 0 ? amount : \"all\"\n        })\n    });\n    // Handle rate limiting - throw generic error for mutations\n    if (payload && typeof payload === \"object\" && \"skipped\" in payload && payload.skipped === true) {\n        throw new Error(\"Request was skipped. Please try again.\");\n    }\n    const result = payload;\n    return {\n        sector: normalizeSector(result.sector),\n        withdrawnAmount: result.withdrawnAmount\n    };\n}\nasync function updateAgent(agentId, updates) {\n    // Normalize and validate ID before making request\n    const normalizedId = normalizeAgentId(agentId);\n    if (!normalizedId) {\n        throw new Error(\"Invalid agent ID provided\");\n    }\n    // Bypass rate limiting for user-triggered actions - always execute immediately\n    const result = await request(\"/agents/\".concat(encodeURIComponent(normalizedId)), {\n        method: \"PUT\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(updates)\n    }, true); // bypassRateLimit = true\n    // Handle rate limiting - throw generic error for mutations\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        throw new Error(\"Request was skipped. Please try again.\");\n    }\n    const payload = result;\n    return normalizeAgent(payload);\n}\nasync function deleteAgent(agentId) {\n    // Normalize and validate ID before making request\n    const normalizedId = normalizeAgentId(agentId);\n    if (!normalizedId) {\n        throw new Error(\"Invalid agent ID provided\");\n    }\n    const result = await request(\"/agents/\".concat(encodeURIComponent(normalizedId)), {\n        method: \"DELETE\"\n    });\n    // Handle rate limiting - throw generic error for mutations\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        throw new Error(\"Request was skipped. Please try again.\");\n    }\n}\nasync function deleteSector(sectorId, confirmationCode) {\n    const result = await request(\"/sectors/\".concat(sectorId), {\n        method: \"DELETE\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            confirmationCode\n        })\n    });\n    // Handle rate limiting - throw generic error for mutations\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        throw new Error(\"Request was skipped. Please try again.\");\n    }\n    const payload = result;\n    return payload;\n}\nasync function getUserBalance() {\n    try {\n        const result = await request(\"/user/balance\");\n        // Handle rate limiting - return 0 when skipped\n        if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n            return 0;\n        }\n        const data = result;\n        return typeof data.balance === \"number\" ? data.balance : 0;\n    } catch (error) {\n        console.error(\"Failed to fetch user balance:\", error);\n        return 0;\n    }\n}\nasync function runConfidenceTick(sectorId) {\n    try {\n        const result = await request(\"/sectors/\".concat(sectorId, \"/confidence-tick\"), {\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({})\n        });\n        // Handle rate limiting - return null when skipped so polling can continue silently\n        if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n            return null;\n        }\n        return result;\n    } catch (error) {\n        // Re-throw errors (only real HTTP errors should reach here)\n        throw error;\n    }\n}\nasync function sendMessageToManager(sectorId, message) {\n    try {\n        const result = await request(\"/sectors/\".concat(sectorId, \"/message-manager\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                message\n            })\n        });\n        // Handle rate limiting\n        if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n            throw new Error(\"Request was rate-limited. Please try again later.\");\n        }\n        return result;\n    } catch (error) {\n        throw error;\n    }\n}\n/**\r\n * Fetch execution logs for a sector\r\n */ async function fetchExecutionLogs(sectorId) {\n    try {\n        const result = await request(\"/execution/logs/\".concat(sectorId));\n        // Handle rate limiting - return empty array when skipped\n        if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n            return [];\n        }\n        const payload = result;\n        if (payload && payload.success && Array.isArray(payload.logs)) {\n            return payload.logs;\n        }\n        return [];\n    } catch (error) {\n        console.error(\"Error fetching execution logs:\", error);\n        return [];\n    }\n}\n/**\r\n * Get execution list for a manager\r\n */ async function getManagerExecutionList(managerId) {\n    try {\n        const result = await request(\"/manager/\".concat(managerId, \"/execution-list\"));\n        // Handle rate limiting - return empty array when skipped\n        if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n            return [];\n        }\n        const payload = result;\n        if (payload && payload.success && Array.isArray(payload.executionList)) {\n            return payload.executionList;\n        }\n        return [];\n    } catch (error) {\n        console.error(\"Error fetching manager execution list:\", error);\n        return [];\n    }\n}\n/**\r\n * Execute all items in manager's execution list\r\n */ async function executeManagerExecutionList(managerId) {\n    const result = await request(\"/manager/\".concat(managerId, \"/execute-all\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        }\n    });\n    // Handle rate limiting - throw generic error for mutations\n    if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n        throw new Error(\"Request was skipped. Please try again.\");\n    }\n    return result;\n}\n/**\r\n * Clear all discussions (development only)\r\n * Note: Uses backend base URL directly since debug routes are at /debug (not /api/debug)\r\n */ async function clearAllDiscussions() {\n    try {\n        // Use backend base URL directly since debug routes are not under /api\n        const backendBase =  true ? (0,_desktopEnv__WEBPACK_IMPORTED_MODULE_0__.getBackendBaseUrl)() : 0;\n        const fullUrl = \"\".concat(backendBase, \"/debug/discussions/clear\");\n        const response = await (0,_rateLimit__WEBPACK_IMPORTED_MODULE_1__.rateLimitedFetch)(fullUrl, 500, {\n            method: \"DELETE\",\n            cache: \"no-store\",\n            credentials: \"omit\"\n        }, {\n            bypass: true\n        } // Bypass rate limiting for user-triggered actions\n        );\n        if (!response.ok) {\n            let errorMessage = \"Request failed: \".concat(response.status);\n            try {\n                const errorData = await response.json();\n                if (errorData.error) {\n                    errorMessage = errorData.error;\n                }\n            } catch (e) {\n                const text = await response.text();\n                if (text) {\n                    errorMessage = text;\n                }\n            }\n            throw new Error(errorMessage);\n        }\n        const payload = await response.json();\n        return payload;\n    } catch (error) {\n        throw error;\n    }\n}\nasync function fetchAllExecutionLogs() {\n    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    try {\n        const params = new URLSearchParams();\n        // Backend uses 'sector' not 'sectorId'\n        if (filters.sectorId) params.append(\"sector\", filters.sectorId);\n        if (filters.managerId) params.append(\"managerId\", filters.managerId);\n        if (filters.discussionId) params.append(\"discussionId\", filters.discussionId);\n        if (filters.actionType) params.append(\"actionType\", filters.actionType);\n        if (filters.startTime && filters.endTime) {\n            // Backend expects timeRange in format \"start:end\" or \"lastNhours\" or \"lastNdays\"\n            const hours = Math.round((filters.endTime - filters.startTime) / (1000 * 60 * 60));\n            if (hours <= 24) {\n                params.append(\"timeRange\", \"last\".concat(hours, \"hours\"));\n            } else {\n                const days = Math.round(hours / 24);\n                params.append(\"timeRange\", \"last\".concat(days, \"days\"));\n            }\n        }\n        const result = await request(\"/decision-logs/executed?\".concat(params.toString()));\n        // Handle rate limiting\n        if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n            return {\n                logs: []\n            };\n        }\n        const payload = result;\n        return {\n            logs: payload && payload.success && Array.isArray(payload.logs) ? payload.logs : [],\n            pagination: {\n                page: filters.page || 1,\n                pageSize: filters.pageSize || 20,\n                total: 0,\n                totalPages: 0\n            }\n        };\n    } catch (error) {\n        console.error(\"Error fetching execution logs:\", error);\n        return {\n            logs: []\n        };\n    }\n}\nasync function fetchFinalizedRejections() {\n    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    try {\n        const params = new URLSearchParams();\n        // Backend uses 'sector' not 'sectorId'\n        if (filters.sectorId) params.append(\"sector\", filters.sectorId);\n        if (filters.managerId) params.append(\"managerId\", filters.managerId);\n        if (filters.discussionId) params.append(\"discussionId\", filters.discussionId);\n        if (filters.startTime && filters.endTime) {\n            // Backend expects timeRange in format \"start:end\" or \"lastNhours\" or \"lastNdays\"\n            const hours = Math.round((filters.endTime - filters.startTime) / (1000 * 60 * 60));\n            if (hours <= 24) {\n                params.append(\"timeRange\", \"last\".concat(hours, \"hours\"));\n            } else {\n                const days = Math.round(hours / 24);\n                params.append(\"timeRange\", \"last\".concat(days, \"days\"));\n            }\n        }\n        const result = await request(\"/decision-logs/finalized-rejections?\".concat(params.toString()));\n        // Handle rate limiting\n        if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n            return {\n                rejections: []\n            };\n        }\n        const payload = result;\n        return {\n            rejections: payload && payload.success && Array.isArray(payload.finalizedRejections) ? payload.finalizedRejections : [],\n            pagination: {\n                page: filters.page || 1,\n                pageSize: filters.pageSize || 20,\n                total: 0,\n                totalPages: 0\n            }\n        };\n    } catch (error) {\n        console.error(\"Error fetching finalized rejections:\", error);\n        return {\n            rejections: []\n        };\n    }\n}\n/**\r\n * Clear all decision logs (development/testing only)\r\n */ async function clearDecisionLogs() {\n    try {\n        const result = await request(\"/decision-logs/clear\", {\n            method: \"DELETE\",\n            cache: \"no-store\",\n            credentials: \"omit\"\n        }, true // Bypass rate limiting for user-triggered actions\n        );\n        // Handle rate limiting\n        if (result && typeof result === \"object\" && \"skipped\" in result && result.skipped === true) {\n            throw new Error(\"Request was rate-limited\");\n        }\n        const payload = result;\n        return payload;\n    } catch (error) {\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1FBQ25HO0lBQ0YsRUFBRSxPQUFPeE0sT0FBTztRQUNkaUMsUUFBUWpDLEtBQUssQ0FBQyx3Q0FBd0NBO1FBQ3RELE9BQU87WUFBRWtRLFlBQVksRUFBRTtRQUFDO0lBQzFCO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLGVBQWVFO0lBQ3BCLElBQUk7UUFDRixNQUFNL1AsU0FBUyxNQUFNcUIsUUFDbkIsd0JBQ0E7WUFDRVMsUUFBUTtZQUNSQyxPQUFPO1lBQ1BDLGFBQWE7UUFDZixHQUNBLEtBQUssa0RBQWtEOztRQUd6RCx1QkFBdUI7UUFDdkIsSUFBSWhDLFVBQVUsT0FBT0EsV0FBVyxZQUFZLGFBQWFBLFVBQVUsT0FBZ0JDLE9BQU8sS0FBSyxNQUFNO1lBQ25HLE1BQU0sSUFBSTJDLE1BQU07UUFDbEI7UUFFQSxNQUFNOUIsVUFBVWQ7UUFDaEIsT0FBT2M7SUFDVCxFQUFFLE9BQU9uQixPQUFZO1FBQ25CLE1BQU1BO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYXBpLnRzPzY4YTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWdlbnQsIEFwaVBheWxvYWQsIERpc2N1c3Npb24sIFNlY3RvciwgQ2FuZGxlRGF0YSwgUmVqZWN0ZWRJdGVtLCBWYWx1YXRpb25IaXN0b3J5UG9pbnQgfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHsgZ2V0QXBpQmFzZVVybCwgZ2V0QmFja2VuZEJhc2VVcmwsIGlzRGVza3RvcEFwcCB9IGZyb20gJy4vZGVza3RvcEVudic7XHJcbmltcG9ydCB7IHJhdGVMaW1pdGVkRmV0Y2ggfSBmcm9tICcuL3JhdGVMaW1pdCc7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYW4gZXJyb3IgaXMgYSByYXRlIGxpbWl0IGVycm9yIGZyb20gdGhlIHNlcnZlciAoSFRUUCA0Mjkgb3Igc2VydmVyX3JhdGVfbGltaXQgY29kZSlcclxuICogVGhpcyBzaG91bGQgT05MWSBiZSB1c2VkIGZvciBhY3R1YWwgc2VydmVyIHJhdGUgbGltaXQgZXJyb3JzLCBOT1QgaW50ZXJuYWwgdGhyb3R0bGUgZXJyb3JzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNSYXRlTGltaXRFcnJvcihlcnJvcjogYW55KTogYm9vbGVhbiB7XHJcbiAgLy8gT25seSBjaGVjayBmb3IgYWN0dWFsIEhUVFAgNDI5IHN0YXR1cyBvciBzZXJ2ZXJfcmF0ZV9saW1pdCBjb2RlXHJcbiAgcmV0dXJuIChcclxuICAgIGVycm9yPy5yZXNwb25zZT8uc3RhdHVzID09PSA0MjkgfHxcclxuICAgIGVycm9yPy5jb2RlID09PSAnc2VydmVyX3JhdGVfbGltaXQnIHx8XHJcbiAgICBlcnJvcj8uc3RhdHVzID09PSA0MjlcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYSByZXN1bHQgaW5kaWNhdGVzIGEgc2tpcHBlZCByZXF1ZXN0IChyYXRlLWxpbWl0ZWQpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNTa2lwcGVkUmVzdWx0PFQ+KHJlc3VsdDogVCB8IHsgc2tpcHBlZDogdHJ1ZSB9KTogcmVzdWx0IGlzIHsgc2tpcHBlZDogdHJ1ZSB9IHtcclxuICByZXR1cm4gcmVzdWx0ICE9PSBudWxsICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmICdza2lwcGVkJyBpbiByZXN1bHQgJiYgKHJlc3VsdCBhcyBhbnkpLnNraXBwZWQgPT09IHRydWU7XHJcbn1cclxuXHJcbi8vIFVzZSBkZXNrdG9wLWF3YXJlIGJhc2UgVVJMXHJcbmNvbnN0IGdldEFwaUJhc2UgPSAoKSA9PiB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyBDbGllbnQtc2lkZTogdXNlIGR5bmFtaWMgZGV0ZWN0aW9uXHJcbiAgICByZXR1cm4gZ2V0QXBpQmFzZVVybCgpO1xyXG4gIH1cclxuICAvLyBTZXJ2ZXItc2lkZTogdXNlIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIGRlZmF1bHRcclxuICAvLyBTdXBwb3J0IE5FWFRfUFVCTElDX0FQSV9VUkwgKGZ1bGwgQVBJIFVSTCkgb3IgTkVYVF9QVUJMSUNfTUFYX0JBQ0tFTkRfVVJML05FWFRfUFVCTElDX0JBQ0tFTkRfVVJMIChiYXNlIFVSTClcclxuICBjb25zdCBhcGlVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMO1xyXG4gIGlmIChhcGlVcmwpIHtcclxuICAgIHJldHVybiBhcGlVcmwucmVwbGFjZSgvXFwvJC8sICcnKTtcclxuICB9XHJcbiAgY29uc3QgYmFja2VuZCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX01BWF9CQUNLRU5EX1VSTCB8fCBcclxuICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFDS0VORF9VUkwgfHwgXHJcbiAgICAgICAgICAgICAgICAgICdodHRwOi8vbG9jYWxob3N0OjgwMDAnO1xyXG4gIHJldHVybiBgJHtiYWNrZW5kLnJlcGxhY2UoL1xcLyQvLCAnJyl9L2FwaWA7XHJcbn07XHJcblxyXG5jb25zdCBBUElfQkFTRSA9IGdldEFwaUJhc2UoKTtcclxuY29uc3QgQkFDS0VORCA9IGdldEJhY2tlbmRCYXNlVXJsKCk7XHJcblxyXG5mdW5jdGlvbiB1bndyYXBQYXlsb2FkPFQ+KHBheWxvYWQ6IEFwaVBheWxvYWQ8VD4pOiBUIHtcclxuICBpZiAocGF5bG9hZCAmJiB0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcgJiYgJ2RhdGEnIGluIHBheWxvYWQpIHtcclxuICAgIHJldHVybiAocGF5bG9hZCBhcyB7IGRhdGE6IFQgfSkuZGF0YTtcclxuICB9XHJcblxyXG4gIHJldHVybiBwYXlsb2FkIGFzIFQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgYWdlbnQgSUQ6IGVuc3VyZSBpdCdzIGEgc3RyaW5nIGFuZCB0cmltIHdoaXRlc3BhY2VcclxuICogQHBhcmFtIGlkIC0gQWdlbnQgSUQgKGNhbiBiZSBzdHJpbmcsIG51bWJlciwgb3IgdW5kZWZpbmVkKVxyXG4gKiBAcmV0dXJucyBOb3JtYWxpemVkIHN0cmluZyBJRCBvciBlbXB0eSBzdHJpbmcgaWYgaW52YWxpZFxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplQWdlbnRJZChpZDogYW55KTogc3RyaW5nIHtcclxuICBpZiAoIWlkKSByZXR1cm4gJyc7XHJcbiAgY29uc3Qgbm9ybWFsaXplZCA9IFN0cmluZyhpZCkudHJpbSgpO1xyXG4gIHJldHVybiBub3JtYWxpemVkIHx8ICcnO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0PFQ+KFxyXG4gIHBhdGg6IHN0cmluZywgXHJcbiAgaW5pdD86IFJlcXVlc3RJbml0LFxyXG4gIGJ5cGFzc1JhdGVMaW1pdCA9IGZhbHNlXHJcbik6IFByb21pc2U8VCB8IHsgc2tpcHBlZDogdHJ1ZSB9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIEdldCBBUEkgYmFzZSBVUkwgZHluYW1pY2FsbHkgKGhhbmRsZXMgZGVza3RvcCB2cyB3ZWIgbW9kZSlcclxuICAgIGNvbnN0IGFwaUJhc2UgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IGdldEFwaUJhc2VVcmwoKSA6IEFQSV9CQVNFO1xyXG4gICAgY29uc3QgYmFja2VuZFVybCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gZ2V0QmFja2VuZEJhc2VVcmwoKSA6IEJBQ0tFTkQ7XHJcbiAgICBjb25zdCBmdWxsVXJsID0gYCR7YXBpQmFzZX0ke3BhdGh9YDtcclxuICAgIFxyXG4gICAgLy8gRGVidWcgbG9nZ2luZyAoYWx3YXlzIGxvZyB0byBoZWxwIGRlYnVnIGlzc3VlcylcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBjb25zb2xlLmxvZyhgW0FQSSBSZXF1ZXN0XSAke2luaXQ/Lm1ldGhvZCB8fCAnR0VUJ30gJHtmdWxsVXJsfWApO1xyXG4gICAgICBjb25zb2xlLmxvZyhgW0FQSSBSZXF1ZXN0XSBCYWNrZW5kIGJhc2UgVVJMOiAke2JhY2tlbmRVcmx9YCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmF0ZUxpbWl0ZWRGZXRjaChcclxuICAgICAgZnVsbFVybCwgXHJcbiAgICAgIDUwMCwgLy8gTWluaW11bSBpbnRlcnZhbCBpcyBub3cgNTAwbXNcclxuICAgICAge1xyXG4gICAgICAgIGNhY2hlOiAnbm8tc3RvcmUnLFxyXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnb21pdCcsXHJcbiAgICAgICAgLi4uaW5pdCxcclxuICAgICAgICAvLyBBZGQgdGltZW91dCB0byBwcmV2ZW50IGhhbmdpbmdcclxuICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQoMTAwMDApLCAvLyAxMCBzZWNvbmQgdGltZW91dFxyXG4gICAgICB9LFxyXG4gICAgICB7IGJ5cGFzczogYnlwYXNzUmF0ZUxpbWl0IH1cclxuICAgICk7XHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICBsZXQgZXJyb3JNZXNzYWdlID0gYFJlcXVlc3QgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c31gO1xyXG4gICAgICBsZXQgZXJyb3JSZXNwb25zZTogYW55ID0gbnVsbDtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgZXJyb3JSZXNwb25zZSA9IGVycm9yRGF0YTtcclxuICAgICAgICBpZiAoZXJyb3JEYXRhLmVycm9yKSB7XHJcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGEuZXJyb3I7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXJyb3JEYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JEYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcmVzZXJ2ZSBzdWNjZXNzOiBmYWxzZSBmb3JtYXQgaWYgcHJlc2VudFxyXG4gICAgICAgIGlmIChlcnJvckRhdGEuc3VjY2VzcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIGVycm9yUmVzcG9uc2UgPSB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3JNZXNzYWdlIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIHtcclxuICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG4gICAgICAgIGlmICh0ZXh0KSB7XHJcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSB0ZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpIGFzIGFueTtcclxuICAgICAgaWYgKGVycm9yUmVzcG9uc2UpIHtcclxuICAgICAgICBlcnJvci5yZXNwb25zZSA9IGVycm9yUmVzcG9uc2U7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcGF5bG9hZCA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpIGFzIEFwaVBheWxvYWQ8VD47XHJcbiAgICByZXR1cm4gdW53cmFwUGF5bG9hZDxUPihwYXlsb2FkKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3Igb3IgdGltZW91dFxyXG4gICAgICBjb25zdCBpc05ldHdvcmtFcnJvciA9IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2ZldGNoJykgfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdGYWlsZWQgdG8gZmV0Y2gnKSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ05ldHdvcmtFcnJvcicpIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygndGltZW91dCcpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdhYm9ydGVkJykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlcnJvci5uYW1lID09PSAnVHlwZUVycm9yJyAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdmZXRjaCcpKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChpc05ldHdvcmtFcnJvcikge1xyXG4gICAgICAgIC8vIEFsd2F5cyB1c2UgZHluYW1pYyBkZXRlY3Rpb24gZm9yIGVycm9yIG1lc3NhZ2VzXHJcbiAgICAgICAgY29uc3QgYXBpQmFzZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gZ2V0QXBpQmFzZVVybCgpIDogQVBJX0JBU0U7XHJcbiAgICAgICAgY29uc3QgYmFja2VuZFVybCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gZ2V0QmFja2VuZEJhc2VVcmwoKSA6IEJBQ0tFTkQ7XHJcbiAgICAgICAgY29uc3QgZnVsbFVybCA9IGAke2FwaUJhc2V9JHtwYXRofWA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTG9nIG1vcmUgZGV0YWlsc1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tBUEkgQ29ubmVjdGlvbiBFcnJvcl0nLCB7XHJcbiAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICAgIG5hbWU6IGVycm9yLm5hbWUsXHJcbiAgICAgICAgICBhdHRlbXB0ZWRVcmw6IGZ1bGxVcmwsXHJcbiAgICAgICAgICBiYWNrZW5kVXJsLFxyXG4gICAgICAgICAgYXBpQmFzZSxcclxuICAgICAgICAgIGVudkFwaVVybDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCxcclxuICAgICAgICAgIGVudkJhY2tlbmRVcmw6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX01BWF9CQUNLRU5EX1VSTCB8fCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CQUNLRU5EX1VSTCxcclxuICAgICAgICAgIGlzRGVza3RvcDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBpc0Rlc2t0b3BBcHAoKSA6IGZhbHNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRyeSB0byBjaGVjayBpZiBiYWNrZW5kIGhlYWx0aCBlbmRwb2ludCBpcyByZWFjaGFibGVcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlYWx0aFVybCA9IGAke2JhY2tlbmRVcmx9L2hlYWx0aGA7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbQVBJXSBDaGVja2luZyBiYWNrZW5kIGhlYWx0aCBhdDogJHtoZWFsdGhVcmx9YCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlYWx0aENoZWNrID0gYXdhaXQgZmV0Y2goaGVhbHRoVXJsLCB7IFxyXG4gICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgICAgICAgY2FjaGU6ICduby1zdG9yZScsXHJcbiAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KDIwMDApIC8vIDIgc2Vjb25kIHRpbWVvdXQgZm9yIGhlYWx0aCBjaGVja1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGhlYWx0aENoZWNrLm9rKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tBUEldIEJhY2tlbmQgaGVhbHRoIGNoZWNrIHBhc3NlZCwgYnV0IEFQSSByZXF1ZXN0IGZhaWxlZC4gVGhpcyBtaWdodCBiZSBhIENPUlMgb3Igcm91dGluZyBpc3N1ZS4nKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbQVBJXSBCYWNrZW5kIGhlYWx0aCBjaGVjayBmYWlsZWQgd2l0aCBzdGF0dXM6ICR7aGVhbHRoQ2hlY2suc3RhdHVzfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChoZWFsdGhFcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbQVBJXSBCYWNrZW5kIGhlYWx0aCBjaGVjayBhbHNvIGZhaWxlZDonLCBoZWFsdGhFcnJvcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbm5lY3QgdG8gYmFja2VuZCBzZXJ2ZXIuIFBsZWFzZSBlbnN1cmUgdGhlIGJhY2tlbmQgaXMgcnVubmluZyBvbiAke2JhY2tlbmRVcmx9LiBBdHRlbXB0ZWQgVVJMOiAke2Z1bGxVcmx9YCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIHVua25vd24gZXJyb3Igb2NjdXJyZWQnKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNhbmRsZURhdGEoZW50cnk6IGFueSwgaW5kZXg6IG51bWJlciwgZmFsbGJhY2tQcmljZTogbnVtYmVyKTogQ2FuZGxlRGF0YSB8IG51bGwge1xyXG4gIGlmIChlbnRyeSAmJiB0eXBlb2YgZW50cnkudGltZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGVudHJ5LnZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgcmV0dXJuIGVudHJ5O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdmFsdWVDYW5kaWRhdGUgPVxyXG4gICAgdHlwZW9mIGVudHJ5Py52YWx1ZSA9PT0gJ251bWJlcidcclxuICAgICAgPyBlbnRyeS52YWx1ZVxyXG4gICAgICA6IHR5cGVvZiBlbnRyeT8uY2xvc2UgPT09ICdudW1iZXInXHJcbiAgICAgID8gZW50cnkuY2xvc2VcclxuICAgICAgOiB0eXBlb2YgZmFsbGJhY2tQcmljZSA9PT0gJ251bWJlcidcclxuICAgICAgPyBmYWxsYmFja1ByaWNlXHJcbiAgICAgIDogMDtcclxuXHJcbiAgY29uc3QgaG91cnMgPSAoaW5kZXggKiAyKSAlIDI0O1xyXG4gIGNvbnN0IG1pbnV0ZXMgPSAoaW5kZXggKiA1KSAlIDYwO1xyXG4gIGNvbnN0IHRpbWUgPSBgJHtob3Vycy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9OiR7bWludXRlcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDtcclxuXHJcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodmFsdWVDYW5kaWRhdGUpKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB0aW1lLFxyXG4gICAgdmFsdWU6IE51bWJlcih2YWx1ZUNhbmRpZGF0ZS50b0ZpeGVkKDIpKSxcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBub3JtYWxpemVBZ2VudChyYXc6IGFueSk6IEFnZW50IHtcclxuICBjb25zdCBwZXJmb3JtYW5jZVZhbHVlID1cclxuICAgIHR5cGVvZiByYXc/LnBlcmZvcm1hbmNlID09PSAnbnVtYmVyJ1xyXG4gICAgICA/IHJhdy5wZXJmb3JtYW5jZVxyXG4gICAgICA6IHR5cGVvZiByYXc/LnBlcmZvcm1hbmNlPy5wbmwgPT09ICdudW1iZXInXHJcbiAgICAgID8gcmF3LnBlcmZvcm1hbmNlLnBubFxyXG4gICAgICA6IDA7XHJcblxyXG4gIGNvbnN0IHRyYWRlc0NvdW50ID0gQXJyYXkuaXNBcnJheShyYXc/LnRyYWRlcylcclxuICAgID8gcmF3LnRyYWRlcy5sZW5ndGhcclxuICAgIDogdHlwZW9mIHJhdz8udHJhZGVzID09PSAnbnVtYmVyJ1xyXG4gICAgPyByYXcudHJhZGVzXHJcbiAgICA6IDA7XHJcblxyXG4gIGNvbnN0IHJpc2tUb2xlcmFuY2UgPVxyXG4gICAgcmF3Py5yaXNrVG9sZXJhbmNlID8/XHJcbiAgICByYXc/LnBlcnNvbmFsaXR5Py5yaXNrVG9sZXJhbmNlID8/XHJcbiAgICByYXc/LnBlcnNvbmFsaXR5Py5yaXNrX3RvbGVyYW5jZSA/P1xyXG4gICAgJ1Vua25vd24nO1xyXG4gIGNvbnN0IGRpc3BsYXlOYW1lID1cclxuICAgIHR5cGVvZiByYXc/LmRpc3BsYXlOYW1lID09PSAnc3RyaW5nJyAmJiByYXcuZGlzcGxheU5hbWUudHJpbSgpLmxlbmd0aCA+IDBcclxuICAgICAgPyByYXcuZGlzcGxheU5hbWUudHJpbSgpXHJcbiAgICAgIDogdHlwZW9mIHJhdz8ubmFtZSA9PT0gJ3N0cmluZydcclxuICAgICAgPyByYXcubmFtZVxyXG4gICAgICA6ICdVbm5hbWVkIEFnZW50JztcclxuICBjb25zdCBzdHlsZSA9IHR5cGVvZiByYXc/LnN0eWxlID09PSAnc3RyaW5nJyA/IHJhdy5zdHlsZSA6IHVuZGVmaW5lZDtcclxuICBjb25zdCBpbml0aWFsQ29uZmlkZW5jZSA9XHJcbiAgICB0eXBlb2YgcmF3Py5pbml0aWFsQ29uZmlkZW5jZSA9PT0gJ251bWJlcidcclxuICAgICAgPyByYXcuaW5pdGlhbENvbmZpZGVuY2VcclxuICAgICAgOiB0eXBlb2YgcmF3Py5jb25maWRlbmNlID09PSAnbnVtYmVyJ1xyXG4gICAgICA/IHJhdy5jb25maWRlbmNlXHJcbiAgICAgIDogdW5kZWZpbmVkO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgaWQ6IG5vcm1hbGl6ZUFnZW50SWQocmF3Py5pZCksXHJcbiAgICBuYW1lOiBkaXNwbGF5TmFtZSxcclxuICAgIGRpc3BsYXlOYW1lLFxyXG4gICAgcm9sZTogU3RyaW5nKHJhdz8ucm9sZSA/PyAnYWdlbnQnKSxcclxuICAgIHN0eWxlLFxyXG4gICAgcmlza1RvbGVyYW5jZSxcclxuICAgIHNob3J0QmlvOiB0eXBlb2YgcmF3Py5zaG9ydEJpbyA9PT0gJ3N0cmluZycgPyByYXcuc2hvcnRCaW8gOiB1bmRlZmluZWQsXHJcbiAgICBpbml0aWFsQ29uZmlkZW5jZSxcclxuICAgIHBlcmZvcm1hbmNlOiBOdW1iZXIocGVyZm9ybWFuY2VWYWx1ZSB8fCAwKSxcclxuICAgIHRyYWRlczogTnVtYmVyKHRyYWRlc0NvdW50IHx8IDApLFxyXG4gICAgc3RhdHVzOiAocmF3Py5zdGF0dXMgPz8gJ2lkbGUnKSBhcyBBZ2VudFsnc3RhdHVzJ10sXHJcbiAgICBzZWN0b3JJZDogcmF3Py5zZWN0b3JJZCA/PyByYXc/LnNlY3Rvcl9pZCA/PyBudWxsLFxyXG4gICAgc2VjdG9yU3ltYm9sOiByYXc/LnNlY3RvclN5bWJvbCA/PyByYXc/LnNlY3Rvcl9zeW1ib2wgPz8gdW5kZWZpbmVkLFxyXG4gICAgc2VjdG9yTmFtZTogcmF3Py5zZWN0b3JOYW1lID8/IHJhdz8uc2VjdG9yX25hbWUgPz8gdW5kZWZpbmVkLFxyXG4gICAgcGVyc29uYWxpdHk6IHtcclxuICAgICAgcmlza1RvbGVyYW5jZSxcclxuICAgICAgZGVjaXNpb25TdHlsZTogcmF3Py5wZXJzb25hbGl0eT8uZGVjaXNpb25TdHlsZSA/PyByYXc/LnBlcnNvbmFsaXR5Py5kZWNpc2lvbl9zdHlsZSA/PyAnVW5rbm93bicsXHJcbiAgICB9LFxyXG4gICAgcHJvbXB0OiB0eXBlb2YgcmF3Py5wcm9tcHQgPT09ICdzdHJpbmcnID8gcmF3LnByb21wdCA6IHVuZGVmaW5lZCxcclxuICAgIHByZWZlcmVuY2VzOiByYXc/LnByZWZlcmVuY2VzID8ge1xyXG4gICAgICByaXNrV2VpZ2h0OiB0eXBlb2YgcmF3LnByZWZlcmVuY2VzLnJpc2tXZWlnaHQgPT09ICdudW1iZXInID8gcmF3LnByZWZlcmVuY2VzLnJpc2tXZWlnaHQgOiB1bmRlZmluZWQsXHJcbiAgICAgIHByb2ZpdFdlaWdodDogdHlwZW9mIHJhdy5wcmVmZXJlbmNlcy5wcm9maXRXZWlnaHQgPT09ICdudW1iZXInID8gcmF3LnByZWZlcmVuY2VzLnByb2ZpdFdlaWdodCA6IHVuZGVmaW5lZCxcclxuICAgICAgc3BlZWRXZWlnaHQ6IHR5cGVvZiByYXcucHJlZmVyZW5jZXMuc3BlZWRXZWlnaHQgPT09ICdudW1iZXInID8gcmF3LnByZWZlcmVuY2VzLnNwZWVkV2VpZ2h0IDogdW5kZWZpbmVkLFxyXG4gICAgICBhY2N1cmFjeVdlaWdodDogdHlwZW9mIHJhdy5wcmVmZXJlbmNlcy5hY2N1cmFjeVdlaWdodCA9PT0gJ251bWJlcicgPyByYXcucHJlZmVyZW5jZXMuYWNjdXJhY3lXZWlnaHQgOiB1bmRlZmluZWQsXHJcbiAgICB9IDogdW5kZWZpbmVkLFxyXG4gICAgbW9yYWxlOiB0eXBlb2YgcmF3Py5tb3JhbGUgPT09ICdudW1iZXInID8gcmF3Lm1vcmFsZSA6IHVuZGVmaW5lZCxcclxuICAgIHJld2FyZFBvaW50czogdHlwZW9mIHJhdz8ucmV3YXJkUG9pbnRzID09PSAnbnVtYmVyJyA/IHJhdy5yZXdhcmRQb2ludHMgOiB1bmRlZmluZWQsXHJcbiAgICBjb25maWRlbmNlOiB0eXBlb2YgcmF3Py5jb25maWRlbmNlID09PSAnbnVtYmVyJ1xyXG4gICAgICA/IHJhdy5jb25maWRlbmNlXHJcbiAgICAgIDogdHlwZW9mIGluaXRpYWxDb25maWRlbmNlID09PSAnbnVtYmVyJ1xyXG4gICAgICA/IGluaXRpYWxDb25maWRlbmNlXHJcbiAgICAgIDogMCxcclxuICAgIGNyZWF0ZWRBdDogcmF3Py5jcmVhdGVkQXQgPz8gcmF3Py5jcmVhdGVkX2F0ID8/IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIHJhd1RyYWRlczogQXJyYXkuaXNBcnJheShyYXc/LnRyYWRlcykgPyByYXcudHJhZGVzIDogdW5kZWZpbmVkLFxyXG4gICAgcmF3UGVyZm9ybWFuY2U6IHR5cGVvZiByYXc/LnBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyA/IHJhdy5wZXJmb3JtYW5jZSA6IHVuZGVmaW5lZCxcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBub3JtYWxpemVEaXNjdXNzaW9uKHJhdzogYW55KTogRGlzY3Vzc2lvbiB7XHJcbiAgY29uc3QgbWVzc2FnZXMgPSBBcnJheS5pc0FycmF5KHJhdz8ubWVzc2FnZXMpXHJcbiAgICA/IHJhdy5tZXNzYWdlcy5tYXAoKG1lc3NhZ2U6IGFueSwgaW5kZXg6IG51bWJlcikgPT4gKHtcclxuICAgICAgICBpZDogU3RyaW5nKG1lc3NhZ2U/LmlkID8/IGAke3Jhdz8uaWQgPz8gJ2Rpc2MnfS1tc2ctJHtpbmRleH1gKSxcclxuICAgICAgICBhZ2VudElkOiBtZXNzYWdlPy5hZ2VudElkID8/IG1lc3NhZ2U/LmFnZW50X2lkID8/IHVuZGVmaW5lZCxcclxuICAgICAgICBhZ2VudE5hbWU6IFN0cmluZyhtZXNzYWdlPy5hZ2VudE5hbWUgPz8gbWVzc2FnZT8uYWdlbnRfbmFtZSA/PyAnVW5rbm93biBBZ2VudCcpLFxyXG4gICAgICAgIGNvbnRlbnQ6IFN0cmluZyhtZXNzYWdlPy5jb250ZW50ID8/ICcnKSxcclxuICAgICAgICB0aW1lc3RhbXA6IG1lc3NhZ2U/LnRpbWVzdGFtcCA/PyBtZXNzYWdlPy5jcmVhdGVkQXQgPz8gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIHJvbGU6IG1lc3NhZ2U/LnJvbGUgPz8gdW5kZWZpbmVkLFxyXG4gICAgICB9KSlcclxuICAgIDogW107XHJcblxyXG4gIGNvbnN0IGNoZWNrbGlzdERyYWZ0ID0gQXJyYXkuaXNBcnJheShyYXc/LmNoZWNrbGlzdERyYWZ0KVxyXG4gICAgPyByYXcuY2hlY2tsaXN0RHJhZnQubWFwKChpdGVtOiBhbnkpID0+ICh7XHJcbiAgICAgICAgaWQ6IFN0cmluZyhpdGVtPy5pZCA/PyAnJyksXHJcbiAgICAgICAgdGV4dDogU3RyaW5nKGl0ZW0/LnRleHQgPz8gJycpLFxyXG4gICAgICAgIGFnZW50SWQ6IGl0ZW0/LmFnZW50SWQgPz8gaXRlbT8uYWdlbnRfaWQgPz8gdW5kZWZpbmVkLFxyXG4gICAgICAgIGFnZW50TmFtZTogaXRlbT8uYWdlbnROYW1lID8/IGl0ZW0/LmFnZW50X25hbWUgPz8gdW5kZWZpbmVkLFxyXG4gICAgICAgIHJvdW5kOiB0eXBlb2YgaXRlbT8ucm91bmQgPT09ICdudW1iZXInID8gaXRlbS5yb3VuZCA6IHVuZGVmaW5lZCxcclxuICAgICAgfSkpXHJcbiAgICA6IHVuZGVmaW5lZDtcclxuXHJcbiAgY29uc3QgY2hlY2tsaXN0ID0gQXJyYXkuaXNBcnJheShyYXc/LmNoZWNrbGlzdClcclxuICAgID8gcmF3LmNoZWNrbGlzdC5tYXAoKGl0ZW06IGFueSkgPT4gKHtcclxuICAgICAgICBpZDogU3RyaW5nKGl0ZW0/LmlkID8/ICcnKSxcclxuICAgICAgICB0ZXh0OiBTdHJpbmcoaXRlbT8udGV4dCA/PyAnJyksXHJcbiAgICAgICAgYWdlbnRJZDogaXRlbT8uYWdlbnRJZCA/PyBpdGVtPy5hZ2VudF9pZCA/PyBpdGVtPy5zb3VyY2VBZ2VudElkID8/IHVuZGVmaW5lZCxcclxuICAgICAgICBhZ2VudE5hbWU6IGl0ZW0/LmFnZW50TmFtZSA/PyBpdGVtPy5hZ2VudF9uYW1lID8/IHVuZGVmaW5lZCxcclxuICAgICAgICByb3VuZDogdHlwZW9mIGl0ZW0/LnJvdW5kID09PSAnbnVtYmVyJyA/IGl0ZW0ucm91bmQgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgYWN0aW9uOiBpdGVtPy5hY3Rpb24gPz8gdW5kZWZpbmVkLFxyXG4gICAgICAgIGFtb3VudDogdHlwZW9mIGl0ZW0/LmFtb3VudCA9PT0gJ251bWJlcicgPyBpdGVtLmFtb3VudCA6IHVuZGVmaW5lZCxcclxuICAgICAgICBhbGxvY2F0aW9uUGVyY2VudDogdHlwZW9mIGl0ZW0/LmFsbG9jYXRpb25QZXJjZW50ID09PSAnbnVtYmVyJyA/IGl0ZW0uYWxsb2NhdGlvblBlcmNlbnQgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgc3ltYm9sOiBpdGVtPy5zeW1ib2wgPz8gdW5kZWZpbmVkLFxyXG4gICAgICAgIHJlYXNvbjogaXRlbT8ucmVhc29uID8/IGl0ZW0/LnJlYXNvbmluZyA/PyB1bmRlZmluZWQsXHJcbiAgICAgICAgcmVhc29uaW5nOiBpdGVtPy5yZWFzb25pbmcgPz8gaXRlbT8ucmVhc29uID8/IHVuZGVmaW5lZCxcclxuICAgICAgICByYXRpb25hbGU6IGl0ZW0/LnJhdGlvbmFsZSA/PyBpdGVtPy5yZWFzb25pbmcgPz8gaXRlbT8ucmVhc29uID8/IHVuZGVmaW5lZCxcclxuICAgICAgICBjb25maWRlbmNlOiB0eXBlb2YgaXRlbT8uY29uZmlkZW5jZSA9PT0gJ251bWJlcicgPyBpdGVtLmNvbmZpZGVuY2UgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgYXBwcm92YWxTdGF0dXM6IGl0ZW0/LmFwcHJvdmFsU3RhdHVzID8/IHVuZGVmaW5lZCxcclxuICAgICAgICBhcHByb3ZhbFJlYXNvbjogaXRlbT8uYXBwcm92YWxSZWFzb24gPz8gdW5kZWZpbmVkLFxyXG4gICAgICAgIHN0YXR1czogaXRlbT8uc3RhdHVzID8/IHVuZGVmaW5lZCxcclxuICAgICAgfSkpXHJcbiAgICA6IHVuZGVmaW5lZDtcclxuXHJcbiAgY29uc3QgZmluYWxpemVkQ2hlY2tsaXN0ID0gQXJyYXkuaXNBcnJheShyYXc/LmZpbmFsaXplZENoZWNrbGlzdClcclxuICAgID8gcmF3LmZpbmFsaXplZENoZWNrbGlzdC5tYXAoKGl0ZW06IGFueSkgPT4gKHtcclxuICAgICAgICBpZDogU3RyaW5nKGl0ZW0/LmlkID8/ICcnKSxcclxuICAgICAgICB0ZXh0OiBTdHJpbmcoaXRlbT8udGV4dCA/PyAnJyksXHJcbiAgICAgICAgYWdlbnRJZDogaXRlbT8uYWdlbnRJZCA/PyBpdGVtPy5hZ2VudF9pZCA/PyBpdGVtPy5zb3VyY2VBZ2VudElkID8/IHVuZGVmaW5lZCxcclxuICAgICAgICBhZ2VudE5hbWU6IGl0ZW0/LmFnZW50TmFtZSA/PyBpdGVtPy5hZ2VudF9uYW1lID8/IHVuZGVmaW5lZCxcclxuICAgICAgICByb3VuZDogdHlwZW9mIGl0ZW0/LnJvdW5kID09PSAnbnVtYmVyJyA/IGl0ZW0ucm91bmQgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgYWN0aW9uOiBpdGVtPy5hY3Rpb24gPz8gdW5kZWZpbmVkLFxyXG4gICAgICAgIGFtb3VudDogdHlwZW9mIGl0ZW0/LmFtb3VudCA9PT0gJ251bWJlcicgPyBpdGVtLmFtb3VudCA6IHVuZGVmaW5lZCxcclxuICAgICAgICBhbGxvY2F0aW9uUGVyY2VudDogdHlwZW9mIGl0ZW0/LmFsbG9jYXRpb25QZXJjZW50ID09PSAnbnVtYmVyJyA/IGl0ZW0uYWxsb2NhdGlvblBlcmNlbnQgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgc3ltYm9sOiBpdGVtPy5zeW1ib2wgPz8gdW5kZWZpbmVkLFxyXG4gICAgICAgIHJlYXNvbjogaXRlbT8ucmVhc29uID8/IGl0ZW0/LnJlYXNvbmluZyA/PyB1bmRlZmluZWQsXHJcbiAgICAgICAgcmVhc29uaW5nOiBpdGVtPy5yZWFzb25pbmcgPz8gaXRlbT8ucmVhc29uID8/IHVuZGVmaW5lZCxcclxuICAgICAgICByYXRpb25hbGU6IGl0ZW0/LnJhdGlvbmFsZSA/PyBpdGVtPy5yZWFzb25pbmcgPz8gaXRlbT8ucmVhc29uID8/IHVuZGVmaW5lZCxcclxuICAgICAgICBjb25maWRlbmNlOiB0eXBlb2YgaXRlbT8uY29uZmlkZW5jZSA9PT0gJ251bWJlcicgPyBpdGVtLmNvbmZpZGVuY2UgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgYXBwcm92YWxTdGF0dXM6IGl0ZW0/LmFwcHJvdmFsU3RhdHVzID8/ICdhY2NlcHRlZCcsIC8vIEZpbmFsaXplZCBpdGVtcyBhcmUgYWNjZXB0ZWQgYnkgZGVmYXVsdFxyXG4gICAgICAgIGFwcHJvdmFsUmVhc29uOiBpdGVtPy5hcHByb3ZhbFJlYXNvbiA/PyB1bmRlZmluZWQsXHJcbiAgICAgICAgc3RhdHVzOiBpdGVtPy5zdGF0dXMgPz8gJ0FQUFJPVkVEJyxcclxuICAgICAgfSkpXHJcbiAgICA6IHVuZGVmaW5lZDtcclxuXHJcbiAgLy8gTm9ybWFsaXplIGNoZWNrbGlzdEl0ZW1zIC0gcHJpbWFyeSBmaWVsZCAodW5pZmllZCBhcnJheSlcclxuICAvLyBJZiBjaGVja2xpc3RJdGVtcyBpcyBwcm92aWRlZCwgdXNlIGl0OyBvdGhlcndpc2UgY29tYmluZSBjaGVja2xpc3QgYW5kIGZpbmFsaXplZENoZWNrbGlzdFxyXG4gIGNvbnN0IGNoZWNrbGlzdEl0ZW1zID0gQXJyYXkuaXNBcnJheShyYXc/LmNoZWNrbGlzdEl0ZW1zKVxyXG4gICAgPyByYXcuY2hlY2tsaXN0SXRlbXMubWFwKChpdGVtOiBhbnkpID0+ICh7XHJcbiAgICAgICAgaWQ6IFN0cmluZyhpdGVtPy5pZCA/PyAnJyksXHJcbiAgICAgICAgdGV4dDogU3RyaW5nKGl0ZW0/LnRleHQgPz8gJycpLFxyXG4gICAgICAgIGFnZW50SWQ6IGl0ZW0/LmFnZW50SWQgPz8gaXRlbT8uYWdlbnRfaWQgPz8gaXRlbT8uc291cmNlQWdlbnRJZCA/PyB1bmRlZmluZWQsXHJcbiAgICAgICAgYWdlbnROYW1lOiBpdGVtPy5hZ2VudE5hbWUgPz8gaXRlbT8uYWdlbnRfbmFtZSA/PyB1bmRlZmluZWQsXHJcbiAgICAgICAgcm91bmQ6IHR5cGVvZiBpdGVtPy5yb3VuZCA9PT0gJ251bWJlcicgPyBpdGVtLnJvdW5kIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIGFjdGlvbjogaXRlbT8uYWN0aW9uID8/IHVuZGVmaW5lZCxcclxuICAgICAgICBhbW91bnQ6IHR5cGVvZiBpdGVtPy5hbW91bnQgPT09ICdudW1iZXInID8gaXRlbS5hbW91bnQgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgYWxsb2NhdGlvblBlcmNlbnQ6IHR5cGVvZiBpdGVtPy5hbGxvY2F0aW9uUGVyY2VudCA9PT0gJ251bWJlcicgPyBpdGVtLmFsbG9jYXRpb25QZXJjZW50IDogdW5kZWZpbmVkLFxyXG4gICAgICAgIHN5bWJvbDogaXRlbT8uc3ltYm9sID8/IHVuZGVmaW5lZCxcclxuICAgICAgICByZWFzb246IGl0ZW0/LnJlYXNvbiA/PyBpdGVtPy5yZWFzb25pbmcgPz8gdW5kZWZpbmVkLFxyXG4gICAgICAgIHJlYXNvbmluZzogaXRlbT8ucmVhc29uaW5nID8/IGl0ZW0/LnJlYXNvbiA/PyB1bmRlZmluZWQsXHJcbiAgICAgICAgcmF0aW9uYWxlOiBpdGVtPy5yYXRpb25hbGUgPz8gaXRlbT8ucmVhc29uaW5nID8/IGl0ZW0/LnJlYXNvbiA/PyB1bmRlZmluZWQsXHJcbiAgICAgICAgY29uZmlkZW5jZTogdHlwZW9mIGl0ZW0/LmNvbmZpZGVuY2UgPT09ICdudW1iZXInID8gaXRlbS5jb25maWRlbmNlIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIGFwcHJvdmFsU3RhdHVzOiBpdGVtPy5hcHByb3ZhbFN0YXR1cyA/PyB1bmRlZmluZWQsXHJcbiAgICAgICAgYXBwcm92YWxSZWFzb246IGl0ZW0/LmFwcHJvdmFsUmVhc29uID8/IHVuZGVmaW5lZCxcclxuICAgICAgICBzdGF0dXM6IGl0ZW0/LnN0YXR1cyA/PyB1bmRlZmluZWQsXHJcbiAgICAgIH0pKVxyXG4gICAgOiAoY2hlY2tsaXN0ICYmIGZpbmFsaXplZENoZWNrbGlzdCBcclxuICAgICAgICA/IFsuLi4oY2hlY2tsaXN0IHx8IFtdKSwgLi4uKGZpbmFsaXplZENoZWNrbGlzdCB8fCBbXSldXHJcbiAgICAgICAgOiBjaGVja2xpc3QgfHwgZmluYWxpemVkQ2hlY2tsaXN0IHx8IHVuZGVmaW5lZCk7XHJcblxyXG4gIC8vIE5vcm1hbGl6ZSBzdGF0dXM6IG9ubHkgJ2luX3Byb2dyZXNzJyBvciAnZGVjaWRlZCcgYXJlIHZhbGlkXHJcbiAgbGV0IG5vcm1hbGl6ZWRTdGF0dXMgPSByYXc/LnN0YXR1cyA/PyAnaW5fcHJvZ3Jlc3MnO1xyXG4gIGlmIChub3JtYWxpemVkU3RhdHVzID09PSAnYWN0aXZlJyB8fCBub3JtYWxpemVkU3RhdHVzID09PSAnb3BlbicgfHwgbm9ybWFsaXplZFN0YXR1cyA9PT0gJ09QRU4nIHx8IFxyXG4gICAgICBub3JtYWxpemVkU3RhdHVzID09PSAnY3JlYXRlZCcgfHwgbm9ybWFsaXplZFN0YXR1cyA9PT0gJ2luX3Byb2dyZXNzJykge1xyXG4gICAgbm9ybWFsaXplZFN0YXR1cyA9ICdpbl9wcm9ncmVzcyc7XHJcbiAgfSBlbHNlIGlmIChub3JtYWxpemVkU3RhdHVzID09PSAnY2xvc2VkJyB8fCBub3JtYWxpemVkU3RhdHVzID09PSAnQ0xPU0VEJyB8fCBcclxuICAgICAgICAgICAgIG5vcm1hbGl6ZWRTdGF0dXMgPT09ICdhcmNoaXZlZCcgfHwgbm9ybWFsaXplZFN0YXR1cyA9PT0gJ2ZpbmFsaXplZCcgfHwgXHJcbiAgICAgICAgICAgICBub3JtYWxpemVkU3RhdHVzID09PSAnYWNjZXB0ZWQnIHx8IG5vcm1hbGl6ZWRTdGF0dXMgPT09ICdjb21wbGV0ZWQnIHx8XHJcbiAgICAgICAgICAgICBub3JtYWxpemVkU3RhdHVzID09PSAnZGVjaWRlZCcpIHtcclxuICAgIG5vcm1hbGl6ZWRTdGF0dXMgPSAnZGVjaWRlZCc7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgaWQ6IFN0cmluZyhyYXc/LmlkID8/ICcnKSxcclxuICAgIHNlY3RvcklkOiBTdHJpbmcocmF3Py5zZWN0b3JJZCA/PyByYXc/LnNlY3Rvcl9pZCA/PyAnJyksXHJcbiAgICB0aXRsZTogU3RyaW5nKHJhdz8udGl0bGUgPz8gJ1VudGl0bGVkIGRpc2N1c3Npb24nKSxcclxuICAgIHN0YXR1czogbm9ybWFsaXplZFN0YXR1cyBhcyBEaXNjdXNzaW9uWydzdGF0dXMnXSxcclxuICAgIGFnZW50SWRzOiBBcnJheS5pc0FycmF5KHJhdz8uYWdlbnRJZHMpXHJcbiAgICAgID8gcmF3LmFnZW50SWRzLm1hcCgoYWdlbnRJZDogYW55KSA9PiBTdHJpbmcoYWdlbnRJZCkpXHJcbiAgICAgIDogQXJyYXkuaXNBcnJheShyYXc/LmFnZW50X2lkcylcclxuICAgICAgPyByYXcuYWdlbnRfaWRzLm1hcCgoYWdlbnRJZDogYW55KSA9PiBTdHJpbmcoYWdlbnRJZCkpXHJcbiAgICAgIDogW10sXHJcbiAgICBtZXNzYWdlcyxcclxuICAgIG1lc3NhZ2VzQ291bnQ6IHR5cGVvZiByYXc/Lm1lc3NhZ2VzQ291bnQgPT09ICdudW1iZXInIFxyXG4gICAgICA/IHJhdy5tZXNzYWdlc0NvdW50IFxyXG4gICAgICA6ICh0eXBlb2YgcmF3Py5tZXNzYWdlQ291bnQgPT09ICdudW1iZXInID8gcmF3Lm1lc3NhZ2VDb3VudCA6IHVuZGVmaW5lZCksXHJcbiAgICBjcmVhdGVkQXQ6IHJhdz8uY3JlYXRlZEF0ID8/IHJhdz8uY3JlYXRlZF9hdCA/PyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICB1cGRhdGVkQXQ6IHJhdz8udXBkYXRlZEF0ID8/IHJhdz8udXBkYXRlZF9hdCA/PyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICBzZWN0b3JTeW1ib2w6IHJhdz8uc2VjdG9yU3ltYm9sID8/IHJhdz8uc2VjdG9yX3N5bWJvbCA/PyB1bmRlZmluZWQsXHJcbiAgICBzZWN0b3JOYW1lOiByYXc/LnNlY3Rvck5hbWUgPz8gcmF3Py5zZWN0b3JfbmFtZSA/PyB1bmRlZmluZWQsXHJcbiAgICByb3VuZDogdHlwZW9mIHJhdz8ucm91bmQgPT09ICdudW1iZXInID8gcmF3LnJvdW5kIDogdW5kZWZpbmVkLFxyXG4gICAgY2hlY2tsaXN0SXRlbXM6IGNoZWNrbGlzdEl0ZW1zICYmIGNoZWNrbGlzdEl0ZW1zLmxlbmd0aCA+IDAgPyBjaGVja2xpc3RJdGVtcyA6IHVuZGVmaW5lZCxcclxuICAgIGNoZWNrbGlzdERyYWZ0OiBjaGVja2xpc3REcmFmdCAmJiBjaGVja2xpc3REcmFmdC5sZW5ndGggPiAwID8gY2hlY2tsaXN0RHJhZnQgOiB1bmRlZmluZWQsXHJcbiAgICBjaGVja2xpc3Q6IGNoZWNrbGlzdCAmJiBjaGVja2xpc3QubGVuZ3RoID4gMCA/IGNoZWNrbGlzdCA6IHVuZGVmaW5lZCxcclxuICAgIGZpbmFsaXplZENoZWNrbGlzdDogZmluYWxpemVkQ2hlY2tsaXN0ICYmIGZpbmFsaXplZENoZWNrbGlzdC5sZW5ndGggPiAwID8gZmluYWxpemVkQ2hlY2tsaXN0IDogdW5kZWZpbmVkLFxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlY3RvcihyYXc6IGFueSk6IFNlY3RvciB7XHJcbiAgY29uc3QgYmFzZVByaWNlID0gTnVtYmVyKHJhdz8uY3VycmVudFByaWNlID8/IHJhdz8ucHJpY2UgPz8gMCk7XHJcblxyXG4gIGNvbnN0IGFnZW50cyA9IEFycmF5LmlzQXJyYXkocmF3Py5hZ2VudHMpXHJcbiAgICA/IHJhdy5hZ2VudHMubWFwKChhZ2VudDogYW55KSA9PlxyXG4gICAgICAgIG5vcm1hbGl6ZUFnZW50KHtcclxuICAgICAgICAgIC4uLmFnZW50LFxyXG4gICAgICAgICAgc2VjdG9ySWQ6IGFnZW50Py5zZWN0b3JJZCA/PyByYXc/LmlkLFxyXG4gICAgICAgICAgc2VjdG9yU3ltYm9sOiBhZ2VudD8uc2VjdG9yU3ltYm9sID8/IHJhdz8uc3ltYm9sID8/IHJhdz8uc2VjdG9yU3ltYm9sLFxyXG4gICAgICAgICAgc2VjdG9yTmFtZTogYWdlbnQ/LnNlY3Rvck5hbWUgPz8gcmF3Py5uYW1lID8/IHJhdz8uc2VjdG9yTmFtZSxcclxuICAgICAgICB9KSxcclxuICAgICAgKVxyXG4gICAgOiBbXTtcclxuXHJcbiAgY29uc3QgY2FuZGxlRGF0YSA9IEFycmF5LmlzQXJyYXkocmF3Py5jYW5kbGVEYXRhKVxyXG4gICAgPyByYXcuY2FuZGxlRGF0YVxyXG4gICAgICAgIC5tYXAoKGVudHJ5OiBhbnksIGluZGV4OiBudW1iZXIpID0+IG5vcm1hbGl6ZUNhbmRsZURhdGEoZW50cnksIGluZGV4LCBiYXNlUHJpY2UpKVxyXG4gICAgICAgIC5maWx0ZXIoKHBvaW50OiBhbnkpOiBwb2ludCBpcyBDYW5kbGVEYXRhID0+IEJvb2xlYW4ocG9pbnQpKVxyXG4gICAgOiBbXTtcclxuXHJcbiAgY29uc3QgZGlzY3Vzc2lvbnMgPSBBcnJheS5pc0FycmF5KHJhdz8uZGlzY3Vzc2lvbnMpXHJcbiAgICA/IHJhdy5kaXNjdXNzaW9ucy5tYXAoKGRpc2N1c3Npb246IGFueSkgPT5cclxuICAgICAgICBub3JtYWxpemVEaXNjdXNzaW9uKHtcclxuICAgICAgICAgIC4uLmRpc2N1c3Npb24sXHJcbiAgICAgICAgICBzZWN0b3JJZDogZGlzY3Vzc2lvbj8uc2VjdG9ySWQgPz8gcmF3Py5pZCxcclxuICAgICAgICAgIHNlY3RvclN5bWJvbDogZGlzY3Vzc2lvbj8uc2VjdG9yU3ltYm9sID8/IHJhdz8uc3ltYm9sID8/IHJhdz8uc2VjdG9yU3ltYm9sLFxyXG4gICAgICAgICAgc2VjdG9yTmFtZTogZGlzY3Vzc2lvbj8uc2VjdG9yTmFtZSA/PyByYXc/Lm5hbWUgPz8gcmF3Py5zZWN0b3JOYW1lLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICApXHJcbiAgICA6IFtdO1xyXG5cclxuICAvLyBDYWxjdWxhdGUgYWN0aXZlQWdlbnRzIGlmIG5vdCBwcm92aWRlZFxyXG4gIGNvbnN0IGFjdGl2ZUFnZW50cyA9IHR5cGVvZiByYXc/LmFjdGl2ZUFnZW50cyA9PT0gJ251bWJlcicgXHJcbiAgICA/IHJhdy5hY3RpdmVBZ2VudHMgXHJcbiAgICA6IHR5cGVvZiByYXc/LmFjdGl2ZV9hZ2VudHMgPT09ICdudW1iZXInXHJcbiAgICA/IHJhdy5hY3RpdmVfYWdlbnRzXHJcbiAgICA6IGFnZW50cy5maWx0ZXIoKGFnZW50OiBhbnkpID0+IGFnZW50LnN0YXR1cyA9PT0gJ2FjdGl2ZScpLmxlbmd0aDtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGlkOiBTdHJpbmcocmF3Py5pZCA/PyAnJyksXHJcbiAgICAvLyBQcmltYXJ5IHN0YW5kYXJkaXplZCBmaWVsZHMgKHByZWZlciBuYW1lL3N5bWJvbCwgZmFsbGJhY2sgdG8gc2VjdG9yTmFtZS9zZWN0b3JTeW1ib2wpXHJcbiAgICBuYW1lOiBTdHJpbmcocmF3Py5uYW1lID8/IHJhdz8uc2VjdG9yTmFtZSA/PyAnVW5rbm93biBTZWN0b3InKSxcclxuICAgIHN5bWJvbDogU3RyaW5nKHJhdz8uc3ltYm9sID8/IHJhdz8uc2VjdG9yU3ltYm9sID8/ICdOL0EnKSxcclxuICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZmllbGRzIChpbmNsdWRlIGlmIHByZXNlbnQpXHJcbiAgICBzZWN0b3JOYW1lOiByYXc/LnNlY3Rvck5hbWUgPz8gcmF3Py5uYW1lID8/IHVuZGVmaW5lZCxcclxuICAgIHNlY3RvclN5bWJvbDogcmF3Py5zZWN0b3JTeW1ib2wgPz8gcmF3Py5zeW1ib2wgPz8gdW5kZWZpbmVkLFxyXG4gICAgLy8gQ29yZSBtYXJrZXQgZGF0YSBmaWVsZHNcclxuICAgIGN1cnJlbnRQcmljZTogTnVtYmVyLmlzRmluaXRlKGJhc2VQcmljZSkgPyBOdW1iZXIoYmFzZVByaWNlLnRvRml4ZWQoMikpIDogMCxcclxuICAgIGNoYW5nZTogTnVtYmVyKHJhdz8uY2hhbmdlID8/IDApLFxyXG4gICAgY2hhbmdlUGVyY2VudDogTnVtYmVyKHJhdz8uY2hhbmdlUGVyY2VudCA/PyByYXc/LmNoYW5nZV9wZXJjZW50ID8/IDApLFxyXG4gICAgdm9sdW1lOiBOdW1iZXIocmF3Py52b2x1bWUgPz8gMCksXHJcbiAgICAvLyBSaXNrIGFuZCB2b2xhdGlsaXR5XHJcbiAgICB2b2xhdGlsaXR5OiB0eXBlb2YgcmF3Py52b2xhdGlsaXR5ID09PSAnbnVtYmVyJyA/IE51bWJlcihyYXcudm9sYXRpbGl0eS50b0ZpeGVkKDQpKSA6IHVuZGVmaW5lZCxcclxuICAgIHJpc2tTY29yZTogdHlwZW9mIHJhdz8ucmlza1Njb3JlID09PSAnbnVtYmVyJyA/IE51bWJlcihyYXcucmlza1Njb3JlKSA6IHVuZGVmaW5lZCxcclxuICAgIC8vIEFnZW50IGFuZCBhY3Rpdml0eSBmaWVsZHNcclxuICAgIGFnZW50cyxcclxuICAgIGFjdGl2ZUFnZW50czogTnVtYmVyKGFjdGl2ZUFnZW50cyksXHJcbiAgICBidXlBZ2VudHM6IHR5cGVvZiByYXc/LmJ1eUFnZW50cyA9PT0gJ251bWJlcicgPyBOdW1iZXIocmF3LmJ1eUFnZW50cykgOiB0eXBlb2YgcmF3Py5idXlfYWdlbnRzID09PSAnbnVtYmVyJyA/IE51bWJlcihyYXcuYnV5X2FnZW50cykgOiB1bmRlZmluZWQsXHJcbiAgICBzZWxsQWdlbnRzOiB0eXBlb2YgcmF3Py5zZWxsQWdlbnRzID09PSAnbnVtYmVyJyA/IE51bWJlcihyYXcuc2VsbEFnZW50cykgOiB0eXBlb2YgcmF3Py5zZWxsX2FnZW50cyA9PT0gJ251bWJlcicgPyBOdW1iZXIocmF3LnNlbGxfYWdlbnRzKSA6IHVuZGVmaW5lZCxcclxuICAgIHN0YXR1c1BlcmNlbnQ6IE51bWJlcihyYXc/LnN0YXR1c1BlcmNlbnQgPz8gcmF3Py5zdGF0dXNfcGVyY2VudCA/PyAwKSxcclxuICAgIC8vIFBlcmZvcm1hbmNlIGFuZCBiYWxhbmNlXHJcbiAgICBwZXJmb3JtYW5jZTogcmF3Py5wZXJmb3JtYW5jZSAmJiB0eXBlb2YgcmF3LnBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyA/IHJhdy5wZXJmb3JtYW5jZSA6IHVuZGVmaW5lZCxcclxuICAgIGJhbGFuY2U6IHR5cGVvZiByYXc/LmJhbGFuY2UgPT09ICdudW1iZXInID8gTnVtYmVyKHJhdy5iYWxhbmNlLnRvRml4ZWQoMikpIDogMCwgLy8gRGVmYXVsdCBiYWxhbmNlIHRvIDAgZm9yIG5ldyBzZWN0b3JzXHJcbiAgICAvLyBBZGRpdGlvbmFsIGZpZWxkc1xyXG4gICAgbGFzdFNpbXVsYXRlZFByaWNlOiB0eXBlb2YgcmF3Py5sYXN0U2ltdWxhdGVkUHJpY2UgPT09ICdudW1iZXInID8gTnVtYmVyKHJhdy5sYXN0U2ltdWxhdGVkUHJpY2UudG9GaXhlZCgyKSkgOiByYXc/Lmxhc3RTaW11bGF0ZWRQcmljZSA9PT0gbnVsbCA/IG51bGwgOiB1bmRlZmluZWQsXHJcbiAgICBpbml0aWFsUHJpY2U6IHR5cGVvZiByYXc/LmluaXRpYWxQcmljZSA9PT0gJ251bWJlcicgJiYgcmF3LmluaXRpYWxQcmljZSA+IDAgPyBOdW1iZXIocmF3LmluaXRpYWxQcmljZS50b0ZpeGVkKDIpKSA6IHVuZGVmaW5lZCxcclxuICAgIGRpc2N1c3Npb25zLFxyXG4gICAgY2FuZGxlRGF0YSxcclxuICAgIGRlc2NyaXB0aW9uOiB0eXBlb2YgcmF3Py5kZXNjcmlwdGlvbiA9PT0gJ3N0cmluZycgPyByYXcuZGVzY3JpcHRpb24gOiB1bmRlZmluZWQsXHJcbiAgICBjcmVhdGVkQXQ6IHJhdz8uY3JlYXRlZEF0ID8/IHJhdz8uY3JlYXRlZF9hdCA/PyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoU2VjdG9ycygpOiBQcm9taXNlPFNlY3RvcltdPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Q8U2VjdG9yW10+KCcvc2VjdG9ycycpO1xyXG4gICAgXHJcbiAgICAvLyBIYW5kbGUgcmF0ZSBsaW1pdGluZyAtIHJldHVybiBlbXB0eSBhcnJheSB3aGVuIHNraXBwZWRcclxuICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3NraXBwZWQnIGluIHJlc3VsdCAmJiAocmVzdWx0IGFzIGFueSkuc2tpcHBlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHBheWxvYWQgPSByZXN1bHQgYXMgU2VjdG9yW107XHJcbiAgICBpZiAoIXBheWxvYWQpIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkLm1hcChub3JtYWxpemVTZWN0b3IpIDogW107XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHNlY3RvcnM6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hTZWN0b3JCeUlkKGlkOiBzdHJpbmcpOiBQcm9taXNlPFNlY3RvciB8IG51bGw+IHtcclxuICBpZiAoIWlkKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIE5vcm1hbGl6ZSBJRCB0byBsb3dlcmNhc2UgZm9yIGNvbnNpc3RlbnQgY2FzZS1zZW5zaXRpdml0eVxyXG4gIGNvbnN0IG5vcm1hbGl6ZWRJZCA9IFN0cmluZyhpZCkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XHJcbiAgXHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdDxTZWN0b3I+KGAvc2VjdG9ycy8ke25vcm1hbGl6ZWRJZH1gKTtcclxuICBcclxuICAvLyBIYW5kbGUgcmF0ZSBsaW1pdGluZyAtIHJldHVybiBudWxsIHdoZW4gc2tpcHBlZFxyXG4gIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3NraXBwZWQnIGluIHJlc3VsdCAmJiAocmVzdWx0IGFzIGFueSkuc2tpcHBlZCA9PT0gdHJ1ZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IHBheWxvYWQgPSByZXN1bHQgYXMgU2VjdG9yO1xyXG4gIHJldHVybiBwYXlsb2FkID8gbm9ybWFsaXplU2VjdG9yKHBheWxvYWQpIDogbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZldGNoIHZhbHVhdGlvbiBoaXN0b3J5IGZvciBhIHNlY3RvclxyXG4gKiBAcGFyYW0gc2VjdG9ySWQgLSBTZWN0b3IgSURcclxuICogQHBhcmFtIHdpbmRvdyAtIFRpbWUgd2luZG93ICgnMWQnLCAnMXcnLCAnMW0nLCAnM20nLCAnNm0nLCAnMXknLCAnbWF4Jywgb3IgaG91cnMgbGlrZSAnNmgnLCAnMjRoJylcclxuICogQHJldHVybnMgQXJyYXkgb2YgdmFsdWF0aW9uIGhpc3RvcnkgcG9pbnRzXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hWYWx1YXRpb25IaXN0b3J5KFxyXG4gIHNlY3RvcklkOiBzdHJpbmcsXHJcbiAgd2luZG93OiBzdHJpbmcgPSAnMW0nXHJcbik6IFByb21pc2U8VmFsdWF0aW9uSGlzdG9yeVBvaW50W10+IHtcclxuICBpZiAoIXNlY3RvcklkKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICAvLyBOb3JtYWxpemUgSUQgdG8gbG93ZXJjYXNlIGZvciBjb25zaXN0ZW50IGNhc2Utc2Vuc2l0aXZpdHlcclxuICBjb25zdCBub3JtYWxpemVkSWQgPSBTdHJpbmcoc2VjdG9ySWQpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xyXG4gIFxyXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Q8eyBzdWNjZXNzOiBib29sZWFuOyBjb3VudDogbnVtYmVyOyBkYXRhOiBWYWx1YXRpb25IaXN0b3J5UG9pbnRbXSB9PihcclxuICAgIGAvcHJpY2UtaGlzdG9yeS8ke25vcm1hbGl6ZWRJZH0/d2luZG93PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHdpbmRvdyl9YFxyXG4gICk7XHJcbiAgXHJcbiAgLy8gSGFuZGxlIHJhdGUgbGltaXRpbmcgLSByZXR1cm4gZW1wdHkgYXJyYXkgd2hlbiBza2lwcGVkXHJcbiAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiAnc2tpcHBlZCcgaW4gcmVzdWx0ICYmIChyZXN1bHQgYXMgYW55KS5za2lwcGVkID09PSB0cnVlKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEhhbmRsZSBib3RoIGRpcmVjdCBhcnJheSByZXNwb25zZSBhbmQgd3JhcHBlZCByZXNwb25zZVxyXG4gIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ2RhdGEnIGluIHJlc3VsdCAmJiBBcnJheS5pc0FycmF5KHJlc3VsdC5kYXRhKSkge1xyXG4gICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gW107XHJcbn1cclxuXHJcbi8vIE1hbmFnZXIgQWdlbnQgQVBJIGZ1bmN0aW9uc1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hBZ2VudHMoKTogUHJvbWlzZTxBZ2VudFtdPiB7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdDxBZ2VudFtdPignL2FnZW50cycpO1xyXG4gIFxyXG4gIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nIC0gcmV0dXJuIGVtcHR5IGFycmF5IHdoZW4gc2tpcHBlZFxyXG4gIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3NraXBwZWQnIGluIHJlc3VsdCAmJiAocmVzdWx0IGFzIGFueSkuc2tpcHBlZCA9PT0gdHJ1ZSkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBwYXlsb2FkID0gcmVzdWx0IGFzIEFnZW50W107XHJcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkLm1hcChhZ2VudCA9PiBub3JtYWxpemVBZ2VudChhZ2VudCkpIDogW107XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEFnZW50QnlJZChpZDogc3RyaW5nKTogUHJvbWlzZTxBZ2VudCB8IG51bGw+IHtcclxuICAvLyBOb3JtYWxpemUgYW5kIHZhbGlkYXRlIElEIGJlZm9yZSBtYWtpbmcgcmVxdWVzdFxyXG4gIGNvbnN0IG5vcm1hbGl6ZWRJZCA9IG5vcm1hbGl6ZUFnZW50SWQoaWQpO1xyXG4gIGlmICghbm9ybWFsaXplZElkKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1tmZXRjaEFnZW50QnlJZF0gSW52YWxpZCBvciBlbXB0eSBhZ2VudCBJRCBwcm92aWRlZCcpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0PEFnZW50PihgL2FnZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChub3JtYWxpemVkSWQpfWApO1xyXG4gIFxyXG4gIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nIC0gcmV0dXJuIG51bGwgd2hlbiBza2lwcGVkXHJcbiAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiAnc2tpcHBlZCcgaW4gcmVzdWx0ICYmIChyZXN1bHQgYXMgYW55KS5za2lwcGVkID09PSB0cnVlKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgXHJcbiAgY29uc3QgcGF5bG9hZCA9IHJlc3VsdCBhcyBBZ2VudDtcclxuICByZXR1cm4gcGF5bG9hZCA/IG5vcm1hbGl6ZUFnZW50KHBheWxvYWQpIDogbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEaXNjdXNzaW9uU3VtbWFyeSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICB0aXRsZTogc3RyaW5nO1xyXG4gIHNlY3Rvcjogc3RyaW5nOyAvLyBTZWN0b3Igc3ltYm9sXHJcbiAgc2VjdG9ySWQ/OiBzdHJpbmc7IC8vIEtlZXAgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuICBzdGF0dXM6IERpc2N1c3Npb25bJ3N0YXR1cyddO1xyXG4gIHVwZGF0ZWRBdDogc3RyaW5nO1xyXG4gIHBhcnRpY2lwYW50czogc3RyaW5nW107IC8vIEFnZW50IElEcyBhcnJheVxyXG4gIG1lc3NhZ2VzQ291bnQ6IG51bWJlcjsgLy8gVXBkYXRlZCB0byBtYXRjaCBiYWNrZW5kICh3YXMgbWVzc2FnZUNvdW50KVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2luYXRlZERpc2N1c3Npb25zUmVzcG9uc2Uge1xyXG4gIGRpc2N1c3Npb25zOiBEaXNjdXNzaW9uU3VtbWFyeVtdO1xyXG4gIHBhZ2luYXRpb246IHtcclxuICAgIHBhZ2U6IG51bWJlcjtcclxuICAgIHBhZ2VTaXplOiBudW1iZXI7XHJcbiAgICB0b3RhbDogbnVtYmVyO1xyXG4gICAgdG90YWxQYWdlczogbnVtYmVyO1xyXG4gIH07XHJcbiAgc3RhdHVzQ291bnRzPzoge1xyXG4gICAgYWxsOiBudW1iZXI7XHJcbiAgICBpbl9wcm9ncmVzczogbnVtYmVyO1xyXG4gICAgZGVjaWRlZDogbnVtYmVyO1xyXG4gICAgcmVqZWN0ZWQ6IG51bWJlcjtcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hEaXNjdXNzaW9ucyhwYWdlOiBudW1iZXIgPSAxLCBwYWdlU2l6ZTogbnVtYmVyID0gMjAsIHNlY3RvcklkPzogc3RyaW5nLCBzdGF0dXM/OiBzdHJpbmcpOiBQcm9taXNlPFBhZ2luYXRlZERpc2N1c3Npb25zUmVzcG9uc2U+IHtcclxuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcclxuICAgIHBhZ2U6IHBhZ2UudG9TdHJpbmcoKSxcclxuICAgIHBhZ2VTaXplOiBwYWdlU2l6ZS50b1N0cmluZygpLFxyXG4gIH0pO1xyXG4gIGlmIChzZWN0b3JJZCkge1xyXG4gICAgcGFyYW1zLmFwcGVuZCgnc2VjdG9ySWQnLCBzZWN0b3JJZCk7XHJcbiAgfVxyXG4gIGlmIChzdGF0dXMgJiYgc3RhdHVzICE9PSAnYWxsJykge1xyXG4gICAgcGFyYW1zLmFwcGVuZCgnc3RhdHVzJywgc3RhdHVzKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Q8UGFnaW5hdGVkRGlzY3Vzc2lvbnNSZXNwb25zZT4oYC9kaXNjdXNzaW9ucz8ke3BhcmFtcy50b1N0cmluZygpfWApO1xyXG4gIFxyXG4gIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nIC0gcmV0dXJuIGVtcHR5IHJlc3VsdCB3aGVuIHNraXBwZWRcclxuICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmICdza2lwcGVkJyBpbiByZXN1bHQgJiYgKHJlc3VsdCBhcyBhbnkpLnNraXBwZWQgPT09IHRydWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRpc2N1c3Npb25zOiBbXSxcclxuICAgICAgcGFnaW5hdGlvbjoge1xyXG4gICAgICAgIHBhZ2UsXHJcbiAgICAgICAgcGFnZVNpemUsXHJcbiAgICAgICAgdG90YWw6IDAsXHJcbiAgICAgICAgdG90YWxQYWdlczogMFxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuICBcclxuICBjb25zdCBwYXlsb2FkID0gcmVzdWx0IGFzIFBhZ2luYXRlZERpc2N1c3Npb25zUmVzcG9uc2U7XHJcbiAgcmV0dXJuIHBheWxvYWQgfHwge1xyXG4gICAgZGlzY3Vzc2lvbnM6IFtdLFxyXG4gICAgcGFnaW5hdGlvbjoge1xyXG4gICAgICBwYWdlLFxyXG4gICAgICBwYWdlU2l6ZSxcclxuICAgICAgdG90YWw6IDAsXHJcbiAgICAgIHRvdGFsUGFnZXM6IDBcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hEaXNjdXNzaW9uTWVzc2FnZXMoZGlzY3Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPE1lc3NhZ2VbXT4ge1xyXG4gIGlmICghZGlzY3Vzc2lvbklkKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0PHsgbWVzc2FnZXM6IE1lc3NhZ2VbXSB9PihgL2Rpc2N1c3Npb25zLyR7ZGlzY3Vzc2lvbklkfS9tZXNzYWdlc2ApO1xyXG4gIFxyXG4gIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nIC0gcmV0dXJuIGVtcHR5IGFycmF5IHdoZW4gc2tpcHBlZFxyXG4gIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3NraXBwZWQnIGluIHJlc3VsdCAmJiAocmVzdWx0IGFzIGFueSkuc2tpcHBlZCA9PT0gdHJ1ZSkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBwYXlsb2FkID0gcmVzdWx0IGFzIHsgbWVzc2FnZXM6IE1lc3NhZ2VbXSB9O1xyXG4gIGlmIChwYXlsb2FkICYmIEFycmF5LmlzQXJyYXkocGF5bG9hZC5tZXNzYWdlcykpIHtcclxuICAgIHJldHVybiBwYXlsb2FkLm1lc3NhZ2VzLm1hcCgobWVzc2FnZTogYW55LCBpbmRleDogbnVtYmVyKSA9PiAoe1xyXG4gICAgICBpZDogU3RyaW5nKG1lc3NhZ2U/LmlkID8/IGAke2Rpc2N1c3Npb25JZH0tbXNnLSR7aW5kZXh9YCksXHJcbiAgICAgIGFnZW50SWQ6IG1lc3NhZ2U/LmFnZW50SWQgPz8gbWVzc2FnZT8uYWdlbnRfaWQgPz8gdW5kZWZpbmVkLFxyXG4gICAgICBhZ2VudE5hbWU6IFN0cmluZyhtZXNzYWdlPy5hZ2VudE5hbWUgPz8gbWVzc2FnZT8uYWdlbnRfbmFtZSA/PyAnVW5rbm93biBBZ2VudCcpLFxyXG4gICAgICBjb250ZW50OiBTdHJpbmcobWVzc2FnZT8uY29udGVudCA/PyAnJyksXHJcbiAgICAgIHRpbWVzdGFtcDogbWVzc2FnZT8udGltZXN0YW1wID8/IG1lc3NhZ2U/LmNyZWF0ZWRBdCA/PyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIHJvbGU6IG1lc3NhZ2U/LnJvbGUgPz8gdW5kZWZpbmVkLFxyXG4gICAgfSkpO1xyXG4gIH1cclxuICByZXR1cm4gW107XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaERpc2N1c3Npb25CeUlkKGlkOiBzdHJpbmcpOiBQcm9taXNlPERpc2N1c3Npb24gfCBudWxsPiB7XHJcbiAgaWYgKCFpZCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0PERpc2N1c3Npb24+KGAvZGlzY3Vzc2lvbnMvJHtpZH1gKTtcclxuICBcclxuICAvLyBIYW5kbGUgcmF0ZSBsaW1pdGluZyAtIHJldHVybiBudWxsIHdoZW4gc2tpcHBlZFxyXG4gIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3NraXBwZWQnIGluIHJlc3VsdCAmJiAocmVzdWx0IGFzIGFueSkuc2tpcHBlZCA9PT0gdHJ1ZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nIC0gcmV0dXJuIG51bGwgd2hlbiBza2lwcGVkXHJcbiAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiAnc2tpcHBlZCcgaW4gcmVzdWx0ICYmIChyZXN1bHQgYXMgYW55KS5za2lwcGVkID09PSB0cnVlKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgXHJcbiAgY29uc3QgcGF5bG9hZCA9IHJlc3VsdCBhcyBEaXNjdXNzaW9uO1xyXG4gIHJldHVybiBwYXlsb2FkID8gbm9ybWFsaXplRGlzY3Vzc2lvbihwYXlsb2FkKSA6IG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFJlamVjdGVkSXRlbXMoKTogUHJvbWlzZTx7IHJlamVjdGVkOiBSZWplY3RlZEl0ZW1bXSB9PiB7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdDx7IHJlamVjdGVkOiBSZWplY3RlZEl0ZW1bXSB9PignL2Rpc2N1c3Npb25zL3JlamVjdGVkLWl0ZW1zJyk7XHJcbiAgXHJcbiAgLy8gSGFuZGxlIHJhdGUgbGltaXRpbmcgLSByZXR1cm4gZW1wdHkgYXJyYXkgd2hlbiBza2lwcGVkXHJcbiAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiAnc2tpcHBlZCcgaW4gcmVzdWx0ICYmIChyZXN1bHQgYXMgYW55KS5za2lwcGVkID09PSB0cnVlKSB7XHJcbiAgICByZXR1cm4geyByZWplY3RlZDogW10gfTtcclxuICB9XHJcbiAgXHJcbiAgY29uc3QgcGF5bG9hZCA9IHJlc3VsdCBhcyB7IHJlamVjdGVkOiBSZWplY3RlZEl0ZW1bXSB9O1xyXG4gIHJldHVybiBwYXlsb2FkIHx8IHsgcmVqZWN0ZWQ6IFtdIH07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2tsaXN0SXRlbVJlc3BvbnNlIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xyXG4gIGFjdGlvbj86IHN0cmluZztcclxuICBhbW91bnQ/OiBudW1iZXI7XHJcbiAgYWxsb2NhdGlvblBlcmNlbnQ/OiBudW1iZXI7IC8vIDDigJMxMDBcclxuICBzeW1ib2w/OiBzdHJpbmc7XHJcbiAgcmVhc29uPzogc3RyaW5nO1xyXG4gIHJlYXNvbmluZz86IHN0cmluZztcclxuICByYXRpb25hbGU/OiBzdHJpbmc7IC8vIFByaW1hcnkgZmllbGQgKDHigJMyIHNlbnRlbmNlcywgY29uY2lzZSlcclxuICBjb25maWRlbmNlPzogbnVtYmVyOyAvLyAw4oCTMTAwXHJcbiAgcm91bmQ/OiBudW1iZXI7XHJcbiAgYWdlbnRJZD86IHN0cmluZztcclxuICBhZ2VudE5hbWU/OiBzdHJpbmc7XHJcbiAgYXBwcm92YWxTdGF0dXM/OiAncGVuZGluZycgfCAnYWNjZXB0ZWQnIHwgJ3JlamVjdGVkJyB8ICdhY2NlcHRfcmVqZWN0aW9uJztcclxuICBhcHByb3ZhbFJlYXNvbj86IHN0cmluZyB8IG51bGw7XHJcbiAgYXBwcm92ZWRBdD86IHN0cmluZztcclxuICAvLyBSZXZpc2lvbiBtZXRhZGF0YVxyXG4gIHN0YXR1cz86ICdQRU5ESU5HJyB8ICdBUFBST1ZFRCcgfCAnUkVKRUNURUQnIHwgJ0VYRUNVVEVEJyB8ICdSRVZJU0VfUkVRVUlSRUQnIHwgJ0FDQ0VQVF9SRUpFQ1RJT04nIHwgJ1JFU1VCTUlUVEVEJyB8IHN0cmluZztcclxuICByZXF1aXJlc1JldmlzaW9uPzogYm9vbGVhbjtcclxuICBtYW5hZ2VyUmVhc29uPzogc3RyaW5nIHwgbnVsbDtcclxuICByZXZpc2lvbkNvdW50PzogbnVtYmVyO1xyXG4gIHJldmlzZWRBdD86IHN0cmluZztcclxuICAvLyBNYW5hZ2VyIGRlY2lzaW9uIG1ldGFkYXRhIC0gYXV0aG9yaXRhdGl2ZSBzdGF0ZVxyXG4gIGRlY2lzaW9uQnk/OiBzdHJpbmc7IC8vIE1hbmFnZXIgSUQgd2hvIG1hZGUgdGhlIGRlY2lzaW9uXHJcbiAgZGVjaWRlZEF0Pzogc3RyaW5nOyAvLyBJU08gdGltZXN0YW1wIHdoZW4gZGVjaXNpb24gd2FzIG1hZGVcclxuICByZWplY3Rpb25SZWFzb24/OiB7XHJcbiAgICBzY29yZT86IG51bWJlcjtcclxuICAgIGFwcHJvdmFsVGhyZXNob2xkPzogbnVtYmVyO1xyXG4gICAgc2NvcmVCcmVha2Rvd24/OiB7XHJcbiAgICAgIHdvcmtlckNvbmZpZGVuY2U/OiBudW1iZXI7XHJcbiAgICAgIGV4cGVjdGVkSW1wYWN0PzogbnVtYmVyO1xyXG4gICAgICByaXNrTGV2ZWw/OiBudW1iZXI7XHJcbiAgICAgIGFsaWdubWVudFdpdGhTZWN0b3JHb2FsPzogbnVtYmVyO1xyXG4gICAgICBub3JtYWxpemVkUmlza1Njb3JlPzogbnVtYmVyO1xyXG4gICAgICB3ZWlnaHRzPzoge1xyXG4gICAgICAgIHdvcmtlckNvbmZpZGVuY2U/OiBudW1iZXI7XHJcbiAgICAgICAgZXhwZWN0ZWRJbXBhY3Q/OiBudW1iZXI7XHJcbiAgICAgICAgcmlza0xldmVsPzogbnVtYmVyO1xyXG4gICAgICAgIGFsaWdubWVudFdpdGhTZWN0b3JHb2FsPzogbnVtYmVyO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICAgIHJlYXNvbj86IHN0cmluZztcclxuICAgIGNvbmZpZGVuY2U/OiBudW1iZXI7XHJcbiAgICBlZmZlY3RpdmVUaHJlc2hvbGQ/OiBudW1iZXI7XHJcbiAgICByZXF1aXJlZEltcHJvdmVtZW50cz86IHN0cmluZ1tdO1xyXG4gIH07XHJcbiAgcHJldmlvdXNWZXJzaW9ucz86IEFycmF5PHtcclxuICAgIGFjdGlvbj86IHN0cmluZztcclxuICAgIGFtb3VudD86IG51bWJlcjtcclxuICAgIGFsbG9jYXRpb25QZXJjZW50PzogbnVtYmVyO1xyXG4gICAgcmVhc29uPzogc3RyaW5nO1xyXG4gICAgY29uZmlkZW5jZT86IG51bWJlcjtcclxuICAgIHRpbWVzdGFtcDogc3RyaW5nO1xyXG4gIH0+O1xyXG4gIC8vIEV4ZWN1dGlvbiBtZXRhZGF0YVxyXG4gIGV4ZWN1dGVkQXQ/OiBzdHJpbmcgfCBudWxsOyAvLyBJU08gdGltZXN0YW1wIHdoZW4gaXRlbSB3YXMgZXhlY3V0ZWRcclxuICBleGVjdXRpb25Mb2dJZD86IHN0cmluZyB8IG51bGw7IC8vIElEIG9mIHRoZSBleGVjdXRpb24gbG9nIGVudHJ5XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2tsaXN0UmVzcG9uc2Uge1xyXG4gIGRpc2N1c3Npb25JZDogc3RyaW5nO1xyXG4gIHN0YXR1czogc3RyaW5nO1xyXG4gIGNoZWNrbGlzdEl0ZW1zOiBDaGVja2xpc3RJdGVtUmVzcG9uc2VbXTsgLy8gUHJpbWFyeSBmaWVsZCAtIHVuaWZpZWQgYXJyYXlcclxuICBjaGVja2xpc3Q/OiBDaGVja2xpc3RJdGVtUmVzcG9uc2VbXTsgLy8gTGVnYWN5IGZpZWxkXHJcbiAgZmluYWxpemVkQ2hlY2tsaXN0PzogQ2hlY2tsaXN0SXRlbVJlc3BvbnNlW107IC8vIExlZ2FjeSBmaWVsZFxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDaGVja2xpc3QoZGlzY3Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPENoZWNrbGlzdFJlc3BvbnNlIHwgbnVsbD4ge1xyXG4gIGlmICghZGlzY3Vzc2lvbklkKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Q8Q2hlY2tsaXN0UmVzcG9uc2U+KGAvZGlzY3Vzc2lvbnMvJHtkaXNjdXNzaW9uSWR9L2NoZWNrbGlzdGApO1xyXG4gIFxyXG4gIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nIC0gcmV0dXJuIG51bGwgd2hlbiBza2lwcGVkXHJcbiAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiAnc2tpcHBlZCcgaW4gcmVzdWx0ICYmIChyZXN1bHQgYXMgYW55KS5za2lwcGVkID09PSB0cnVlKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHJlc3VsdCBhcyBDaGVja2xpc3RSZXNwb25zZSB8IG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUmVqZWN0ZWRJdGVtc1Jlc3BvbnNlIHtcclxuICBzdWNjZXNzOiBib29sZWFuO1xyXG4gIGRpc2N1c3Npb25JZDogc3RyaW5nO1xyXG4gIHJlamVjdGVkSXRlbXM6IENoZWNrbGlzdEl0ZW1SZXNwb25zZVtdO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmVqZWN0ZWRJdGVtc0ZvckRpc2N1c3Npb24oZGlzY3Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPFJlamVjdGVkSXRlbXNSZXNwb25zZSB8IG51bGw+IHtcclxuICBpZiAoIWRpc2N1c3Npb25JZCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0PFJlamVjdGVkSXRlbXNSZXNwb25zZT4oYC9kaXNjdXNzaW9ucy8ke2Rpc2N1c3Npb25JZH0vcmVqZWN0ZWQtaXRlbXNgKTtcclxuICBcclxuICAvLyBIYW5kbGUgcmF0ZSBsaW1pdGluZyAtIHJldHVybiBudWxsIHdoZW4gc2tpcHBlZFxyXG4gIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3NraXBwZWQnIGluIHJlc3VsdCAmJiAocmVzdWx0IGFzIGFueSkuc2tpcHBlZCA9PT0gdHJ1ZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiByZXN1bHQgYXMgUmVqZWN0ZWRJdGVtc1Jlc3BvbnNlIHwgbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTdWJtaXRSZXZpc2lvblBhcmFtcyB7XHJcbiAgaXRlbUlkOiBzdHJpbmc7XHJcbiAgbmV3Q29udGVudDoge1xyXG4gICAgYWN0aW9uPzogc3RyaW5nO1xyXG4gICAgYW1vdW50PzogbnVtYmVyO1xyXG4gICAgcmVhc29uPzogc3RyaW5nO1xyXG4gICAgcmVhc29uaW5nPzogc3RyaW5nO1xyXG4gICAgY29uZmlkZW5jZT86IG51bWJlcjtcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN1Ym1pdFJldmlzaW9uUmVzcG9uc2Uge1xyXG4gIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgZGlzY3Vzc2lvbklkOiBzdHJpbmc7XHJcbiAgaXRlbUlkOiBzdHJpbmc7XHJcbiAgaXRlbToge1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIGFjdGlvbj86IHN0cmluZztcclxuICAgIGFtb3VudD86IG51bWJlcjtcclxuICAgIHJlYXNvbj86IHN0cmluZztcclxuICAgIGNvbmZpZGVuY2U/OiBudW1iZXI7XHJcbiAgICBzdGF0dXM6IHN0cmluZztcclxuICAgIHJldmlzaW9uQ291bnQ6IG51bWJlcjtcclxuICB9O1xyXG4gIGFsbEl0ZW1zUmVzb2x2ZWQ/OiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3VibWl0UmV2aXNpb24oXHJcbiAgZGlzY3Vzc2lvbklkOiBzdHJpbmcsXHJcbiAgcGFyYW1zOiBTdWJtaXRSZXZpc2lvblBhcmFtc1xyXG4pOiBQcm9taXNlPFN1Ym1pdFJldmlzaW9uUmVzcG9uc2U+IHtcclxuICBpZiAoIWRpc2N1c3Npb25JZCB8fCAhcGFyYW1zLml0ZW1JZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaXNjdXNzaW9uSWQgYW5kIGl0ZW1JZCBhcmUgcmVxdWlyZWQnKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Q8U3VibWl0UmV2aXNpb25SZXNwb25zZT4oYC9kaXNjdXNzaW9ucy8ke2Rpc2N1c3Npb25JZH0vc3VibWl0LXJldmlzaW9uYCwge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICBoZWFkZXJzOiB7XHJcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICB9LFxyXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICBpdGVtSWQ6IHBhcmFtcy5pdGVtSWQsXHJcbiAgICAgIG5ld0NvbnRlbnQ6IHBhcmFtcy5uZXdDb250ZW50LFxyXG4gICAgfSksXHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gSGFuZGxlIHJhdGUgbGltaXRpbmcgLSB0aHJvdyBnZW5lcmljIGVycm9yIGZvciBtdXRhdGlvbnNcclxuICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmICdza2lwcGVkJyBpbiByZXN1bHQgJiYgKHJlc3VsdCBhcyBhbnkpLnNraXBwZWQgPT09IHRydWUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdCB3YXMgc2tpcHBlZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHJlc3VsdCBhcyBTdWJtaXRSZXZpc2lvblJlc3BvbnNlO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFjY2VwdFJlamVjdGlvblJlc3BvbnNlIHtcclxuICBzdWNjZXNzOiBib29sZWFuO1xyXG4gIGRpc2N1c3Npb25JZDogc3RyaW5nO1xyXG4gIGl0ZW1JZDogc3RyaW5nO1xyXG4gIGl0ZW06IHtcclxuICAgIGlkOiBzdHJpbmc7XHJcbiAgICBzdGF0dXM6IHN0cmluZztcclxuICB9O1xyXG4gIGFsbEl0ZW1zUmVzb2x2ZWQ/OiBib29sZWFuO1xyXG4gIGRpc2N1c3Npb25TdGF0dXM/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhY2NlcHRSZWplY3Rpb24oXHJcbiAgZGlzY3Vzc2lvbklkOiBzdHJpbmcsXHJcbiAgaXRlbUlkOiBzdHJpbmdcclxuKTogUHJvbWlzZTxBY2NlcHRSZWplY3Rpb25SZXNwb25zZT4ge1xyXG4gIGlmICghZGlzY3Vzc2lvbklkIHx8ICFpdGVtSWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignZGlzY3Vzc2lvbklkIGFuZCBpdGVtSWQgYXJlIHJlcXVpcmVkJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0PEFjY2VwdFJlamVjdGlvblJlc3BvbnNlPihgL2Rpc2N1c3Npb25zLyR7ZGlzY3Vzc2lvbklkfS9hY2NlcHQtcmVqZWN0aW9uYCwge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICBoZWFkZXJzOiB7XHJcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICB9LFxyXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICBpdGVtSWQ6IGl0ZW1JZCxcclxuICAgIH0pLFxyXG4gIH0pO1xyXG4gIFxyXG4gIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nIC0gdGhyb3cgZ2VuZXJpYyBlcnJvciBmb3IgbXV0YXRpb25zXHJcbiAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiAnc2tpcHBlZCcgaW4gcmVzdWx0ICYmIChyZXN1bHQgYXMgYW55KS5za2lwcGVkID09PSB0cnVlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3Qgd2FzIHNraXBwZWQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiByZXN1bHQgYXMgQWNjZXB0UmVqZWN0aW9uUmVzcG9uc2U7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVEaXNjdXNzaW9uKFxyXG4gIHNlY3RvcklkOiBzdHJpbmcsXHJcbiAgdGl0bGU6IHN0cmluZyxcclxuICBhZ2VudElkczogc3RyaW5nW10gPSBbXVxyXG4pOiBQcm9taXNlPERpc2N1c3Npb24+IHtcclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0PERpc2N1c3Npb24+KCcvZGlzY3Vzc2lvbnMnLCB7XHJcbiAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgIGhlYWRlcnM6IHtcclxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgIH0sXHJcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgIHNlY3RvcklkLFxyXG4gICAgICB0aXRsZSxcclxuICAgICAgYWdlbnRJZHMsXHJcbiAgICB9KSxcclxuICB9KTtcclxuICBcclxuICAvLyBIYW5kbGUgcmF0ZSBsaW1pdGluZyAtIHRocm93IGdlbmVyaWMgZXJyb3IgZm9yIG11dGF0aW9uc1xyXG4gIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3NraXBwZWQnIGluIHJlc3VsdCAmJiAocmVzdWx0IGFzIGFueSkuc2tpcHBlZCA9PT0gdHJ1ZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IHdhcyBza2lwcGVkLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBwYXlsb2FkID0gcmVzdWx0IGFzIERpc2N1c3Npb247XHJcbiAgcmV0dXJuIG5vcm1hbGl6ZURpc2N1c3Npb24ocGF5bG9hZCk7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWRkTWVzc2FnZVBhcmFtcyB7XHJcbiAgYWdlbnRJZDogc3RyaW5nO1xyXG4gIGNvbnRlbnQ6IHN0cmluZztcclxuICByb2xlPzogc3RyaW5nO1xyXG4gIGFnZW50TmFtZT86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZERpc2N1c3Npb25NZXNzYWdlKFxyXG4gIGRpc2N1c3Npb25JZDogc3RyaW5nLFxyXG4gIG1lc3NhZ2U6IEFkZE1lc3NhZ2VQYXJhbXNcclxuKTogUHJvbWlzZTxEaXNjdXNzaW9uPiB7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdDxEaXNjdXNzaW9uPihgL2Rpc2N1c3Npb25zLyR7ZGlzY3Vzc2lvbklkfS9tZXNzYWdlYCwge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICBoZWFkZXJzOiB7XHJcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICB9LFxyXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksXHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gSGFuZGxlIHJhdGUgbGltaXRpbmcgLSB0aHJvdyBnZW5lcmljIGVycm9yIGZvciBtdXRhdGlvbnNcclxuICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmICdza2lwcGVkJyBpbiByZXN1bHQgJiYgKHJlc3VsdCBhcyBhbnkpLnNraXBwZWQgPT09IHRydWUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdCB3YXMgc2tpcHBlZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcclxuICB9XHJcbiAgXHJcbiAgY29uc3QgcGF5bG9hZCA9IHJlc3VsdCBhcyBEaXNjdXNzaW9uO1xyXG4gIHJldHVybiBub3JtYWxpemVEaXNjdXNzaW9uKHBheWxvYWQpO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xvc2VEaXNjdXNzaW9uKGRpc2N1c3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTxEaXNjdXNzaW9uPiB7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdDxEaXNjdXNzaW9uPihgL2Rpc2N1c3Npb25zLyR7ZGlzY3Vzc2lvbklkfS9jbG9zZWAsIHtcclxuICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgaGVhZGVyczoge1xyXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgfSxcclxuICB9KTtcclxuICBcclxuICAvLyBIYW5kbGUgcmF0ZSBsaW1pdGluZyAtIHRocm93IGdlbmVyaWMgZXJyb3IgZm9yIG11dGF0aW9uc1xyXG4gIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3NraXBwZWQnIGluIHJlc3VsdCAmJiAocmVzdWx0IGFzIGFueSkuc2tpcHBlZCA9PT0gdHJ1ZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IHdhcyBza2lwcGVkLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBwYXlsb2FkID0gcmVzdWx0IGFzIERpc2N1c3Npb247XHJcbiAgcmV0dXJuIG5vcm1hbGl6ZURpc2N1c3Npb24ocGF5bG9hZCk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydERpc2N1c3Npb25Sb3VuZHMoZGlzY3Vzc2lvbklkOiBzdHJpbmcsIG51bVJvdW5kczogbnVtYmVyID0gMyk6IFByb21pc2U8RGlzY3Vzc2lvbj4ge1xyXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Q8RGlzY3Vzc2lvbj4oYC9kaXNjdXNzaW9ucy8ke2Rpc2N1c3Npb25JZH0vc3RhcnQtcm91bmRzYCwge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICBoZWFkZXJzOiB7XHJcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICB9LFxyXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBudW1Sb3VuZHMgfSksXHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gSGFuZGxlIHJhdGUgbGltaXRpbmcgLSB0aHJvdyBnZW5lcmljIGVycm9yIGZvciBtdXRhdGlvbnNcclxuICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmICdza2lwcGVkJyBpbiByZXN1bHQgJiYgKHJlc3VsdCBhcyBhbnkpLnNraXBwZWQgPT09IHRydWUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdCB3YXMgc2tpcHBlZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcclxuICB9XHJcbiAgXHJcbiAgY29uc3QgcGF5bG9hZCA9IHJlc3VsdCBhcyBEaXNjdXNzaW9uO1xyXG4gIHJldHVybiBub3JtYWxpemVEaXNjdXNzaW9uKHBheWxvYWQpO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlRGlzY3Vzc2lvbihkaXNjdXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Q8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlPzogc3RyaW5nIH0+KGAvZGlzY3Vzc2lvbnMvJHtkaXNjdXNzaW9uSWR9YCwge1xyXG4gICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgIC8vIERvbid0IHNlbmQgQ29udGVudC1UeXBlIGhlYWRlciBmb3IgREVMRVRFIHJlcXVlc3RzIHdpdGhvdXQgYm9keVxyXG4gIH0pO1xyXG4gIFxyXG4gIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nIC0gdGhyb3cgZ2VuZXJpYyBlcnJvciBmb3IgbXV0YXRpb25zXHJcbiAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiAnc2tpcHBlZCcgaW4gcmVzdWx0ICYmIChyZXN1bHQgYXMgYW55KS5za2lwcGVkID09PSB0cnVlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3Qgd2FzIHNraXBwZWQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3N1Y2Nlc3MnIGluIHJlc3VsdCAmJiAhcmVzdWx0LnN1Y2Nlc3MpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigocmVzdWx0IGFzIGFueSkuZXJyb3IgfHwgJ0ZhaWxlZCB0byBkZWxldGUgZGlzY3Vzc2lvbicpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFyY2hpdmVEaXNjdXNzaW9uKGRpc2N1c3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTxEaXNjdXNzaW9uPiB7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdDxEaXNjdXNzaW9uPihgL2Rpc2N1c3Npb25zLyR7ZGlzY3Vzc2lvbklkfS9hcmNoaXZlYCwge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICBoZWFkZXJzOiB7XHJcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICB9LFxyXG4gIH0pO1xyXG4gIFxyXG4gIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nIC0gdGhyb3cgZ2VuZXJpYyBlcnJvciBmb3IgbXV0YXRpb25zXHJcbiAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiAnc2tpcHBlZCcgaW4gcmVzdWx0ICYmIChyZXN1bHQgYXMgYW55KS5za2lwcGVkID09PSB0cnVlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3Qgd2FzIHNraXBwZWQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IHBheWxvYWQgPSByZXN1bHQgYXMgRGlzY3Vzc2lvbjtcclxuICByZXR1cm4gbm9ybWFsaXplRGlzY3Vzc2lvbihwYXlsb2FkKTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFjY2VwdERpc2N1c3Npb24oZGlzY3Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPERpc2N1c3Npb24+IHtcclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0PERpc2N1c3Npb24+KGAvZGlzY3Vzc2lvbnMvJHtkaXNjdXNzaW9uSWR9L2FjY2VwdGAsIHtcclxuICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgaGVhZGVyczoge1xyXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgfSxcclxuICB9KTtcclxuICBcclxuICAvLyBIYW5kbGUgcmF0ZSBsaW1pdGluZyAtIHRocm93IGdlbmVyaWMgZXJyb3IgZm9yIG11dGF0aW9uc1xyXG4gIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3NraXBwZWQnIGluIHJlc3VsdCAmJiAocmVzdWx0IGFzIGFueSkuc2tpcHBlZCA9PT0gdHJ1ZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IHdhcyBza2lwcGVkLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBwYXlsb2FkID0gcmVzdWx0IGFzIERpc2N1c3Npb247XHJcbiAgcmV0dXJuIG5vcm1hbGl6ZURpc2N1c3Npb24ocGF5bG9hZCk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWplY3REaXNjdXNzaW9uKGRpc2N1c3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTxEaXNjdXNzaW9uPiB7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdDxEaXNjdXNzaW9uPihgL2Rpc2N1c3Npb25zLyR7ZGlzY3Vzc2lvbklkfS9yZWplY3RgLCB7XHJcbiAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgIGhlYWRlcnM6IHtcclxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgIH0sXHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gSGFuZGxlIHJhdGUgbGltaXRpbmcgLSB0aHJvdyBnZW5lcmljIGVycm9yIGZvciBtdXRhdGlvbnNcclxuICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmICdza2lwcGVkJyBpbiByZXN1bHQgJiYgKHJlc3VsdCBhcyBhbnkpLnNraXBwZWQgPT09IHRydWUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdCB3YXMgc2tpcHBlZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcclxuICB9XHJcbiAgXHJcbiAgY29uc3QgcGF5bG9hZCA9IHJlc3VsdCBhcyBEaXNjdXNzaW9uO1xyXG4gIHJldHVybiBub3JtYWxpemVEaXNjdXNzaW9uKHBheWxvYWQpO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlU2VjdG9yKHNlY3Rvck5hbWU6IHN0cmluZywgc2VjdG9yU3ltYm9sOiBzdHJpbmcpOiBQcm9taXNlPFNlY3Rvcj4ge1xyXG4gIC8vIEJ5cGFzcyByYXRlIGxpbWl0aW5nIGZvciB1c2VyLXRyaWdnZXJlZCBhY3Rpb25zIC0gYWx3YXlzIGV4ZWN1dGUgaW1tZWRpYXRlbHlcclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0PFNlY3Rvcj4oJy9zZWN0b3JzJywge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICBoZWFkZXJzOiB7XHJcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICB9LFxyXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICBzZWN0b3JOYW1lLFxyXG4gICAgICBzZWN0b3JTeW1ib2wsXHJcbiAgICB9KSxcclxuICB9LCB0cnVlKTsgLy8gYnlwYXNzUmF0ZUxpbWl0ID0gdHJ1ZVxyXG4gIFxyXG4gIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nIC0gdGhyb3cgZ2VuZXJpYyBlcnJvciBmb3IgbXV0YXRpb25zXHJcbiAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiAnc2tpcHBlZCcgaW4gcmVzdWx0ICYmIChyZXN1bHQgYXMgYW55KS5za2lwcGVkID09PSB0cnVlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3Qgd2FzIHNraXBwZWQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IHBheWxvYWQgPSByZXN1bHQgYXMgU2VjdG9yO1xyXG4gIHJldHVybiBub3JtYWxpemVTZWN0b3IocGF5bG9hZCk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVBZ2VudChcclxuICBwcm9tcHQ6IHN0cmluZyxcclxuICBzZWN0b3JJZDogc3RyaW5nIHwgbnVsbCxcclxuICByb2xlPzogc3RyaW5nIHwgbnVsbFxyXG4pOiBQcm9taXNlPEFnZW50PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Q8dW5rbm93bj4oJy9hZ2VudHMnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgIHByb21wdCxcclxuICAgICAgICBzZWN0b3JJZCxcclxuICAgICAgICByb2xlOiByb2xlIHx8IG51bGwsXHJcbiAgICAgIH0pLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSGFuZGxlIHJhdGUgbGltaXRpbmcgLSB0aHJvdyBnZW5lcmljIGVycm9yIGZvciBtdXRhdGlvbnNcclxuICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3NraXBwZWQnIGluIHJlc3VsdCAmJiAocmVzdWx0IGFzIGFueSkuc2tpcHBlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3Qgd2FzIHNraXBwZWQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcGF5bG9hZCA9IHJlc3VsdCBhcyB1bmtub3duO1xyXG5cclxuICAgIC8vIEhhbmRsZSBib3RoIGB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IEFnZW50IH1gIGFuZCBkaXJlY3QgYEFnZW50YFxyXG4gICAgbGV0IHJhd0FnZW50OiB1bmtub3duO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgcGF5bG9hZCAmJlxyXG4gICAgICB0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgJ3N1Y2Nlc3MnIGluIHBheWxvYWQgJiZcclxuICAgICAgKHBheWxvYWQgYXMgYW55KS5zdWNjZXNzID09PSB0cnVlICYmXHJcbiAgICAgICdkYXRhJyBpbiBwYXlsb2FkXHJcbiAgICApIHtcclxuICAgICAgcmF3QWdlbnQgPSAocGF5bG9hZCBhcyBhbnkpLmRhdGE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByYXdBZ2VudCA9IHBheWxvYWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBleHBlY3QgYHJhd0FnZW50YCB0byBiZSBhbiBBZ2VudC1saWtlIG9iamVjdFxyXG4gICAgY29uc3QgYWdlbnQgPSBub3JtYWxpemVBZ2VudChyYXdBZ2VudCBhcyBBZ2VudCk7XHJcbiAgICByZXR1cm4gYWdlbnQ7XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgLy8gUHJlc2VydmUgZXJyb3Igc3RydWN0dXJlIChpbmNsdWRpbmcgZXJyb3IucmVzcG9uc2UpIGZvciBwcm9wZXIgZXJyb3IgaGFuZGxpbmcgaW4gbW9kYWxzXHJcbiAgICAvLyBFeHRyYWN0IGVycm9yIG1lc3NhZ2UgZnJvbSB2YXJpb3VzIHBvc3NpYmxlIGZvcm1hdHNcclxuICAgIGNvbnN0IG1lc3NhZ2UgPVxyXG4gICAgICAoZXJyb3IgJiYgZXJyb3IubWVzc2FnZSkgfHxcclxuICAgICAgJ0ZhaWxlZCB0byBjcmVhdGUgYWdlbnQuIFBsZWFzZSB0cnkgYWdhaW4uJztcclxuXHJcbiAgICAvLyBSZS10aHJvdyB3aXRoIHByZXNlcnZlZCBzdHJ1Y3R1cmVcclxuICAgIGNvbnN0IG5ld0Vycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpIGFzIGFueTtcclxuICAgIGlmIChlcnJvcj8ucmVzcG9uc2UpIHtcclxuICAgICAgbmV3RXJyb3IucmVzcG9uc2UgPSBlcnJvci5yZXNwb25zZTtcclxuICAgIH1cclxuICAgIHRocm93IG5ld0Vycm9yO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlcG9zaXRTZWN0b3Ioc2VjdG9ySWQ6IHN0cmluZywgYW1vdW50OiBudW1iZXIpOiBQcm9taXNlPFNlY3Rvcj4ge1xyXG4gIGNvbnN0IHBheWxvYWQgPSBhd2FpdCByZXF1ZXN0PHsgc3VjY2VzczogYm9vbGVhbjsgZGF0YTogU2VjdG9yIH0gfCBTZWN0b3I+KGAvc2VjdG9ycy8ke3NlY3RvcklkfS9kZXBvc2l0YCwge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICBoZWFkZXJzOiB7XHJcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICB9LFxyXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBhbW91bnQgfSksXHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gSGFuZGxlIGJvdGggd3JhcHBlZCBhbmQgdW53cmFwcGVkIHJlc3BvbnNlc1xyXG4gIGxldCBzZWN0b3JEYXRhOiBhbnkgPSBwYXlsb2FkO1xyXG4gIGlmIChwYXlsb2FkICYmIHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JyAmJiAnc3VjY2VzcycgaW4gcGF5bG9hZCAmJiAnZGF0YScgaW4gcGF5bG9hZCkge1xyXG4gICAgc2VjdG9yRGF0YSA9IChwYXlsb2FkIGFzIHsgc3VjY2VzczogYm9vbGVhbjsgZGF0YTogU2VjdG9yIH0pLmRhdGE7XHJcbiAgfVxyXG4gIHJldHVybiBub3JtYWxpemVTZWN0b3Ioc2VjdG9yRGF0YSk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3aXRoZHJhd1NlY3RvcihzZWN0b3JJZDogc3RyaW5nLCBhbW91bnQ/OiBudW1iZXIgfCAnYWxsJyk6IFByb21pc2U8eyBzZWN0b3I6IFNlY3Rvcjsgd2l0aGRyYXduQW1vdW50OiBudW1iZXIgfT4ge1xyXG4gIGNvbnN0IHBheWxvYWQgPSBhd2FpdCByZXF1ZXN0PHsgc3VjY2VzczogYm9vbGVhbjsgc2VjdG9yOiBTZWN0b3I7IHdpdGhkcmF3bkFtb3VudDogbnVtYmVyIH0+KGAvc2VjdG9ycy8ke3NlY3RvcklkfS93aXRoZHJhd2AsIHtcclxuICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgaGVhZGVyczoge1xyXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgfSxcclxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgYW1vdW50OiBhbW91bnQgPz8gJ2FsbCcgfSksXHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gSGFuZGxlIHJhdGUgbGltaXRpbmcgLSB0aHJvdyBnZW5lcmljIGVycm9yIGZvciBtdXRhdGlvbnNcclxuICBpZiAocGF5bG9hZCAmJiB0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcgJiYgJ3NraXBwZWQnIGluIHBheWxvYWQgJiYgKHBheWxvYWQgYXMgYW55KS5za2lwcGVkID09PSB0cnVlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3Qgd2FzIHNraXBwZWQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IHJlc3VsdCA9IHBheWxvYWQgYXMgeyBzdWNjZXNzOiBib29sZWFuOyBzZWN0b3I6IFNlY3Rvcjsgd2l0aGRyYXduQW1vdW50OiBudW1iZXIgfTtcclxuICByZXR1cm4ge1xyXG4gICAgc2VjdG9yOiBub3JtYWxpemVTZWN0b3IocmVzdWx0LnNlY3RvciksXHJcbiAgICB3aXRoZHJhd25BbW91bnQ6IHJlc3VsdC53aXRoZHJhd25BbW91bnRcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlQWdlbnQoYWdlbnRJZDogc3RyaW5nLCB1cGRhdGVzOiB7XHJcbiAgbmFtZT86IHN0cmluZztcclxuICByb2xlPzogc3RyaW5nO1xyXG4gIHByb21wdD86IHN0cmluZztcclxuICBzZWN0b3JJZD86IHN0cmluZyB8IG51bGw7XHJcbiAgcGVyc29uYWxpdHk/OiB7XHJcbiAgICByaXNrVG9sZXJhbmNlPzogc3RyaW5nO1xyXG4gICAgZGVjaXNpb25TdHlsZT86IHN0cmluZztcclxuICB9O1xyXG4gIHByZWZlcmVuY2VzPzoge1xyXG4gICAgcmlza1dlaWdodD86IG51bWJlcjtcclxuICAgIHByb2ZpdFdlaWdodD86IG51bWJlcjtcclxuICAgIHNwZWVkV2VpZ2h0PzogbnVtYmVyO1xyXG4gICAgYWNjdXJhY3lXZWlnaHQ/OiBudW1iZXI7XHJcbiAgfTtcclxufSk6IFByb21pc2U8QWdlbnQ+IHtcclxuICAvLyBOb3JtYWxpemUgYW5kIHZhbGlkYXRlIElEIGJlZm9yZSBtYWtpbmcgcmVxdWVzdFxyXG4gIGNvbnN0IG5vcm1hbGl6ZWRJZCA9IG5vcm1hbGl6ZUFnZW50SWQoYWdlbnRJZCk7XHJcbiAgaWYgKCFub3JtYWxpemVkSWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZ2VudCBJRCBwcm92aWRlZCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gQnlwYXNzIHJhdGUgbGltaXRpbmcgZm9yIHVzZXItdHJpZ2dlcmVkIGFjdGlvbnMgLSBhbHdheXMgZXhlY3V0ZSBpbW1lZGlhdGVseVxyXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Q8QWdlbnQ+KGAvYWdlbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KG5vcm1hbGl6ZWRJZCl9YCwge1xyXG4gICAgbWV0aG9kOiAnUFVUJyxcclxuICAgIGhlYWRlcnM6IHtcclxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgIH0sXHJcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVzKSxcclxuICB9LCB0cnVlKTsgLy8gYnlwYXNzUmF0ZUxpbWl0ID0gdHJ1ZVxyXG4gIFxyXG4gIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nIC0gdGhyb3cgZ2VuZXJpYyBlcnJvciBmb3IgbXV0YXRpb25zXHJcbiAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiAnc2tpcHBlZCcgaW4gcmVzdWx0ICYmIChyZXN1bHQgYXMgYW55KS5za2lwcGVkID09PSB0cnVlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3Qgd2FzIHNraXBwZWQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IHBheWxvYWQgPSByZXN1bHQgYXMgQWdlbnQ7XHJcbiAgcmV0dXJuIG5vcm1hbGl6ZUFnZW50KHBheWxvYWQpO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQWdlbnQoYWdlbnRJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgLy8gTm9ybWFsaXplIGFuZCB2YWxpZGF0ZSBJRCBiZWZvcmUgbWFraW5nIHJlcXVlc3RcclxuICBjb25zdCBub3JtYWxpemVkSWQgPSBub3JtYWxpemVBZ2VudElkKGFnZW50SWQpO1xyXG4gIGlmICghbm9ybWFsaXplZElkKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWdlbnQgSUQgcHJvdmlkZWQnKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Q8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlPzogc3RyaW5nIH0+KGAvYWdlbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KG5vcm1hbGl6ZWRJZCl9YCwge1xyXG4gICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICB9KTtcclxuICBcclxuICAvLyBIYW5kbGUgcmF0ZSBsaW1pdGluZyAtIHRocm93IGdlbmVyaWMgZXJyb3IgZm9yIG11dGF0aW9uc1xyXG4gIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3NraXBwZWQnIGluIHJlc3VsdCAmJiAocmVzdWx0IGFzIGFueSkuc2tpcHBlZCA9PT0gdHJ1ZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IHdhcyBza2lwcGVkLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVNlY3RvcihzZWN0b3JJZDogc3RyaW5nLCBjb25maXJtYXRpb25Db2RlOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgbWVzc2FnZT86IHN0cmluZzsgd2l0aGRyYXduQmFsYW5jZT86IG51bWJlciB9PiB7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdDx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U/OiBzdHJpbmc7IHdpdGhkcmF3bkJhbGFuY2U/OiBudW1iZXIgfT4oYC9zZWN0b3JzLyR7c2VjdG9ySWR9YCwge1xyXG4gICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgIGhlYWRlcnM6IHtcclxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgIH0sXHJcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGNvbmZpcm1hdGlvbkNvZGUgfSksXHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gSGFuZGxlIHJhdGUgbGltaXRpbmcgLSB0aHJvdyBnZW5lcmljIGVycm9yIGZvciBtdXRhdGlvbnNcclxuICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmICdza2lwcGVkJyBpbiByZXN1bHQgJiYgKHJlc3VsdCBhcyBhbnkpLnNraXBwZWQgPT09IHRydWUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdCB3YXMgc2tpcHBlZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcclxuICB9XHJcbiAgXHJcbiAgY29uc3QgcGF5bG9hZCA9IHJlc3VsdCBhcyB7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U/OiBzdHJpbmc7IHdpdGhkcmF3bkJhbGFuY2U/OiBudW1iZXIgfTtcclxuICByZXR1cm4gcGF5bG9hZDtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJCYWxhbmNlKCk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Q8eyBiYWxhbmNlOiBudW1iZXIgfT4oJy91c2VyL2JhbGFuY2UnKTtcclxuICAgIFxyXG4gICAgLy8gSGFuZGxlIHJhdGUgbGltaXRpbmcgLSByZXR1cm4gMCB3aGVuIHNraXBwZWRcclxuICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3NraXBwZWQnIGluIHJlc3VsdCAmJiAocmVzdWx0IGFzIGFueSkuc2tpcHBlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgZGF0YSA9IHJlc3VsdCBhcyB7IGJhbGFuY2U6IG51bWJlciB9O1xyXG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhLmJhbGFuY2UgPT09ICdudW1iZXInID8gZGF0YS5iYWxhbmNlIDogMDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIHVzZXIgYmFsYW5jZTonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29uZmlkZW5jZVRpY2tSZXN1bHQge1xyXG4gIGFnZW50czogQXJyYXk8e1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIGNvbmZpZGVuY2U6IG51bWJlcjtcclxuICB9PjtcclxuICBkaXNjdXNzaW9uUmVhZHk6IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBydW5Db25maWRlbmNlVGljayhzZWN0b3JJZDogc3RyaW5nKTogUHJvbWlzZTxDb25maWRlbmNlVGlja1Jlc3VsdCB8IG51bGw+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdDxDb25maWRlbmNlVGlja1Jlc3VsdD4oYC9zZWN0b3JzLyR7c2VjdG9ySWR9L2NvbmZpZGVuY2UtdGlja2AsIHtcclxuICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe30pLFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nIC0gcmV0dXJuIG51bGwgd2hlbiBza2lwcGVkIHNvIHBvbGxpbmcgY2FuIGNvbnRpbnVlIHNpbGVudGx5XHJcbiAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmICdza2lwcGVkJyBpbiByZXN1bHQgJiYgKHJlc3VsdCBhcyBhbnkpLnNraXBwZWQgPT09IHRydWUpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiByZXN1bHQgYXMgQ29uZmlkZW5jZVRpY2tSZXN1bHQ7XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgLy8gUmUtdGhyb3cgZXJyb3JzIChvbmx5IHJlYWwgSFRUUCBlcnJvcnMgc2hvdWxkIHJlYWNoIGhlcmUpXHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kTWVzc2FnZVRvTWFuYWdlcihzZWN0b3JJZDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgbWVzc2FnZT86IHN0cmluZyB9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Q8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlPzogc3RyaW5nIH0+KGAvc2VjdG9ycy8ke3NlY3RvcklkfS9tZXNzYWdlLW1hbmFnZXJgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBtZXNzYWdlIH0pLFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nXHJcbiAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmICdza2lwcGVkJyBpbiByZXN1bHQgJiYgKHJlc3VsdCBhcyBhbnkpLnNraXBwZWQgPT09IHRydWUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IHdhcyByYXRlLWxpbWl0ZWQuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiByZXN1bHQgYXMgeyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlPzogc3RyaW5nIH07XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRXhlY3V0aW9uIGxvZyBlbnRyeVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBFeGVjdXRpb25Mb2cge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgc2VjdG9ySWQ6IHN0cmluZztcclxuICBjaGVja2xpc3RJZD86IHN0cmluZztcclxuICBtYW5hZ2VySWQ/OiBzdHJpbmc7XHJcbiAgdGltZXN0YW1wOiBudW1iZXI7XHJcbiAgZXhlY3V0aW9uVHlwZT86IHN0cmluZztcclxuICByZXN1bHRzPzogQXJyYXk8e1xyXG4gICAgaXRlbUlkOiBzdHJpbmc7XHJcbiAgICBhY3Rpb246IHN0cmluZztcclxuICAgIGFjdGlvblR5cGU/OiBzdHJpbmc7XHJcbiAgICBhbW91bnQ6IG51bWJlcjtcclxuICAgIGFsbG9jYXRpb24/OiBudW1iZXI7XHJcbiAgICBzeW1ib2w/OiBzdHJpbmc7XHJcbiAgICBzdWNjZXNzOiBib29sZWFuO1xyXG4gICAgcmVhc29uPzogc3RyaW5nO1xyXG4gICAgaW1wYWN0PzogbnVtYmVyO1xyXG4gICAgbWFuYWdlckltcGFjdD86IG51bWJlcjtcclxuICB9PjtcclxuICBpbXBhY3Q/OiBudW1iZXI7XHJcbiAgYWN0aW9uPzogc3RyaW5nO1xyXG4gIHN0YXR1cz86IHN0cmluZzsgLy8gRm9yIGFwcHJvdmVkIGl0ZW1zOiAnQVBQUk9WRUQnXHJcbiAgc2NvcmU/OiBudW1iZXI7IC8vIE1hbmFnZXIgZGVjaXNpb24gc2NvcmVcclxuICBtYW5hZ2VyUmVhc29uPzogc3RyaW5nOyAvLyBNYW5hZ2VyJ3MgcmVhc29uIGZvciBhcHByb3ZhbC9yZWplY3Rpb25cclxufVxyXG5cclxuLyoqXHJcbiAqIEV4ZWN1dGlvbiBsaXN0IGl0ZW1cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgRXhlY3V0aW9uTGlzdEl0ZW0ge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgYWN0aW9uVHlwZTogJ0JVWScgfCAnU0VMTCcgfCAnSE9MRCcgfCAnUkVCQUxBTkNFJztcclxuICBzeW1ib2w6IHN0cmluZztcclxuICBhbGxvY2F0aW9uOiBudW1iZXI7XHJcbiAgZ2VuZXJhdGVkRnJvbURpc2N1c3Npb24/OiBzdHJpbmc7XHJcbiAgY3JlYXRlZEF0OiBudW1iZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeGVjdXRpb24gcmVzdWx0XHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEV4ZWN1dGlvblJlc3VsdCB7XHJcbiAgaXRlbUlkOiBzdHJpbmc7XHJcbiAgYWN0aW9uVHlwZTogc3RyaW5nO1xyXG4gIHN5bWJvbDogc3RyaW5nO1xyXG4gIGFsbG9jYXRpb246IG51bWJlcjtcclxuICBzdWNjZXNzOiBib29sZWFuO1xyXG4gIHJlYXNvbjogc3RyaW5nO1xyXG4gIG1hbmFnZXJJbXBhY3Q/OiBudW1iZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGZXRjaCBleGVjdXRpb24gbG9ncyBmb3IgYSBzZWN0b3JcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEV4ZWN1dGlvbkxvZ3Moc2VjdG9ySWQ6IHN0cmluZyk6IFByb21pc2U8RXhlY3V0aW9uTG9nW10+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdDx7IHN1Y2Nlc3M6IGJvb2xlYW47IGxvZ3M6IEV4ZWN1dGlvbkxvZ1tdIH0+KGAvZXhlY3V0aW9uL2xvZ3MvJHtzZWN0b3JJZH1gKTtcclxuICAgIFxyXG4gICAgLy8gSGFuZGxlIHJhdGUgbGltaXRpbmcgLSByZXR1cm4gZW1wdHkgYXJyYXkgd2hlbiBza2lwcGVkXHJcbiAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmICdza2lwcGVkJyBpbiByZXN1bHQgJiYgKHJlc3VsdCBhcyBhbnkpLnNraXBwZWQgPT09IHRydWUpIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBwYXlsb2FkID0gcmVzdWx0IGFzIHsgc3VjY2VzczogYm9vbGVhbjsgbG9nczogRXhlY3V0aW9uTG9nW10gfTtcclxuICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQuc3VjY2VzcyAmJiBBcnJheS5pc0FycmF5KHBheWxvYWQubG9ncykpIHtcclxuICAgICAgcmV0dXJuIHBheWxvYWQubG9ncztcclxuICAgIH1cclxuICAgIHJldHVybiBbXTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZXhlY3V0aW9uIGxvZ3M6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBleGVjdXRpb24gbGlzdCBmb3IgYSBtYW5hZ2VyXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TWFuYWdlckV4ZWN1dGlvbkxpc3QobWFuYWdlcklkOiBzdHJpbmcpOiBQcm9taXNlPEV4ZWN1dGlvbkxpc3RJdGVtW10+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdDx7IHN1Y2Nlc3M6IGJvb2xlYW47IGV4ZWN1dGlvbkxpc3Q6IEV4ZWN1dGlvbkxpc3RJdGVtW10gfT4oYC9tYW5hZ2VyLyR7bWFuYWdlcklkfS9leGVjdXRpb24tbGlzdGApO1xyXG4gICAgXHJcbiAgICAvLyBIYW5kbGUgcmF0ZSBsaW1pdGluZyAtIHJldHVybiBlbXB0eSBhcnJheSB3aGVuIHNraXBwZWRcclxuICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3NraXBwZWQnIGluIHJlc3VsdCAmJiAocmVzdWx0IGFzIGFueSkuc2tpcHBlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHBheWxvYWQgPSByZXN1bHQgYXMgeyBzdWNjZXNzOiBib29sZWFuOyBleGVjdXRpb25MaXN0OiBFeGVjdXRpb25MaXN0SXRlbVtdIH07XHJcbiAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLnN1Y2Nlc3MgJiYgQXJyYXkuaXNBcnJheShwYXlsb2FkLmV4ZWN1dGlvbkxpc3QpKSB7XHJcbiAgICAgIHJldHVybiBwYXlsb2FkLmV4ZWN1dGlvbkxpc3Q7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW107XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG1hbmFnZXIgZXhlY3V0aW9uIGxpc3Q6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEV4ZWN1dGUgYWxsIGl0ZW1zIGluIG1hbmFnZXIncyBleGVjdXRpb24gbGlzdFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVNYW5hZ2VyRXhlY3V0aW9uTGlzdChtYW5hZ2VySWQ6IHN0cmluZyk6IFByb21pc2U8e1xyXG4gIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgZXhlY3V0ZWQ6IG51bWJlcjtcclxuICB0b3RhbDogbnVtYmVyO1xyXG4gIHJlc3VsdHM6IEV4ZWN1dGlvblJlc3VsdFtdO1xyXG4gIHVwZGF0ZWRTZWN0b3JTdGF0ZT86IHtcclxuICAgIGlkOiBzdHJpbmc7XHJcbiAgICBjYXBpdGFsOiBudW1iZXI7XHJcbiAgICBwb3NpdGlvbjogbnVtYmVyO1xyXG4gICAgcGVyZm9ybWFuY2U6IGFueTtcclxuICAgIHV0aWxpemF0aW9uOiBudW1iZXI7XHJcbiAgICBjdXJyZW50UHJpY2U6IG51bWJlcjtcclxuICB9O1xyXG59PiB7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdDx7XHJcbiAgICBzdWNjZXNzOiBib29sZWFuO1xyXG4gICAgZXhlY3V0ZWQ6IG51bWJlcjtcclxuICAgIHRvdGFsOiBudW1iZXI7XHJcbiAgICByZXN1bHRzOiBFeGVjdXRpb25SZXN1bHRbXTtcclxuICAgIHVwZGF0ZWRTZWN0b3JTdGF0ZT86IGFueTtcclxuICB9PihgL21hbmFnZXIvJHttYW5hZ2VySWR9L2V4ZWN1dGUtYWxsYCwge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICBoZWFkZXJzOiB7XHJcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICB9LFxyXG4gIH0pO1xyXG4gIFxyXG4gIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nIC0gdGhyb3cgZ2VuZXJpYyBlcnJvciBmb3IgbXV0YXRpb25zXHJcbiAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiAnc2tpcHBlZCcgaW4gcmVzdWx0ICYmIChyZXN1bHQgYXMgYW55KS5za2lwcGVkID09PSB0cnVlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3Qgd2FzIHNraXBwZWQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiByZXN1bHQgYXMge1xyXG4gICAgc3VjY2VzczogYm9vbGVhbjtcclxuICAgIGV4ZWN1dGVkOiBudW1iZXI7XHJcbiAgICB0b3RhbDogbnVtYmVyO1xyXG4gICAgcmVzdWx0czogRXhlY3V0aW9uUmVzdWx0W107XHJcbiAgICB1cGRhdGVkU2VjdG9yU3RhdGU/OiBhbnk7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFyIGFsbCBkaXNjdXNzaW9ucyAoZGV2ZWxvcG1lbnQgb25seSlcclxuICogTm90ZTogVXNlcyBiYWNrZW5kIGJhc2UgVVJMIGRpcmVjdGx5IHNpbmNlIGRlYnVnIHJvdXRlcyBhcmUgYXQgL2RlYnVnIChub3QgL2FwaS9kZWJ1ZylcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGVhckFsbERpc2N1c3Npb25zKCk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBkZWxldGVkQ291bnQ6IG51bWJlciB9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIFVzZSBiYWNrZW5kIGJhc2UgVVJMIGRpcmVjdGx5IHNpbmNlIGRlYnVnIHJvdXRlcyBhcmUgbm90IHVuZGVyIC9hcGlcclxuICAgIGNvbnN0IGJhY2tlbmRCYXNlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBnZXRCYWNrZW5kQmFzZVVybCgpIDogQkFDS0VORDtcclxuICAgIGNvbnN0IGZ1bGxVcmwgPSBgJHtiYWNrZW5kQmFzZX0vZGVidWcvZGlzY3Vzc2lvbnMvY2xlYXJgO1xyXG4gICAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJhdGVMaW1pdGVkRmV0Y2goXHJcbiAgICAgIGZ1bGxVcmwsXHJcbiAgICAgIDUwMCxcclxuICAgICAge1xyXG4gICAgICAgIG1ldGhvZDogJ0RFTEVURScsXHJcbiAgICAgICAgY2FjaGU6ICduby1zdG9yZScsXHJcbiAgICAgICAgY3JlZGVudGlhbHM6ICdvbWl0JyxcclxuICAgICAgfSxcclxuICAgICAgeyBieXBhc3M6IHRydWUgfSAvLyBCeXBhc3MgcmF0ZSBsaW1pdGluZyBmb3IgdXNlci10cmlnZ2VyZWQgYWN0aW9uc1xyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgUmVxdWVzdCBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWA7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIGlmIChlcnJvckRhdGEuZXJyb3IpIHtcclxuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yRGF0YS5lcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgaWYgKHRleHQpIHtcclxuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICByZXR1cm4gcGF5bG9hZCBhcyB7IHN1Y2Nlc3M6IGJvb2xlYW47IGRlbGV0ZWRDb3VudDogbnVtYmVyIH07XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRGVjaXNpb24gTG9ncyBBUElcclxuICovXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEV4ZWN1dGlvbkxvZ3NGaWx0ZXJzIHtcclxuICBwYWdlPzogbnVtYmVyO1xyXG4gIHBhZ2VTaXplPzogbnVtYmVyO1xyXG4gIHNlY3RvcklkPzogc3RyaW5nO1xyXG4gIG1hbmFnZXJJZD86IHN0cmluZztcclxuICBkaXNjdXNzaW9uSWQ/OiBzdHJpbmc7XHJcbiAgc3RhcnRUaW1lPzogbnVtYmVyO1xyXG4gIGVuZFRpbWU/OiBudW1iZXI7XHJcbiAgYWN0aW9uVHlwZT86IHN0cmluZztcclxufVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRmluYWxpemVkUmVqZWN0aW9uc0ZpbHRlcnMge1xyXG4gIHBhZ2U/OiBudW1iZXI7XHJcbiAgcGFnZVNpemU/OiBudW1iZXI7XHJcbiAgc2VjdG9ySWQ/OiBzdHJpbmc7XHJcbiAgbWFuYWdlcklkPzogc3RyaW5nO1xyXG4gIGRpc2N1c3Npb25JZD86IHN0cmluZztcclxuICBzdGFydFRpbWU/OiBudW1iZXI7XHJcbiAgZW5kVGltZT86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGaW5hbGl6ZWRSZWplY3Rpb24ge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgdGltZXN0YW1wOiBudW1iZXI7XHJcbiAgc2VjdG9yU3ltYm9sOiBzdHJpbmc7XHJcbiAgZGlzY3Vzc2lvbklkOiBzdHJpbmc7XHJcbiAgZGlzY3Vzc2lvblRpdGxlOiBzdHJpbmc7XHJcbiAgbWFuYWdlcklkPzogc3RyaW5nIHwgbnVsbDtcclxuICBhY3Rpb24/OiBzdHJpbmc7XHJcbiAgYW1vdW50PzogbnVtYmVyIHwgbnVsbDtcclxuICBjb25maWRlbmNlPzogbnVtYmVyIHwgbnVsbDtcclxuICBtYW5hZ2VyUmVhc29uPzogc3RyaW5nIHwgbnVsbDtcclxuICB0ZXh0Pzogc3RyaW5nO1xyXG4gIHN0YXR1cz86IHN0cmluZztcclxuICBpc0ZpbmFsaXplZD86IGJvb2xlYW47XHJcbiAgcmV2aXNpb25Db3VudD86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQWxsRXhlY3V0aW9uTG9ncyhmaWx0ZXJzOiBFeGVjdXRpb25Mb2dzRmlsdGVycyA9IHt9KTogUHJvbWlzZTx7IGxvZ3M6IEV4ZWN1dGlvbkxvZ1tdOyBwYWdpbmF0aW9uPzogYW55IH0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xyXG4gICAgLy8gQmFja2VuZCB1c2VzICdzZWN0b3InIG5vdCAnc2VjdG9ySWQnXHJcbiAgICBpZiAoZmlsdGVycy5zZWN0b3JJZCkgcGFyYW1zLmFwcGVuZCgnc2VjdG9yJywgZmlsdGVycy5zZWN0b3JJZCk7XHJcbiAgICBpZiAoZmlsdGVycy5tYW5hZ2VySWQpIHBhcmFtcy5hcHBlbmQoJ21hbmFnZXJJZCcsIGZpbHRlcnMubWFuYWdlcklkKTtcclxuICAgIGlmIChmaWx0ZXJzLmRpc2N1c3Npb25JZCkgcGFyYW1zLmFwcGVuZCgnZGlzY3Vzc2lvbklkJywgZmlsdGVycy5kaXNjdXNzaW9uSWQpO1xyXG4gICAgaWYgKGZpbHRlcnMuYWN0aW9uVHlwZSkgcGFyYW1zLmFwcGVuZCgnYWN0aW9uVHlwZScsIGZpbHRlcnMuYWN0aW9uVHlwZSk7XHJcbiAgICBpZiAoZmlsdGVycy5zdGFydFRpbWUgJiYgZmlsdGVycy5lbmRUaW1lKSB7XHJcbiAgICAgIC8vIEJhY2tlbmQgZXhwZWN0cyB0aW1lUmFuZ2UgaW4gZm9ybWF0IFwic3RhcnQ6ZW5kXCIgb3IgXCJsYXN0TmhvdXJzXCIgb3IgXCJsYXN0TmRheXNcIlxyXG4gICAgICBjb25zdCBob3VycyA9IE1hdGgucm91bmQoKGZpbHRlcnMuZW5kVGltZSAtIGZpbHRlcnMuc3RhcnRUaW1lKSAvICgxMDAwICogNjAgKiA2MCkpO1xyXG4gICAgICBpZiAoaG91cnMgPD0gMjQpIHtcclxuICAgICAgICBwYXJhbXMuYXBwZW5kKCd0aW1lUmFuZ2UnLCBgbGFzdCR7aG91cnN9aG91cnNgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBkYXlzID0gTWF0aC5yb3VuZChob3VycyAvIDI0KTtcclxuICAgICAgICBwYXJhbXMuYXBwZW5kKCd0aW1lUmFuZ2UnLCBgbGFzdCR7ZGF5c31kYXlzYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0PHsgc3VjY2VzczogYm9vbGVhbjsgbG9nczogRXhlY3V0aW9uTG9nW10gfT4oYC9kZWNpc2lvbi1sb2dzL2V4ZWN1dGVkPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCk7XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nXHJcbiAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmICdza2lwcGVkJyBpbiByZXN1bHQgJiYgKHJlc3VsdCBhcyBhbnkpLnNraXBwZWQgPT09IHRydWUpIHtcclxuICAgICAgcmV0dXJuIHsgbG9nczogW10gfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgcGF5bG9hZCA9IHJlc3VsdCBhcyB7IHN1Y2Nlc3M6IGJvb2xlYW47IGxvZ3M6IEV4ZWN1dGlvbkxvZ1tdIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsb2dzOiBwYXlsb2FkICYmIHBheWxvYWQuc3VjY2VzcyAmJiBBcnJheS5pc0FycmF5KHBheWxvYWQubG9ncykgPyBwYXlsb2FkLmxvZ3MgOiBbXSxcclxuICAgICAgcGFnaW5hdGlvbjogeyBwYWdlOiBmaWx0ZXJzLnBhZ2UgfHwgMSwgcGFnZVNpemU6IGZpbHRlcnMucGFnZVNpemUgfHwgMjAsIHRvdGFsOiAwLCB0b3RhbFBhZ2VzOiAwIH1cclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGV4ZWN1dGlvbiBsb2dzOicsIGVycm9yKTtcclxuICAgIHJldHVybiB7IGxvZ3M6IFtdIH07XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hGaW5hbGl6ZWRSZWplY3Rpb25zKGZpbHRlcnM6IEZpbmFsaXplZFJlamVjdGlvbnNGaWx0ZXJzID0ge30pOiBQcm9taXNlPHsgcmVqZWN0aW9uczogRmluYWxpemVkUmVqZWN0aW9uW107IHBhZ2luYXRpb24/OiBhbnkgfT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XHJcbiAgICAvLyBCYWNrZW5kIHVzZXMgJ3NlY3Rvcicgbm90ICdzZWN0b3JJZCdcclxuICAgIGlmIChmaWx0ZXJzLnNlY3RvcklkKSBwYXJhbXMuYXBwZW5kKCdzZWN0b3InLCBmaWx0ZXJzLnNlY3RvcklkKTtcclxuICAgIGlmIChmaWx0ZXJzLm1hbmFnZXJJZCkgcGFyYW1zLmFwcGVuZCgnbWFuYWdlcklkJywgZmlsdGVycy5tYW5hZ2VySWQpO1xyXG4gICAgaWYgKGZpbHRlcnMuZGlzY3Vzc2lvbklkKSBwYXJhbXMuYXBwZW5kKCdkaXNjdXNzaW9uSWQnLCBmaWx0ZXJzLmRpc2N1c3Npb25JZCk7XHJcbiAgICBpZiAoZmlsdGVycy5zdGFydFRpbWUgJiYgZmlsdGVycy5lbmRUaW1lKSB7XHJcbiAgICAgIC8vIEJhY2tlbmQgZXhwZWN0cyB0aW1lUmFuZ2UgaW4gZm9ybWF0IFwic3RhcnQ6ZW5kXCIgb3IgXCJsYXN0TmhvdXJzXCIgb3IgXCJsYXN0TmRheXNcIlxyXG4gICAgICBjb25zdCBob3VycyA9IE1hdGgucm91bmQoKGZpbHRlcnMuZW5kVGltZSAtIGZpbHRlcnMuc3RhcnRUaW1lKSAvICgxMDAwICogNjAgKiA2MCkpO1xyXG4gICAgICBpZiAoaG91cnMgPD0gMjQpIHtcclxuICAgICAgICBwYXJhbXMuYXBwZW5kKCd0aW1lUmFuZ2UnLCBgbGFzdCR7aG91cnN9aG91cnNgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBkYXlzID0gTWF0aC5yb3VuZChob3VycyAvIDI0KTtcclxuICAgICAgICBwYXJhbXMuYXBwZW5kKCd0aW1lUmFuZ2UnLCBgbGFzdCR7ZGF5c31kYXlzYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0PHsgc3VjY2VzczogYm9vbGVhbjsgZmluYWxpemVkUmVqZWN0aW9uczogRmluYWxpemVkUmVqZWN0aW9uW10gfT4oYC9kZWNpc2lvbi1sb2dzL2ZpbmFsaXplZC1yZWplY3Rpb25zPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCk7XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nXHJcbiAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmICdza2lwcGVkJyBpbiByZXN1bHQgJiYgKHJlc3VsdCBhcyBhbnkpLnNraXBwZWQgPT09IHRydWUpIHtcclxuICAgICAgcmV0dXJuIHsgcmVqZWN0aW9uczogW10gfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgcGF5bG9hZCA9IHJlc3VsdCBhcyB7IHN1Y2Nlc3M6IGJvb2xlYW47IGZpbmFsaXplZFJlamVjdGlvbnM6IEZpbmFsaXplZFJlamVjdGlvbltdIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZWplY3Rpb25zOiBwYXlsb2FkICYmIHBheWxvYWQuc3VjY2VzcyAmJiBBcnJheS5pc0FycmF5KHBheWxvYWQuZmluYWxpemVkUmVqZWN0aW9ucykgPyBwYXlsb2FkLmZpbmFsaXplZFJlamVjdGlvbnMgOiBbXSxcclxuICAgICAgcGFnaW5hdGlvbjogeyBwYWdlOiBmaWx0ZXJzLnBhZ2UgfHwgMSwgcGFnZVNpemU6IGZpbHRlcnMucGFnZVNpemUgfHwgMjAsIHRvdGFsOiAwLCB0b3RhbFBhZ2VzOiAwIH1cclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGZpbmFsaXplZCByZWplY3Rpb25zOicsIGVycm9yKTtcclxuICAgIHJldHVybiB7IHJlamVjdGlvbnM6IFtdIH07XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2xlYXIgYWxsIGRlY2lzaW9uIGxvZ3MgKGRldmVsb3BtZW50L3Rlc3Rpbmcgb25seSlcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGVhckRlY2lzaW9uTG9ncygpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Q8eyBzdWNjZXNzOiBib29sZWFuIH0+KFxyXG4gICAgICAnL2RlY2lzaW9uLWxvZ3MvY2xlYXInLFxyXG4gICAgICB7XHJcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgICAgICBjYWNoZTogJ25vLXN0b3JlJyxcclxuICAgICAgICBjcmVkZW50aWFsczogJ29taXQnLFxyXG4gICAgICB9LFxyXG4gICAgICB0cnVlIC8vIEJ5cGFzcyByYXRlIGxpbWl0aW5nIGZvciB1c2VyLXRyaWdnZXJlZCBhY3Rpb25zXHJcbiAgICApO1xyXG5cclxuICAgIC8vIEhhbmRsZSByYXRlIGxpbWl0aW5nXHJcbiAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmICdza2lwcGVkJyBpbiByZXN1bHQgJiYgKHJlc3VsdCBhcyBhbnkpLnNraXBwZWQgPT09IHRydWUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IHdhcyByYXRlLWxpbWl0ZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwYXlsb2FkID0gcmVzdWx0IGFzIHsgc3VjY2VzczogYm9vbGVhbiB9O1xyXG4gICAgcmV0dXJuIHBheWxvYWQ7XHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG4iXSwibmFtZXMiOlsiZ2V0QXBpQmFzZVVybCIsImdldEJhY2tlbmRCYXNlVXJsIiwiaXNEZXNrdG9wQXBwIiwicmF0ZUxpbWl0ZWRGZXRjaCIsImlzUmF0ZUxpbWl0RXJyb3IiLCJlcnJvciIsInJlc3BvbnNlIiwic3RhdHVzIiwiY29kZSIsImlzU2tpcHBlZFJlc3VsdCIsInJlc3VsdCIsInNraXBwZWQiLCJnZXRBcGlCYXNlIiwiYXBpVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJyZXBsYWNlIiwiYmFja2VuZCIsIk5FWFRfUFVCTElDX01BWF9CQUNLRU5EX1VSTCIsIk5FWFRfUFVCTElDX0JBQ0tFTkRfVVJMIiwiQVBJX0JBU0UiLCJCQUNLRU5EIiwidW53cmFwUGF5bG9hZCIsInBheWxvYWQiLCJkYXRhIiwibm9ybWFsaXplQWdlbnRJZCIsImlkIiwibm9ybWFsaXplZCIsIlN0cmluZyIsInRyaW0iLCJyZXF1ZXN0IiwicGF0aCIsImluaXQiLCJieXBhc3NSYXRlTGltaXQiLCJhcGlCYXNlIiwiYmFja2VuZFVybCIsImZ1bGxVcmwiLCJjb25zb2xlIiwibG9nIiwibWV0aG9kIiwiY2FjaGUiLCJjcmVkZW50aWFscyIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwidGltZW91dCIsImJ5cGFzcyIsIm9rIiwiZXJyb3JNZXNzYWdlIiwiZXJyb3JSZXNwb25zZSIsImVycm9yRGF0YSIsImpzb24iLCJzdWNjZXNzIiwidGV4dCIsIkVycm9yIiwiaXNOZXR3b3JrRXJyb3IiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJuYW1lIiwiYXR0ZW1wdGVkVXJsIiwiZW52QXBpVXJsIiwiZW52QmFja2VuZFVybCIsImlzRGVza3RvcCIsImhlYWx0aFVybCIsImhlYWx0aENoZWNrIiwiZmV0Y2giLCJoZWFsdGhFcnJvciIsIm5vcm1hbGl6ZUNhbmRsZURhdGEiLCJlbnRyeSIsImluZGV4IiwiZmFsbGJhY2tQcmljZSIsInRpbWUiLCJ2YWx1ZSIsInZhbHVlQ2FuZGlkYXRlIiwiY2xvc2UiLCJob3VycyIsIm1pbnV0ZXMiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ0b0ZpeGVkIiwibm9ybWFsaXplQWdlbnQiLCJyYXciLCJwZXJmb3JtYW5jZVZhbHVlIiwicGVyZm9ybWFuY2UiLCJwbmwiLCJ0cmFkZXNDb3VudCIsIkFycmF5IiwiaXNBcnJheSIsInRyYWRlcyIsImxlbmd0aCIsInJpc2tUb2xlcmFuY2UiLCJwZXJzb25hbGl0eSIsInJpc2tfdG9sZXJhbmNlIiwiZGlzcGxheU5hbWUiLCJzdHlsZSIsInVuZGVmaW5lZCIsImluaXRpYWxDb25maWRlbmNlIiwiY29uZmlkZW5jZSIsInJvbGUiLCJzaG9ydEJpbyIsInNlY3RvcklkIiwic2VjdG9yX2lkIiwic2VjdG9yU3ltYm9sIiwic2VjdG9yX3N5bWJvbCIsInNlY3Rvck5hbWUiLCJzZWN0b3JfbmFtZSIsImRlY2lzaW9uU3R5bGUiLCJkZWNpc2lvbl9zdHlsZSIsInByb21wdCIsInByZWZlcmVuY2VzIiwicmlza1dlaWdodCIsInByb2ZpdFdlaWdodCIsInNwZWVkV2VpZ2h0IiwiYWNjdXJhY3lXZWlnaHQiLCJtb3JhbGUiLCJyZXdhcmRQb2ludHMiLCJjcmVhdGVkQXQiLCJjcmVhdGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwicmF3VHJhZGVzIiwicmF3UGVyZm9ybWFuY2UiLCJub3JtYWxpemVEaXNjdXNzaW9uIiwibWVzc2FnZXMiLCJtYXAiLCJhZ2VudElkIiwiYWdlbnRfaWQiLCJhZ2VudE5hbWUiLCJhZ2VudF9uYW1lIiwiY29udGVudCIsInRpbWVzdGFtcCIsImNoZWNrbGlzdERyYWZ0IiwiaXRlbSIsInJvdW5kIiwiY2hlY2tsaXN0Iiwic291cmNlQWdlbnRJZCIsImFjdGlvbiIsImFtb3VudCIsImFsbG9jYXRpb25QZXJjZW50Iiwic3ltYm9sIiwicmVhc29uIiwicmVhc29uaW5nIiwicmF0aW9uYWxlIiwiYXBwcm92YWxTdGF0dXMiLCJhcHByb3ZhbFJlYXNvbiIsImZpbmFsaXplZENoZWNrbGlzdCIsImNoZWNrbGlzdEl0ZW1zIiwibm9ybWFsaXplZFN0YXR1cyIsInRpdGxlIiwiYWdlbnRJZHMiLCJhZ2VudF9pZHMiLCJtZXNzYWdlc0NvdW50IiwibWVzc2FnZUNvdW50IiwidXBkYXRlZEF0IiwidXBkYXRlZF9hdCIsIm5vcm1hbGl6ZVNlY3RvciIsImJhc2VQcmljZSIsImN1cnJlbnRQcmljZSIsInByaWNlIiwiYWdlbnRzIiwiYWdlbnQiLCJjYW5kbGVEYXRhIiwiZmlsdGVyIiwicG9pbnQiLCJCb29sZWFuIiwiZGlzY3Vzc2lvbnMiLCJkaXNjdXNzaW9uIiwiYWN0aXZlQWdlbnRzIiwiYWN0aXZlX2FnZW50cyIsImNoYW5nZSIsImNoYW5nZVBlcmNlbnQiLCJjaGFuZ2VfcGVyY2VudCIsInZvbHVtZSIsInZvbGF0aWxpdHkiLCJyaXNrU2NvcmUiLCJidXlBZ2VudHMiLCJidXlfYWdlbnRzIiwic2VsbEFnZW50cyIsInNlbGxfYWdlbnRzIiwic3RhdHVzUGVyY2VudCIsInN0YXR1c19wZXJjZW50IiwiYmFsYW5jZSIsImxhc3RTaW11bGF0ZWRQcmljZSIsImluaXRpYWxQcmljZSIsImRlc2NyaXB0aW9uIiwiZmV0Y2hTZWN0b3JzIiwiZmV0Y2hTZWN0b3JCeUlkIiwibm9ybWFsaXplZElkIiwidG9Mb3dlckNhc2UiLCJmZXRjaFZhbHVhdGlvbkhpc3RvcnkiLCJ3aW5kb3ciLCJlbmNvZGVVUklDb21wb25lbnQiLCJmZXRjaEFnZW50cyIsImZldGNoQWdlbnRCeUlkIiwid2FybiIsImZldGNoRGlzY3Vzc2lvbnMiLCJwYWdlIiwicGFnZVNpemUiLCJwYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJwYWdpbmF0aW9uIiwidG90YWwiLCJ0b3RhbFBhZ2VzIiwiZmV0Y2hEaXNjdXNzaW9uTWVzc2FnZXMiLCJkaXNjdXNzaW9uSWQiLCJmZXRjaERpc2N1c3Npb25CeUlkIiwiZmV0Y2hSZWplY3RlZEl0ZW1zIiwicmVqZWN0ZWQiLCJmZXRjaENoZWNrbGlzdCIsImdldFJlamVjdGVkSXRlbXNGb3JEaXNjdXNzaW9uIiwic3VibWl0UmV2aXNpb24iLCJpdGVtSWQiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJuZXdDb250ZW50IiwiYWNjZXB0UmVqZWN0aW9uIiwiY3JlYXRlRGlzY3Vzc2lvbiIsImFkZERpc2N1c3Npb25NZXNzYWdlIiwiY2xvc2VEaXNjdXNzaW9uIiwic3RhcnREaXNjdXNzaW9uUm91bmRzIiwibnVtUm91bmRzIiwiZGVsZXRlRGlzY3Vzc2lvbiIsImFyY2hpdmVEaXNjdXNzaW9uIiwiYWNjZXB0RGlzY3Vzc2lvbiIsInJlamVjdERpc2N1c3Npb24iLCJjcmVhdGVTZWN0b3IiLCJjcmVhdGVBZ2VudCIsInJhd0FnZW50IiwibmV3RXJyb3IiLCJkZXBvc2l0U2VjdG9yIiwic2VjdG9yRGF0YSIsIndpdGhkcmF3U2VjdG9yIiwic2VjdG9yIiwid2l0aGRyYXduQW1vdW50IiwidXBkYXRlQWdlbnQiLCJ1cGRhdGVzIiwiZGVsZXRlQWdlbnQiLCJkZWxldGVTZWN0b3IiLCJjb25maXJtYXRpb25Db2RlIiwiZ2V0VXNlckJhbGFuY2UiLCJydW5Db25maWRlbmNlVGljayIsInNlbmRNZXNzYWdlVG9NYW5hZ2VyIiwiZmV0Y2hFeGVjdXRpb25Mb2dzIiwibG9ncyIsImdldE1hbmFnZXJFeGVjdXRpb25MaXN0IiwibWFuYWdlcklkIiwiZXhlY3V0aW9uTGlzdCIsImV4ZWN1dGVNYW5hZ2VyRXhlY3V0aW9uTGlzdCIsImNsZWFyQWxsRGlzY3Vzc2lvbnMiLCJiYWNrZW5kQmFzZSIsImZldGNoQWxsRXhlY3V0aW9uTG9ncyIsImZpbHRlcnMiLCJhY3Rpb25UeXBlIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsIk1hdGgiLCJkYXlzIiwiZmV0Y2hGaW5hbGl6ZWRSZWplY3Rpb25zIiwicmVqZWN0aW9ucyIsImZpbmFsaXplZFJlamVjdGlvbnMiLCJjbGVhckRlY2lzaW9uTG9ncyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});