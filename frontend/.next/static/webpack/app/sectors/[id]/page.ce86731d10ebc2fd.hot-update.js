"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/sectors/[id]/page",{

/***/ "(app-pages-browser)/./lib/stockData.ts":
/*!**************************!*\
  !*** ./lib/stockData.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchStockData: function() { return /* binding */ fetchStockData; },\n/* harmony export */   formatTimeRangeLabel: function() { return /* binding */ formatTimeRangeLabel; },\n/* harmony export */   getStockDataParams: function() { return /* binding */ getStockDataParams; }\n/* harmony export */ });\n/**\r\n * Stock Data API Utility\r\n * Fetches real stock market data using Yahoo Finance API\r\n */ /**\r\n * Fetch stock data from Yahoo Finance API\r\n * Uses yahoo-finance2-like endpoint (public API)\r\n */ async function fetchStockData(options) {\n    const { symbol, interval = \"1d\", range = \"1mo\" } = options;\n    // Validate symbol\n    if (!symbol || symbol.trim() === \"\" || symbol === \"N/A\") {\n        console.warn(\"Invalid symbol for stock data fetch:\", symbol);\n        return [];\n    }\n    try {\n        var _data_chart_result, _data_chart, _result_indicators_quote, _result_indicators;\n        // Use Yahoo Finance API via a public proxy or direct API\n        // Using yahoo-finance2 compatible endpoint\n        const baseUrl = \"https://query1.finance.yahoo.com/v8/finance/chart\";\n        // Clean and uppercase the symbol\n        const cleanSymbol = symbol.trim().toUpperCase();\n        const url = \"\".concat(baseUrl, \"/\").concat(encodeURIComponent(cleanSymbol), \"?interval=\").concat(interval, \"&range=\").concat(range);\n        const response = await fetch(url, {\n            headers: {\n                \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\",\n                \"Accept\": \"application/json\"\n            },\n            // Add timeout\n            signal: AbortSignal.timeout(10000)\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch stock data: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        const data = await response.json();\n        if (!(data === null || data === void 0 ? void 0 : (_data_chart = data.chart) === null || _data_chart === void 0 ? void 0 : (_data_chart_result = _data_chart.result) === null || _data_chart_result === void 0 ? void 0 : _data_chart_result[0])) {\n            throw new Error(\"Invalid stock data response: no chart data\");\n        }\n        const result = data.chart.result[0];\n        const timestamps = result.timestamp || [];\n        const quotes = ((_result_indicators = result.indicators) === null || _result_indicators === void 0 ? void 0 : (_result_indicators_quote = _result_indicators.quote) === null || _result_indicators_quote === void 0 ? void 0 : _result_indicators_quote[0]) || {};\n        const closes = quotes.close || [];\n        if (timestamps.length === 0 || closes.length === 0) {\n            console.warn(\"No price data available for symbol:\", cleanSymbol);\n            return [];\n        }\n        // Convert to our format\n        const dataPoints = timestamps.map((timestamp, index)=>{\n            const date = new Date(timestamp * 1000);\n            const value = closes[index];\n            // Skip if value is null or undefined\n            if (value === null || value === undefined || !Number.isFinite(value)) {\n                return null;\n            }\n            // Format time based on interval\n            let time;\n            if (interval === \"1d\" && (range === \"1d\" || range === \"5d\")) {\n                // Intraday: show time\n                const hours = date.getHours();\n                const minutes = date.getMinutes();\n                time = \"\".concat(hours.toString().padStart(2, \"0\"), \":\").concat(minutes.toString().padStart(2, \"0\"));\n            } else {\n                // Daily/Weekly/Monthly: show date\n                const month = (date.getMonth() + 1).toString().padStart(2, \"0\");\n                const day = date.getDate().toString().padStart(2, \"0\");\n                time = \"\".concat(month, \"/\").concat(day);\n            }\n            return {\n                time,\n                value: Number(value.toFixed(2)),\n                timestamp: timestamp * 1000,\n                date: date.toISOString().split(\"T\")[0]\n            };\n        }).filter((point)=>point !== null && point.value > 0);\n        if (dataPoints.length === 0) {\n            console.warn(\"No valid data points after filtering for symbol:\", cleanSymbol);\n        }\n        return dataPoints;\n    } catch (error) {\n        // Handle CORS or network errors gracefully\n        if (error instanceof Error) {\n            if (error.name === \"AbortError\" || error.message.includes(\"timeout\")) {\n                console.warn(\"Stock data fetch timed out for symbol:\", symbol);\n            } else if (error.message.includes(\"CORS\") || error.message.includes(\"Failed to fetch\")) {\n                console.warn(\"CORS error fetching stock data for symbol:\", symbol, \"- falling back to simulated data\");\n            } else {\n                console.error(\"Error fetching stock data for symbol:\", symbol, error);\n            }\n        } else {\n            console.error(\"Unknown error fetching stock data:\", error);\n        }\n        // Return empty array on error - fallback to simulated data\n        return [];\n    }\n}\n/**\r\n * Get appropriate interval and range for a time period\r\n */ function getStockDataParams(timeRange) {\n    switch(timeRange){\n        case \"1d\":\n            return {\n                interval: \"1d\",\n                range: \"1d\"\n            };\n        case \"1w\":\n        case \"1 week\":\n            return {\n                interval: \"1d\",\n                range: \"5d\"\n            };\n        case \"1m\":\n        case \"1 month\":\n            return {\n                interval: \"1d\",\n                range: \"1mo\"\n            };\n        case \"3m\":\n        case \"3 months\":\n            return {\n                interval: \"1d\",\n                range: \"3mo\"\n            };\n        case \"6m\":\n        case \"6 months\":\n            return {\n                interval: \"1wk\",\n                range: \"6mo\"\n            };\n        case \"1y\":\n        case \"1 year\":\n            return {\n                interval: \"1wk\",\n                range: \"1y\"\n            };\n        case \"max\":\n            return {\n                interval: \"1mo\",\n                range: \"max\"\n            };\n        default:\n            return {\n                interval: \"1d\",\n                range: \"1mo\"\n            };\n    }\n}\n/**\r\n * Convert time range string to display label\r\n */ function formatTimeRangeLabel(timeRange) {\n    switch(timeRange){\n        case \"1d\":\n            return \"1 Day\";\n        case \"1w\":\n        case \"1 week\":\n            return \"1 Week\";\n        case \"1m\":\n        case \"1 month\":\n            return \"1 Month\";\n        case \"3m\":\n        case \"3 months\":\n            return \"3 Months\";\n        case \"6m\":\n        case \"6 months\":\n            return \"6 Months\";\n        case \"1y\":\n        case \"1 year\":\n            return \"1 Year\";\n        case \"max\":\n            return \"Max\";\n        default:\n            return timeRange;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNYO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNJLG1CQUFtQkMsU0FBaUI7SUFDbEQsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTztnQkFBRTlELFVBQVU7Z0JBQU1DLE9BQU87WUFBSztRQUN2QyxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87Z0JBQUVELFVBQVU7Z0JBQU1DLE9BQU87WUFBSztRQUN2QyxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87Z0JBQUVELFVBQVU7Z0JBQU1DLE9BQU87WUFBTTtRQUN4QyxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87Z0JBQUVELFVBQVU7Z0JBQU1DLE9BQU87WUFBTTtRQUN4QyxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87Z0JBQUVELFVBQVU7Z0JBQU9DLE9BQU87WUFBTTtRQUN6QyxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87Z0JBQUVELFVBQVU7Z0JBQU9DLE9BQU87WUFBSztRQUN4QyxLQUFLO1lBQ0gsT0FBTztnQkFBRUQsVUFBVTtnQkFBT0MsT0FBTztZQUFNO1FBQ3pDO1lBQ0UsT0FBTztnQkFBRUQsVUFBVTtnQkFBTUMsT0FBTztZQUFNO0lBQzFDO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVM4RCxxQkFBcUJELFNBQWlCO0lBQ3BELE9BQVFBO1FBQ04sS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBT0E7SUFDWDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9zdG9ja0RhdGEudHM/NjllNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogU3RvY2sgRGF0YSBBUEkgVXRpbGl0eVxyXG4gKiBGZXRjaGVzIHJlYWwgc3RvY2sgbWFya2V0IGRhdGEgdXNpbmcgWWFob28gRmluYW5jZSBBUElcclxuICovXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0b2NrRGF0YVBvaW50IHtcclxuICB0aW1lOiBzdHJpbmc7IC8vIEZvcm1hdDogXCJISDpNTVwiIGZvciBpbnRyYWRheSwgXCJZWVlZLU1NLUREXCIgZm9yIGRhaWx5XHJcbiAgdmFsdWU6IG51bWJlcjtcclxuICB0aW1lc3RhbXA/OiBudW1iZXI7IC8vIFVuaXggdGltZXN0YW1wIGZvciBzb3J0aW5nXHJcbiAgZGF0ZT86IHN0cmluZzsgLy8gRnVsbCBkYXRlIHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0b2NrRGF0YU9wdGlvbnMge1xyXG4gIHN5bWJvbDogc3RyaW5nO1xyXG4gIGludGVydmFsPzogJzFkJyB8ICcxd2snIHwgJzFtbyc7IC8vIERhaWx5LCBXZWVrbHksIE1vbnRobHlcclxuICByYW5nZT86ICcxZCcgfCAnNWQnIHwgJzFtbycgfCAnM21vJyB8ICc2bW8nIHwgJzF5JyB8ICcyeScgfCAnNXknIHwgJzEweScgfCAneXRkJyB8ICdtYXgnO1xyXG59XHJcblxyXG4vKipcclxuICogRmV0Y2ggc3RvY2sgZGF0YSBmcm9tIFlhaG9vIEZpbmFuY2UgQVBJXHJcbiAqIFVzZXMgeWFob28tZmluYW5jZTItbGlrZSBlbmRwb2ludCAocHVibGljIEFQSSlcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFN0b2NrRGF0YShvcHRpb25zOiBTdG9ja0RhdGFPcHRpb25zKTogUHJvbWlzZTxTdG9ja0RhdGFQb2ludFtdPiB7XHJcbiAgY29uc3QgeyBzeW1ib2wsIGludGVydmFsID0gJzFkJywgcmFuZ2UgPSAnMW1vJyB9ID0gb3B0aW9ucztcclxuXHJcbiAgLy8gVmFsaWRhdGUgc3ltYm9sXHJcbiAgaWYgKCFzeW1ib2wgfHwgc3ltYm9sLnRyaW0oKSA9PT0gJycgfHwgc3ltYm9sID09PSAnTi9BJykge1xyXG4gICAgY29uc29sZS53YXJuKCdJbnZhbGlkIHN5bWJvbCBmb3Igc3RvY2sgZGF0YSBmZXRjaDonLCBzeW1ib2wpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIFVzZSBZYWhvbyBGaW5hbmNlIEFQSSB2aWEgYSBwdWJsaWMgcHJveHkgb3IgZGlyZWN0IEFQSVxyXG4gICAgLy8gVXNpbmcgeWFob28tZmluYW5jZTIgY29tcGF0aWJsZSBlbmRwb2ludFxyXG4gICAgY29uc3QgYmFzZVVybCA9ICdodHRwczovL3F1ZXJ5MS5maW5hbmNlLnlhaG9vLmNvbS92OC9maW5hbmNlL2NoYXJ0JztcclxuICAgIC8vIENsZWFuIGFuZCB1cHBlcmNhc2UgdGhlIHN5bWJvbFxyXG4gICAgY29uc3QgY2xlYW5TeW1ib2wgPSBzeW1ib2wudHJpbSgpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICBjb25zdCB1cmwgPSBgJHtiYXNlVXJsfS8ke2VuY29kZVVSSUNvbXBvbmVudChjbGVhblN5bWJvbCl9P2ludGVydmFsPSR7aW50ZXJ2YWx9JnJhbmdlPSR7cmFuZ2V9YDtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ1VzZXItQWdlbnQnOiAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2JyxcclxuICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICB9LFxyXG4gICAgICAvLyBBZGQgdGltZW91dFxyXG4gICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQoMTAwMDApLCAvLyAxMCBzZWNvbmQgdGltZW91dFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBzdG9jayBkYXRhOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgaWYgKCFkYXRhPy5jaGFydD8ucmVzdWx0Py5bMF0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0b2NrIGRhdGEgcmVzcG9uc2U6IG5vIGNoYXJ0IGRhdGEnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBkYXRhLmNoYXJ0LnJlc3VsdFswXTtcclxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSByZXN1bHQudGltZXN0YW1wIHx8IFtdO1xyXG4gICAgY29uc3QgcXVvdGVzID0gcmVzdWx0LmluZGljYXRvcnM/LnF1b3RlPy5bMF0gfHwge307XHJcbiAgICBjb25zdCBjbG9zZXMgPSBxdW90ZXMuY2xvc2UgfHwgW107XHJcblxyXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAwIHx8IGNsb3Nlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS53YXJuKCdObyBwcmljZSBkYXRhIGF2YWlsYWJsZSBmb3Igc3ltYm9sOicsIGNsZWFuU3ltYm9sKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnZlcnQgdG8gb3VyIGZvcm1hdFxyXG4gICAgY29uc3QgZGF0YVBvaW50czogU3RvY2tEYXRhUG9pbnRbXSA9IHRpbWVzdGFtcHNcclxuICAgICAgLm1hcCgodGltZXN0YW1wOiBudW1iZXIsIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodGltZXN0YW1wICogMTAwMCk7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjbG9zZXNbaW5kZXhdO1xyXG5cclxuICAgICAgICAvLyBTa2lwIGlmIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkXHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRm9ybWF0IHRpbWUgYmFzZWQgb24gaW50ZXJ2YWxcclxuICAgICAgICBsZXQgdGltZTogc3RyaW5nO1xyXG4gICAgICAgIGlmIChpbnRlcnZhbCA9PT0gJzFkJyAmJiAocmFuZ2UgPT09ICcxZCcgfHwgcmFuZ2UgPT09ICc1ZCcpKSB7XHJcbiAgICAgICAgICAvLyBJbnRyYWRheTogc2hvdyB0aW1lXHJcbiAgICAgICAgICBjb25zdCBob3VycyA9IGRhdGUuZ2V0SG91cnMoKTtcclxuICAgICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBkYXRlLmdldE1pbnV0ZXMoKTtcclxuICAgICAgICAgIHRpbWUgPSBgJHtob3Vycy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9OiR7bWludXRlcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gRGFpbHkvV2Vla2x5L01vbnRobHk6IHNob3cgZGF0ZVxyXG4gICAgICAgICAgY29uc3QgbW9udGggPSAoZGF0ZS5nZXRNb250aCgpICsgMSkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xyXG4gICAgICAgICAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXRlKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xyXG4gICAgICAgICAgdGltZSA9IGAke21vbnRofS8ke2RheX1gO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHRpbWUsXHJcbiAgICAgICAgICB2YWx1ZTogTnVtYmVyKHZhbHVlLnRvRml4ZWQoMikpLFxyXG4gICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAgKiAxMDAwLFxyXG4gICAgICAgICAgZGF0ZTogZGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXHJcbiAgICAgICAgfTtcclxuICAgICAgfSlcclxuICAgICAgLmZpbHRlcigocG9pbnQ6IFN0b2NrRGF0YVBvaW50IHwgbnVsbCk6IHBvaW50IGlzIFN0b2NrRGF0YVBvaW50ID0+IHBvaW50ICE9PSBudWxsICYmIHBvaW50LnZhbHVlID4gMCk7XHJcblxyXG4gICAgaWYgKGRhdGFQb2ludHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignTm8gdmFsaWQgZGF0YSBwb2ludHMgYWZ0ZXIgZmlsdGVyaW5nIGZvciBzeW1ib2w6JywgY2xlYW5TeW1ib2wpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhUG9pbnRzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAvLyBIYW5kbGUgQ09SUyBvciBuZXR3b3JrIGVycm9ycyBncmFjZWZ1bGx5XHJcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3RpbWVvdXQnKSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignU3RvY2sgZGF0YSBmZXRjaCB0aW1lZCBvdXQgZm9yIHN5bWJvbDonLCBzeW1ib2wpO1xyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0NPUlMnKSB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdGYWlsZWQgdG8gZmV0Y2gnKSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignQ09SUyBlcnJvciBmZXRjaGluZyBzdG9jayBkYXRhIGZvciBzeW1ib2w6Jywgc3ltYm9sLCAnLSBmYWxsaW5nIGJhY2sgdG8gc2ltdWxhdGVkIGRhdGEnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzdG9jayBkYXRhIGZvciBzeW1ib2w6Jywgc3ltYm9sLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Vua25vd24gZXJyb3IgZmV0Y2hpbmcgc3RvY2sgZGF0YTonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgb24gZXJyb3IgLSBmYWxsYmFjayB0byBzaW11bGF0ZWQgZGF0YVxyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhcHByb3ByaWF0ZSBpbnRlcnZhbCBhbmQgcmFuZ2UgZm9yIGEgdGltZSBwZXJpb2RcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdG9ja0RhdGFQYXJhbXModGltZVJhbmdlOiBzdHJpbmcpOiB7IGludGVydmFsOiAnMWQnIHwgJzF3aycgfCAnMW1vJzsgcmFuZ2U6IHN0cmluZyB9IHtcclxuICBzd2l0Y2ggKHRpbWVSYW5nZSkge1xyXG4gICAgY2FzZSAnMWQnOlxyXG4gICAgICByZXR1cm4geyBpbnRlcnZhbDogJzFkJywgcmFuZ2U6ICcxZCcgfTtcclxuICAgIGNhc2UgJzF3JzpcclxuICAgIGNhc2UgJzEgd2Vlayc6XHJcbiAgICAgIHJldHVybiB7IGludGVydmFsOiAnMWQnLCByYW5nZTogJzVkJyB9O1xyXG4gICAgY2FzZSAnMW0nOlxyXG4gICAgY2FzZSAnMSBtb250aCc6XHJcbiAgICAgIHJldHVybiB7IGludGVydmFsOiAnMWQnLCByYW5nZTogJzFtbycgfTtcclxuICAgIGNhc2UgJzNtJzpcclxuICAgIGNhc2UgJzMgbW9udGhzJzpcclxuICAgICAgcmV0dXJuIHsgaW50ZXJ2YWw6ICcxZCcsIHJhbmdlOiAnM21vJyB9O1xyXG4gICAgY2FzZSAnNm0nOlxyXG4gICAgY2FzZSAnNiBtb250aHMnOlxyXG4gICAgICByZXR1cm4geyBpbnRlcnZhbDogJzF3aycsIHJhbmdlOiAnNm1vJyB9O1xyXG4gICAgY2FzZSAnMXknOlxyXG4gICAgY2FzZSAnMSB5ZWFyJzpcclxuICAgICAgcmV0dXJuIHsgaW50ZXJ2YWw6ICcxd2snLCByYW5nZTogJzF5JyB9O1xyXG4gICAgY2FzZSAnbWF4JzpcclxuICAgICAgcmV0dXJuIHsgaW50ZXJ2YWw6ICcxbW8nLCByYW5nZTogJ21heCcgfTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiB7IGludGVydmFsOiAnMWQnLCByYW5nZTogJzFtbycgfTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IHRpbWUgcmFuZ2Ugc3RyaW5nIHRvIGRpc3BsYXkgbGFiZWxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUaW1lUmFuZ2VMYWJlbCh0aW1lUmFuZ2U6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgc3dpdGNoICh0aW1lUmFuZ2UpIHtcclxuICAgIGNhc2UgJzFkJzpcclxuICAgICAgcmV0dXJuICcxIERheSc7XHJcbiAgICBjYXNlICcxdyc6XHJcbiAgICBjYXNlICcxIHdlZWsnOlxyXG4gICAgICByZXR1cm4gJzEgV2Vlayc7XHJcbiAgICBjYXNlICcxbSc6XHJcbiAgICBjYXNlICcxIG1vbnRoJzpcclxuICAgICAgcmV0dXJuICcxIE1vbnRoJztcclxuICAgIGNhc2UgJzNtJzpcclxuICAgIGNhc2UgJzMgbW9udGhzJzpcclxuICAgICAgcmV0dXJuICczIE1vbnRocyc7XHJcbiAgICBjYXNlICc2bSc6XHJcbiAgICBjYXNlICc2IG1vbnRocyc6XHJcbiAgICAgIHJldHVybiAnNiBNb250aHMnO1xyXG4gICAgY2FzZSAnMXknOlxyXG4gICAgY2FzZSAnMSB5ZWFyJzpcclxuICAgICAgcmV0dXJuICcxIFllYXInO1xyXG4gICAgY2FzZSAnbWF4JzpcclxuICAgICAgcmV0dXJuICdNYXgnO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIHRpbWVSYW5nZTtcclxuICB9XHJcbn1cclxuXHJcbiJdLCJuYW1lcyI6WyJmZXRjaFN0b2NrRGF0YSIsIm9wdGlvbnMiLCJzeW1ib2wiLCJpbnRlcnZhbCIsInJhbmdlIiwidHJpbSIsImNvbnNvbGUiLCJ3YXJuIiwiZGF0YSIsInJlc3VsdCIsImJhc2VVcmwiLCJjbGVhblN5bWJvbCIsInRvVXBwZXJDYXNlIiwidXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJzaWduYWwiLCJBYm9ydFNpZ25hbCIsInRpbWVvdXQiLCJvayIsIkVycm9yIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImpzb24iLCJjaGFydCIsInRpbWVzdGFtcHMiLCJ0aW1lc3RhbXAiLCJxdW90ZXMiLCJpbmRpY2F0b3JzIiwicXVvdGUiLCJjbG9zZXMiLCJjbG9zZSIsImxlbmd0aCIsImRhdGFQb2ludHMiLCJtYXAiLCJpbmRleCIsImRhdGUiLCJEYXRlIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInRpbWUiLCJob3VycyIsImdldEhvdXJzIiwibWludXRlcyIsImdldE1pbnV0ZXMiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwibW9udGgiLCJnZXRNb250aCIsImRheSIsImdldERhdGUiLCJ0b0ZpeGVkIiwidG9JU09TdHJpbmciLCJzcGxpdCIsImZpbHRlciIsInBvaW50IiwiZXJyb3IiLCJuYW1lIiwibWVzc2FnZSIsImluY2x1ZGVzIiwiZ2V0U3RvY2tEYXRhUGFyYW1zIiwidGltZVJhbmdlIiwiZm9ybWF0VGltZVJhbmdlTGFiZWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/stockData.ts\n"));

/***/ })

});