"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/sectors/[id]/page",{

/***/ "(app-pages-browser)/./hooks/useExecutionRefresh.ts":
/*!**************************************!*\
  !*** ./hooks/useExecutionRefresh.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useExecutionRefresh: function() { return /* binding */ useExecutionRefresh; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./lib/api.ts\");\n/* harmony import */ var _usePolling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./usePolling */ \"(app-pages-browser)/./hooks/usePolling.ts\");\n/* __next_internal_client_entry_do_not_use__ useExecutionRefresh auto */ \n\n\n/**\r\n * Hook to detect execution completion and manage immediate refresh + fast polling\r\n * \r\n * Detects execution by comparing sector values (capital, pnl, utilization, trend)\r\n * When changes are detected, immediately refreshes all data and starts fast polling\r\n */ function useExecutionRefresh(param) {\n    let { sectorId, enabled = true, fastPollInterval = 650, normalPollInterval = 5000, callbacks = {} } = param;\n    const [isFastPolling, setIsFastPolling] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [highlightedFields, setHighlightedFields] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(new Set());\n    const previousSectorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const fastPollTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const executionDetectedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Track previous values for comparison\n    const previousValuesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    // Clear fast polling timeout\n    const clearFastPollTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (fastPollTimeoutRef.current) {\n            clearTimeout(fastPollTimeoutRef.current);\n            fastPollTimeoutRef.current = null;\n        }\n    }, []);\n    // Start fast polling after execution detection\n    const startFastPolling = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        var _callbacks_onExecutionDetected;\n        if (isFastPolling) return; // Already fast polling\n        setIsFastPolling(true);\n        executionDetectedRef.current = true;\n        (_callbacks_onExecutionDetected = callbacks.onExecutionDetected) === null || _callbacks_onExecutionDetected === void 0 ? void 0 : _callbacks_onExecutionDetected.call(callbacks);\n        // Stop fast polling after 30 seconds (enough time for values to stabilize)\n        clearFastPollTimeout();\n        fastPollTimeoutRef.current = setTimeout(()=>{\n            setIsFastPolling(false);\n            executionDetectedRef.current = false;\n            // Clear highlights after fast polling stops\n            setTimeout(()=>{\n                setHighlightedFields(new Set());\n            }, 1000);\n        }, 30000);\n    }, [\n        isFastPolling,\n        callbacks,\n        clearFastPollTimeout\n    ]);\n    // Detect execution by comparing sector values\n    const detectExecution = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((currentSector)=>{\n        var _prev_performance, _current_performance;\n        if (!currentSector) return false;\n        const prev = previousValuesRef.current;\n        const current = {\n            balance: currentSector.balance,\n            performance: currentSector.performance,\n            activeAgents: currentSector.activeAgents,\n            statusPercent: currentSector.statusPercent,\n            currentPrice: currentSector.currentPrice,\n            change: currentSector.change,\n            changePercent: currentSector.changePercent,\n            lastSimulatedPrice: currentSector.lastSimulatedPrice\n        };\n        // Check if any tracked values changed (indicating execution)\n        const fieldsToCheck = [\n            {\n                key: \"balance\",\n                prev: prev.balance,\n                curr: current.balance\n            },\n            {\n                key: \"totalPL\",\n                prev: (_prev_performance = prev.performance) === null || _prev_performance === void 0 ? void 0 : _prev_performance.totalPL,\n                curr: (_current_performance = current.performance) === null || _current_performance === void 0 ? void 0 : _current_performance.totalPL\n            },\n            {\n                key: \"activeAgents\",\n                prev: prev.activeAgents,\n                curr: current.activeAgents\n            },\n            {\n                key: \"statusPercent\",\n                prev: prev.statusPercent,\n                curr: current.statusPercent\n            },\n            {\n                key: \"currentPrice\",\n                prev: prev.currentPrice,\n                curr: current.currentPrice\n            },\n            {\n                key: \"change\",\n                prev: prev.change,\n                curr: current.change\n            },\n            {\n                key: \"changePercent\",\n                prev: prev.changePercent,\n                curr: current.changePercent\n            },\n            {\n                key: \"lastSimulatedPrice\",\n                prev: prev.lastSimulatedPrice,\n                curr: current.lastSimulatedPrice\n            }\n        ];\n        const changedFields = new Set();\n        let hasChanges = false;\n        for (const { key, prev, curr } of fieldsToCheck){\n            if (prev !== undefined && curr !== undefined && prev !== curr) {\n                hasChanges = true;\n                changedFields.add(key);\n            }\n        }\n        // Update previous values\n        previousValuesRef.current = {\n            balance: current.balance,\n            performance: current.performance,\n            activeAgents: current.activeAgents,\n            statusPercent: current.statusPercent,\n            currentPrice: current.currentPrice,\n            change: current.change,\n            changePercent: current.changePercent\n        };\n        if (hasChanges && !executionDetectedRef.current) {\n            // Highlight changed fields\n            setHighlightedFields(changedFields);\n            // Clear highlights after animation duration\n            setTimeout(()=>{\n                setHighlightedFields((prev)=>{\n                    const next = new Set(prev);\n                    changedFields.forEach((field)=>next.delete(field));\n                    return next;\n                });\n            }, 2000);\n            return true;\n        }\n        return false;\n    }, []);\n    // Refresh sector data\n    const refreshSector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!sectorId) return null;\n        try {\n            var _callbacks_onSectorUpdate;\n            const sector = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.fetchSectorById)(sectorId);\n            if ((0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.isSkippedResult)(sector) || !sector) {\n                return previousSectorRef.current;\n            }\n            // Detect execution\n            const executionDetected = detectExecution(sector);\n            if (executionDetected) {\n                startFastPolling();\n            }\n            previousSectorRef.current = sector;\n            (_callbacks_onSectorUpdate = callbacks.onSectorUpdate) === null || _callbacks_onSectorUpdate === void 0 ? void 0 : _callbacks_onSectorUpdate.call(callbacks, sector);\n            return sector;\n        } catch (error) {\n            console.error(\"[useExecutionRefresh] Failed to refresh sector:\", error);\n            return previousSectorRef.current;\n        }\n    }, [\n        sectorId,\n        detectExecution,\n        startFastPolling,\n        callbacks\n    ]);\n    // Refresh agents data\n    const refreshAgents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!sectorId) return [];\n        try {\n            var _callbacks_onAgentsUpdate;\n            const agents = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.fetchAgents)();\n            if ((0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.isSkippedResult)(agents) || !Array.isArray(agents)) {\n                return [];\n            }\n            const sectorAgents = agents.filter((agent)=>agent.sectorId && agent.sectorId.toLowerCase() === sectorId.toLowerCase());\n            (_callbacks_onAgentsUpdate = callbacks.onAgentsUpdate) === null || _callbacks_onAgentsUpdate === void 0 ? void 0 : _callbacks_onAgentsUpdate.call(callbacks, sectorAgents);\n            return sectorAgents;\n        } catch (error) {\n            console.error(\"[useExecutionRefresh] Failed to refresh agents:\", error);\n            return [];\n        }\n    }, [\n        sectorId,\n        callbacks\n    ]);\n    // Refresh discussions data\n    const refreshDiscussions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!sectorId) return [];\n        try {\n            var _callbacks_onDiscussionsUpdate;\n            const discussions = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.fetchDiscussions)();\n            if ((0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.isSkippedResult)(discussions) || !Array.isArray(discussions)) {\n                return [];\n            }\n            const sectorDiscussions = discussions.filter((discussion)=>discussion.sectorId && discussion.sectorId.toLowerCase() === sectorId.toLowerCase() && discussion.status !== \"closed\" && discussion.status !== \"archived\");\n            (_callbacks_onDiscussionsUpdate = callbacks.onDiscussionsUpdate) === null || _callbacks_onDiscussionsUpdate === void 0 ? void 0 : _callbacks_onDiscussionsUpdate.call(callbacks, sectorDiscussions);\n            return sectorDiscussions;\n        } catch (error) {\n            console.error(\"[useExecutionRefresh] Failed to refresh discussions:\", error);\n            return [];\n        }\n    }, [\n        sectorId,\n        callbacks\n    ]);\n    // Immediate refresh function (called when execution is detected)\n    const immediateRefresh = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!sectorId) return;\n        // Refresh all data immediately\n        await Promise.all([\n            refreshSector(),\n            refreshAgents(),\n            refreshDiscussions()\n        ]);\n    }, [\n        sectorId,\n        refreshSector,\n        refreshAgents,\n        refreshDiscussions\n    ]);\n    // Polling callback - uses fast or normal interval based on state\n    const pollCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!sectorId || !enabled) return;\n        await Promise.all([\n            refreshSector(),\n            refreshAgents(),\n            refreshDiscussions()\n        ]);\n    }, [\n        sectorId,\n        enabled,\n        refreshSector,\n        refreshAgents,\n        refreshDiscussions\n    ]);\n    // Use polling with dynamic interval\n    (0,_usePolling__WEBPACK_IMPORTED_MODULE_2__.usePolling)({\n        callback: pollCallback,\n        interval: isFastPolling ? fastPollInterval : normalPollInterval,\n        enabled: enabled && !!sectorId,\n        pauseWhenHidden: true,\n        immediate: false,\n        allowLowerInterval: true\n    });\n    // Cleanup on unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            clearFastPollTimeout();\n        };\n    }, [\n        clearFastPollTimeout\n    ]);\n    return {\n        isFastPolling,\n        highlightedFields,\n        immediateRefresh,\n        refreshSector,\n        refreshAgents,\n        refreshDiscussions\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUV4ZWN1dGlvblJlZnJlc2gudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7eUVBRWlFO0FBQzJCO0FBRWxEO0FBaUIxQzs7Ozs7Q0FLQyxHQUNNLFNBQVNTLG9CQUFvQixLQU1QO1FBTk8sRUFDbENDLFFBQVEsRUFDUkMsVUFBVSxJQUFJLEVBQ2RDLG1CQUFtQixHQUFHLEVBQ3RCQyxxQkFBcUIsSUFBSSxFQUN6QkMsWUFBWSxDQUFDLENBQUMsRUFDYSxHQU5PO0lBT2xDLE1BQU0sQ0FBQ0MsZUFBZUMsaUJBQWlCLEdBQUdkLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sQ0FBQ2UsbUJBQW1CQyxxQkFBcUIsR0FBR2hCLCtDQUFRQSxDQUFjLElBQUlpQjtJQUM1RSxNQUFNQyxvQkFBb0JuQiw2Q0FBTUEsQ0FBZ0I7SUFDaEQsTUFBTW9CLHFCQUFxQnBCLDZDQUFNQSxDQUF3QjtJQUN6RCxNQUFNcUIsdUJBQXVCckIsNkNBQU1BLENBQUM7SUFFcEMsdUNBQXVDO0lBQ3ZDLE1BQU1zQixvQkFBb0J0Qiw2Q0FBTUEsQ0FTN0IsQ0FBQztJQUVKLDZCQUE2QjtJQUM3QixNQUFNdUIsdUJBQXVCckIsa0RBQVdBLENBQUM7UUFDdkMsSUFBSWtCLG1CQUFtQkksT0FBTyxFQUFFO1lBQzlCQyxhQUFhTCxtQkFBbUJJLE9BQU87WUFDdkNKLG1CQUFtQkksT0FBTyxHQUFHO1FBQy9CO0lBQ0YsR0FBRyxFQUFFO0lBRUwsK0NBQStDO0lBQy9DLE1BQU1FLG1CQUFtQnhCLGtEQUFXQSxDQUFDO1lBS25DVztRQUpBLElBQUlDLGVBQWUsUUFBUSx1QkFBdUI7UUFFbERDLGlCQUFpQjtRQUNqQk0scUJBQXFCRyxPQUFPLEdBQUc7U0FDL0JYLGlDQUFBQSxVQUFVYyxtQkFBbUIsY0FBN0JkLHFEQUFBQSxvQ0FBQUE7UUFFQSwyRUFBMkU7UUFDM0VVO1FBQ0FILG1CQUFtQkksT0FBTyxHQUFHSSxXQUFXO1lBQ3RDYixpQkFBaUI7WUFDakJN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QUMvQixJQUFJLENBQUNPLFlBQVksQ0FBQ0MsU0FBUztRQUUzQixNQUFNZ0UsUUFBUUMsR0FBRyxDQUFDO1lBQ2hCdkI7WUFDQU07WUFDQVM7U0FDRDtJQUNILEdBQUc7UUFBQzFEO1FBQVVDO1FBQVMwQztRQUFlTTtRQUFlUztLQUFtQjtJQUV4RSxvQ0FBb0M7SUFDcEM1RCx1REFBVUEsQ0FBQztRQUNUc0UsVUFBVUQ7UUFDVkUsVUFBVWhFLGdCQUFnQkgsbUJBQW1CQztRQUM3Q0YsU0FBU0EsV0FBVyxDQUFDLENBQUNEO1FBQ3RCc0UsaUJBQWlCO1FBQ2pCQyxXQUFXO1FBQ1hDLG9CQUFvQjtJQUN0QjtJQUVBLHFCQUFxQjtJQUNyQmxGLGdEQUFTQSxDQUFDO1FBQ1IsT0FBTztZQUNMd0I7UUFDRjtJQUNGLEdBQUc7UUFBQ0E7S0FBcUI7SUFFekIsT0FBTztRQUNMVDtRQUNBRTtRQUNBeUQ7UUFDQXJCO1FBQ0FNO1FBQ0FTO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy91c2VFeGVjdXRpb25SZWZyZXNoLnRzPzU1OGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgZmV0Y2hTZWN0b3JCeUlkLCBmZXRjaEFnZW50cywgZmV0Y2hEaXNjdXNzaW9ucywgaXNTa2lwcGVkUmVzdWx0IH0gZnJvbSAnQC9saWIvYXBpJztcclxuaW1wb3J0IHR5cGUgeyBTZWN0b3IsIEFnZW50LCBEaXNjdXNzaW9uIH0gZnJvbSAnQC9saWIvdHlwZXMnO1xyXG5pbXBvcnQgeyB1c2VQb2xsaW5nIH0gZnJvbSAnLi91c2VQb2xsaW5nJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRXhlY3V0aW9uUmVmcmVzaENhbGxiYWNrcyB7XHJcbiAgb25TZWN0b3JVcGRhdGU/OiAoc2VjdG9yOiBTZWN0b3IpID0+IHZvaWQ7XHJcbiAgb25BZ2VudHNVcGRhdGU/OiAoYWdlbnRzOiBBZ2VudFtdKSA9PiB2b2lkO1xyXG4gIG9uRGlzY3Vzc2lvbnNVcGRhdGU/OiAoZGlzY3Vzc2lvbnM6IERpc2N1c3Npb25bXSkgPT4gdm9pZDtcclxuICBvbkV4ZWN1dGlvbkRldGVjdGVkPzogKCkgPT4gdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VFeGVjdXRpb25SZWZyZXNoT3B0aW9ucyB7XHJcbiAgc2VjdG9ySWQ6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgZW5hYmxlZD86IGJvb2xlYW47XHJcbiAgZmFzdFBvbGxJbnRlcnZhbD86IG51bWJlcjsgLy8gSW50ZXJ2YWwgZm9yIGZhc3QgcG9sbGluZyBhZnRlciBleGVjdXRpb24gKGRlZmF1bHQ6IDY1MG1zKVxyXG4gIG5vcm1hbFBvbGxJbnRlcnZhbD86IG51bWJlcjsgLy8gTm9ybWFsIHBvbGxpbmcgaW50ZXJ2YWwgKGRlZmF1bHQ6IDUwMDBtcylcclxuICBjYWxsYmFja3M/OiBFeGVjdXRpb25SZWZyZXNoQ2FsbGJhY2tzO1xyXG59XHJcblxyXG4vKipcclxuICogSG9vayB0byBkZXRlY3QgZXhlY3V0aW9uIGNvbXBsZXRpb24gYW5kIG1hbmFnZSBpbW1lZGlhdGUgcmVmcmVzaCArIGZhc3QgcG9sbGluZ1xyXG4gKiBcclxuICogRGV0ZWN0cyBleGVjdXRpb24gYnkgY29tcGFyaW5nIHNlY3RvciB2YWx1ZXMgKGNhcGl0YWwsIHBubCwgdXRpbGl6YXRpb24sIHRyZW5kKVxyXG4gKiBXaGVuIGNoYW5nZXMgYXJlIGRldGVjdGVkLCBpbW1lZGlhdGVseSByZWZyZXNoZXMgYWxsIGRhdGEgYW5kIHN0YXJ0cyBmYXN0IHBvbGxpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VFeGVjdXRpb25SZWZyZXNoKHtcclxuICBzZWN0b3JJZCxcclxuICBlbmFibGVkID0gdHJ1ZSxcclxuICBmYXN0UG9sbEludGVydmFsID0gNjUwLFxyXG4gIG5vcm1hbFBvbGxJbnRlcnZhbCA9IDUwMDAsXHJcbiAgY2FsbGJhY2tzID0ge30sXHJcbn06IFVzZUV4ZWN1dGlvblJlZnJlc2hPcHRpb25zKSB7XHJcbiAgY29uc3QgW2lzRmFzdFBvbGxpbmcsIHNldElzRmFzdFBvbGxpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtoaWdobGlnaHRlZEZpZWxkcywgc2V0SGlnaGxpZ2h0ZWRGaWVsZHNdID0gdXNlU3RhdGU8U2V0PHN0cmluZz4+KG5ldyBTZXQoKSk7XHJcbiAgY29uc3QgcHJldmlvdXNTZWN0b3JSZWYgPSB1c2VSZWY8U2VjdG9yIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgZmFzdFBvbGxUaW1lb3V0UmVmID0gdXNlUmVmPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgZXhlY3V0aW9uRGV0ZWN0ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xyXG5cclxuICAvLyBUcmFjayBwcmV2aW91cyB2YWx1ZXMgZm9yIGNvbXBhcmlzb25cclxuICBjb25zdCBwcmV2aW91c1ZhbHVlc1JlZiA9IHVzZVJlZjx7XHJcbiAgICBiYWxhbmNlPzogbnVtYmVyO1xyXG4gICAgcGVyZm9ybWFuY2U/OiB7IHRvdGFsUEw/OiBudW1iZXIgfTtcclxuICAgIGFjdGl2ZUFnZW50cz86IG51bWJlcjtcclxuICAgIHN0YXR1c1BlcmNlbnQ/OiBudW1iZXI7XHJcbiAgICBjdXJyZW50UHJpY2U/OiBudW1iZXI7XHJcbiAgICBjaGFuZ2U/OiBudW1iZXI7XHJcbiAgICBjaGFuZ2VQZXJjZW50PzogbnVtYmVyO1xyXG4gICAgbGFzdFNpbXVsYXRlZFByaWNlPzogbnVtYmVyIHwgbnVsbDtcclxuICB9Pih7fSk7XHJcblxyXG4gIC8vIENsZWFyIGZhc3QgcG9sbGluZyB0aW1lb3V0XHJcbiAgY29uc3QgY2xlYXJGYXN0UG9sbFRpbWVvdXQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBpZiAoZmFzdFBvbGxUaW1lb3V0UmVmLmN1cnJlbnQpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KGZhc3RQb2xsVGltZW91dFJlZi5jdXJyZW50KTtcclxuICAgICAgZmFzdFBvbGxUaW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8gU3RhcnQgZmFzdCBwb2xsaW5nIGFmdGVyIGV4ZWN1dGlvbiBkZXRlY3Rpb25cclxuICBjb25zdCBzdGFydEZhc3RQb2xsaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKGlzRmFzdFBvbGxpbmcpIHJldHVybjsgLy8gQWxyZWFkeSBmYXN0IHBvbGxpbmdcclxuICAgIFxyXG4gICAgc2V0SXNGYXN0UG9sbGluZyh0cnVlKTtcclxuICAgIGV4ZWN1dGlvbkRldGVjdGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgY2FsbGJhY2tzLm9uRXhlY3V0aW9uRGV0ZWN0ZWQ/LigpO1xyXG5cclxuICAgIC8vIFN0b3AgZmFzdCBwb2xsaW5nIGFmdGVyIDMwIHNlY29uZHMgKGVub3VnaCB0aW1lIGZvciB2YWx1ZXMgdG8gc3RhYmlsaXplKVxyXG4gICAgY2xlYXJGYXN0UG9sbFRpbWVvdXQoKTtcclxuICAgIGZhc3RQb2xsVGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHNldElzRmFzdFBvbGxpbmcoZmFsc2UpO1xyXG4gICAgICBleGVjdXRpb25EZXRlY3RlZFJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgIC8vIENsZWFyIGhpZ2hsaWdodHMgYWZ0ZXIgZmFzdCBwb2xsaW5nIHN0b3BzXHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHNldEhpZ2hsaWdodGVkRmllbGRzKG5ldyBTZXQoKSk7XHJcbiAgICAgIH0sIDEwMDApO1xyXG4gICAgfSwgMzAwMDApO1xyXG4gIH0sIFtpc0Zhc3RQb2xsaW5nLCBjYWxsYmFja3MsIGNsZWFyRmFzdFBvbGxUaW1lb3V0XSk7XHJcblxyXG4gIC8vIERldGVjdCBleGVjdXRpb24gYnkgY29tcGFyaW5nIHNlY3RvciB2YWx1ZXNcclxuICBjb25zdCBkZXRlY3RFeGVjdXRpb24gPSB1c2VDYWxsYmFjaygoY3VycmVudFNlY3RvcjogU2VjdG9yKSA9PiB7XHJcbiAgICBpZiAoIWN1cnJlbnRTZWN0b3IpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICBjb25zdCBwcmV2ID0gcHJldmlvdXNWYWx1ZXNSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IGN1cnJlbnQgPSB7XHJcbiAgICAgIGJhbGFuY2U6IGN1cnJlbnRTZWN0b3IuYmFsYW5jZSxcclxuICAgICAgcGVyZm9ybWFuY2U6IGN1cnJlbnRTZWN0b3IucGVyZm9ybWFuY2UsXHJcbiAgICAgIGFjdGl2ZUFnZW50czogY3VycmVudFNlY3Rvci5hY3RpdmVBZ2VudHMsXHJcbiAgICAgIHN0YXR1c1BlcmNlbnQ6IGN1cnJlbnRTZWN0b3Iuc3RhdHVzUGVyY2VudCxcclxuICAgICAgY3VycmVudFByaWNlOiBjdXJyZW50U2VjdG9yLmN1cnJlbnRQcmljZSxcclxuICAgICAgY2hhbmdlOiBjdXJyZW50U2VjdG9yLmNoYW5nZSxcclxuICAgICAgY2hhbmdlUGVyY2VudDogY3VycmVudFNlY3Rvci5jaGFuZ2VQZXJjZW50LFxyXG4gICAgICBsYXN0U2ltdWxhdGVkUHJpY2U6IGN1cnJlbnRTZWN0b3IubGFzdFNpbXVsYXRlZFByaWNlLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiBhbnkgdHJhY2tlZCB2YWx1ZXMgY2hhbmdlZCAoaW5kaWNhdGluZyBleGVjdXRpb24pXHJcbiAgICBjb25zdCBmaWVsZHNUb0NoZWNrID0gW1xyXG4gICAgICB7IGtleTogJ2JhbGFuY2UnLCBwcmV2OiBwcmV2LmJhbGFuY2UsIGN1cnI6IGN1cnJlbnQuYmFsYW5jZSB9LFxyXG4gICAgICB7IGtleTogJ3RvdGFsUEwnLCBwcmV2OiBwcmV2LnBlcmZvcm1hbmNlPy50b3RhbFBMLCBjdXJyOiBjdXJyZW50LnBlcmZvcm1hbmNlPy50b3RhbFBMIH0sXHJcbiAgICAgIHsga2V5OiAnYWN0aXZlQWdlbnRzJywgcHJldjogcHJldi5hY3RpdmVBZ2VudHMsIGN1cnI6IGN1cnJlbnQuYWN0aXZlQWdlbnRzIH0sXHJcbiAgICAgIHsga2V5OiAnc3RhdHVzUGVyY2VudCcsIHByZXY6IHByZXYuc3RhdHVzUGVyY2VudCwgY3VycjogY3VycmVudC5zdGF0dXNQZXJjZW50IH0sXHJcbiAgICAgIHsga2V5OiAnY3VycmVudFByaWNlJywgcHJldjogcHJldi5jdXJyZW50UHJpY2UsIGN1cnI6IGN1cnJlbnQuY3VycmVudFByaWNlIH0sXHJcbiAgICAgIHsga2V5OiAnY2hhbmdlJywgcHJldjogcHJldi5jaGFuZ2UsIGN1cnI6IGN1cnJlbnQuY2hhbmdlIH0sXHJcbiAgICAgIHsga2V5OiAnY2hhbmdlUGVyY2VudCcsIHByZXY6IHByZXYuY2hhbmdlUGVyY2VudCwgY3VycjogY3VycmVudC5jaGFuZ2VQZXJjZW50IH0sXHJcbiAgICAgIHsga2V5OiAnbGFzdFNpbXVsYXRlZFByaWNlJywgcHJldjogcHJldi5sYXN0U2ltdWxhdGVkUHJpY2UsIGN1cnI6IGN1cnJlbnQubGFzdFNpbXVsYXRlZFByaWNlIH0sXHJcbiAgICBdO1xyXG5cclxuICAgIGNvbnN0IGNoYW5nZWRGaWVsZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICAgIGxldCBoYXNDaGFuZ2VzID0gZmFsc2U7XHJcblxyXG4gICAgZm9yIChjb25zdCB7IGtleSwgcHJldiwgY3VyciB9IG9mIGZpZWxkc1RvQ2hlY2spIHtcclxuICAgICAgaWYgKHByZXYgIT09IHVuZGVmaW5lZCAmJiBjdXJyICE9PSB1bmRlZmluZWQgJiYgcHJldiAhPT0gY3Vycikge1xyXG4gICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xyXG4gICAgICAgIGNoYW5nZWRGaWVsZHMuYWRkKGtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBVcGRhdGUgcHJldmlvdXMgdmFsdWVzXHJcbiAgICBwcmV2aW91c1ZhbHVlc1JlZi5jdXJyZW50ID0ge1xyXG4gICAgICBiYWxhbmNlOiBjdXJyZW50LmJhbGFuY2UsXHJcbiAgICAgIHBlcmZvcm1hbmNlOiBjdXJyZW50LnBlcmZvcm1hbmNlLFxyXG4gICAgICBhY3RpdmVBZ2VudHM6IGN1cnJlbnQuYWN0aXZlQWdlbnRzLFxyXG4gICAgICBzdGF0dXNQZXJjZW50OiBjdXJyZW50LnN0YXR1c1BlcmNlbnQsXHJcbiAgICAgIGN1cnJlbnRQcmljZTogY3VycmVudC5jdXJyZW50UHJpY2UsXHJcbiAgICAgIGNoYW5nZTogY3VycmVudC5jaGFuZ2UsXHJcbiAgICAgIGNoYW5nZVBlcmNlbnQ6IGN1cnJlbnQuY2hhbmdlUGVyY2VudCxcclxuICAgIH07XHJcblxyXG4gICAgaWYgKGhhc0NoYW5nZXMgJiYgIWV4ZWN1dGlvbkRldGVjdGVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgLy8gSGlnaGxpZ2h0IGNoYW5nZWQgZmllbGRzXHJcbiAgICAgIHNldEhpZ2hsaWdodGVkRmllbGRzKGNoYW5nZWRGaWVsZHMpO1xyXG4gICAgICAvLyBDbGVhciBoaWdobGlnaHRzIGFmdGVyIGFuaW1hdGlvbiBkdXJhdGlvblxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBzZXRIaWdobGlnaHRlZEZpZWxkcyhwcmV2ID0+IHtcclxuICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXcgU2V0KHByZXYpO1xyXG4gICAgICAgICAgY2hhbmdlZEZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IG5leHQuZGVsZXRlKGZpZWxkKSk7XHJcbiAgICAgICAgICByZXR1cm4gbmV4dDtcclxuICAgICAgICB9KTtcclxuICAgICAgfSwgMjAwMCk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSwgW10pO1xyXG5cclxuICAvLyBSZWZyZXNoIHNlY3RvciBkYXRhXHJcbiAgY29uc3QgcmVmcmVzaFNlY3RvciA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgIGlmICghc2VjdG9ySWQpIHJldHVybiBudWxsO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHNlY3RvciA9IGF3YWl0IGZldGNoU2VjdG9yQnlJZChzZWN0b3JJZCk7XHJcbiAgICAgIGlmIChpc1NraXBwZWRSZXN1bHQoc2VjdG9yKSB8fCAhc2VjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzU2VjdG9yUmVmLmN1cnJlbnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERldGVjdCBleGVjdXRpb25cclxuICAgICAgY29uc3QgZXhlY3V0aW9uRGV0ZWN0ZWQgPSBkZXRlY3RFeGVjdXRpb24oc2VjdG9yKTtcclxuICAgICAgaWYgKGV4ZWN1dGlvbkRldGVjdGVkKSB7XHJcbiAgICAgICAgc3RhcnRGYXN0UG9sbGluZygpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcmV2aW91c1NlY3RvclJlZi5jdXJyZW50ID0gc2VjdG9yO1xyXG4gICAgICBjYWxsYmFja3Mub25TZWN0b3JVcGRhdGU/LihzZWN0b3IpO1xyXG4gICAgICByZXR1cm4gc2VjdG9yO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignW3VzZUV4ZWN1dGlvblJlZnJlc2hdIEZhaWxlZCB0byByZWZyZXNoIHNlY3RvcjonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBwcmV2aW91c1NlY3RvclJlZi5jdXJyZW50O1xyXG4gICAgfVxyXG4gIH0sIFtzZWN0b3JJZCwgZGV0ZWN0RXhlY3V0aW9uLCBzdGFydEZhc3RQb2xsaW5nLCBjYWxsYmFja3NdKTtcclxuXHJcbiAgLy8gUmVmcmVzaCBhZ2VudHMgZGF0YVxyXG4gIGNvbnN0IHJlZnJlc2hBZ2VudHMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoIXNlY3RvcklkKSByZXR1cm4gW107XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgYWdlbnRzID0gYXdhaXQgZmV0Y2hBZ2VudHMoKTtcclxuICAgICAgaWYgKGlzU2tpcHBlZFJlc3VsdChhZ2VudHMpIHx8ICFBcnJheS5pc0FycmF5KGFnZW50cykpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHNlY3RvckFnZW50cyA9IGFnZW50cy5maWx0ZXIoYWdlbnQgPT4gXHJcbiAgICAgICAgYWdlbnQuc2VjdG9ySWQgJiYgYWdlbnQuc2VjdG9ySWQudG9Mb3dlckNhc2UoKSA9PT0gc2VjdG9ySWQudG9Mb3dlckNhc2UoKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY2FsbGJhY2tzLm9uQWdlbnRzVXBkYXRlPy4oc2VjdG9yQWdlbnRzKTtcclxuICAgICAgcmV0dXJuIHNlY3RvckFnZW50cztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1t1c2VFeGVjdXRpb25SZWZyZXNoXSBGYWlsZWQgdG8gcmVmcmVzaCBhZ2VudHM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfSwgW3NlY3RvcklkLCBjYWxsYmFja3NdKTtcclxuXHJcbiAgLy8gUmVmcmVzaCBkaXNjdXNzaW9ucyBkYXRhXHJcbiAgY29uc3QgcmVmcmVzaERpc2N1c3Npb25zID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCFzZWN0b3JJZCkgcmV0dXJuIFtdO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRpc2N1c3Npb25zID0gYXdhaXQgZmV0Y2hEaXNjdXNzaW9ucygpO1xyXG4gICAgICBpZiAoaXNTa2lwcGVkUmVzdWx0KGRpc2N1c3Npb25zKSB8fCAhQXJyYXkuaXNBcnJheShkaXNjdXNzaW9ucykpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHNlY3RvckRpc2N1c3Npb25zID0gZGlzY3Vzc2lvbnMuZmlsdGVyKGRpc2N1c3Npb24gPT5cclxuICAgICAgICBkaXNjdXNzaW9uLnNlY3RvcklkICYmIFxyXG4gICAgICAgIGRpc2N1c3Npb24uc2VjdG9ySWQudG9Mb3dlckNhc2UoKSA9PT0gc2VjdG9ySWQudG9Mb3dlckNhc2UoKSAmJlxyXG4gICAgICAgIGRpc2N1c3Npb24uc3RhdHVzICE9PSAnY2xvc2VkJyAmJlxyXG4gICAgICAgIGRpc2N1c3Npb24uc3RhdHVzICE9PSAnYXJjaGl2ZWQnXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjYWxsYmFja3Mub25EaXNjdXNzaW9uc1VwZGF0ZT8uKHNlY3RvckRpc2N1c3Npb25zKTtcclxuICAgICAgcmV0dXJuIHNlY3RvckRpc2N1c3Npb25zO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignW3VzZUV4ZWN1dGlvblJlZnJlc2hdIEZhaWxlZCB0byByZWZyZXNoIGRpc2N1c3Npb25zOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH0sIFtzZWN0b3JJZCwgY2FsbGJhY2tzXSk7XHJcblxyXG4gIC8vIEltbWVkaWF0ZSByZWZyZXNoIGZ1bmN0aW9uIChjYWxsZWQgd2hlbiBleGVjdXRpb24gaXMgZGV0ZWN0ZWQpXHJcbiAgY29uc3QgaW1tZWRpYXRlUmVmcmVzaCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgIGlmICghc2VjdG9ySWQpIHJldHVybjtcclxuXHJcbiAgICAvLyBSZWZyZXNoIGFsbCBkYXRhIGltbWVkaWF0ZWx5XHJcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgIHJlZnJlc2hTZWN0b3IoKSxcclxuICAgICAgcmVmcmVzaEFnZW50cygpLFxyXG4gICAgICByZWZyZXNoRGlzY3Vzc2lvbnMoKSxcclxuICAgIF0pO1xyXG4gIH0sIFtzZWN0b3JJZCwgcmVmcmVzaFNlY3RvciwgcmVmcmVzaEFnZW50cywgcmVmcmVzaERpc2N1c3Npb25zXSk7XHJcblxyXG4gIC8vIFBvbGxpbmcgY2FsbGJhY2sgLSB1c2VzIGZhc3Qgb3Igbm9ybWFsIGludGVydmFsIGJhc2VkIG9uIHN0YXRlXHJcbiAgY29uc3QgcG9sbENhbGxiYWNrID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCFzZWN0b3JJZCB8fCAhZW5hYmxlZCkgcmV0dXJuO1xyXG5cclxuICAgIGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgcmVmcmVzaFNlY3RvcigpLFxyXG4gICAgICByZWZyZXNoQWdlbnRzKCksXHJcbiAgICAgIHJlZnJlc2hEaXNjdXNzaW9ucygpLFxyXG4gICAgXSk7XHJcbiAgfSwgW3NlY3RvcklkLCBlbmFibGVkLCByZWZyZXNoU2VjdG9yLCByZWZyZXNoQWdlbnRzLCByZWZyZXNoRGlzY3Vzc2lvbnNdKTtcclxuXHJcbiAgLy8gVXNlIHBvbGxpbmcgd2l0aCBkeW5hbWljIGludGVydmFsXHJcbiAgdXNlUG9sbGluZyh7XHJcbiAgICBjYWxsYmFjazogcG9sbENhbGxiYWNrLFxyXG4gICAgaW50ZXJ2YWw6IGlzRmFzdFBvbGxpbmcgPyBmYXN0UG9sbEludGVydmFsIDogbm9ybWFsUG9sbEludGVydmFsLFxyXG4gICAgZW5hYmxlZDogZW5hYmxlZCAmJiAhIXNlY3RvcklkLFxyXG4gICAgcGF1c2VXaGVuSGlkZGVuOiB0cnVlLFxyXG4gICAgaW1tZWRpYXRlOiBmYWxzZSxcclxuICAgIGFsbG93TG93ZXJJbnRlcnZhbDogdHJ1ZSxcclxuICB9KTtcclxuXHJcbiAgLy8gQ2xlYW51cCBvbiB1bm1vdW50XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGNsZWFyRmFzdFBvbGxUaW1lb3V0KCk7XHJcbiAgICB9O1xyXG4gIH0sIFtjbGVhckZhc3RQb2xsVGltZW91dF0pO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgaXNGYXN0UG9sbGluZyxcclxuICAgIGhpZ2hsaWdodGVkRmllbGRzLFxyXG4gICAgaW1tZWRpYXRlUmVmcmVzaCxcclxuICAgIHJlZnJlc2hTZWN0b3IsXHJcbiAgICByZWZyZXNoQWdlbnRzLFxyXG4gICAgcmVmcmVzaERpc2N1c3Npb25zLFxyXG4gIH07XHJcbn1cclxuXHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiZmV0Y2hTZWN0b3JCeUlkIiwiZmV0Y2hBZ2VudHMiLCJmZXRjaERpc2N1c3Npb25zIiwiaXNTa2lwcGVkUmVzdWx0IiwidXNlUG9sbGluZyIsInVzZUV4ZWN1dGlvblJlZnJlc2giLCJzZWN0b3JJZCIsImVuYWJsZWQiLCJmYXN0UG9sbEludGVydmFsIiwibm9ybWFsUG9sbEludGVydmFsIiwiY2FsbGJhY2tzIiwiaXNGYXN0UG9sbGluZyIsInNldElzRmFzdFBvbGxpbmciLCJoaWdobGlnaHRlZEZpZWxkcyIsInNldEhpZ2hsaWdodGVkRmllbGRzIiwiU2V0IiwicHJldmlvdXNTZWN0b3JSZWYiLCJmYXN0UG9sbFRpbWVvdXRSZWYiLCJleGVjdXRpb25EZXRlY3RlZFJlZiIsInByZXZpb3VzVmFsdWVzUmVmIiwiY2xlYXJGYXN0UG9sbFRpbWVvdXQiLCJjdXJyZW50IiwiY2xlYXJUaW1lb3V0Iiwic3RhcnRGYXN0UG9sbGluZyIsIm9uRXhlY3V0aW9uRGV0ZWN0ZWQiLCJzZXRUaW1lb3V0IiwiZGV0ZWN0RXhlY3V0aW9uIiwiY3VycmVudFNlY3RvciIsInByZXYiLCJiYWxhbmNlIiwicGVyZm9ybWFuY2UiLCJhY3RpdmVBZ2VudHMiLCJzdGF0dXNQZXJjZW50IiwiY3VycmVudFByaWNlIiwiY2hhbmdlIiwiY2hhbmdlUGVyY2VudCIsImxhc3RTaW11bGF0ZWRQcmljZSIsImZpZWxkc1RvQ2hlY2siLCJrZXkiLCJjdXJyIiwidG90YWxQTCIsImNoYW5nZWRGaWVsZHMiLCJoYXNDaGFuZ2VzIiwidW5kZWZpbmVkIiwiYWRkIiwibmV4dCIsImZvckVhY2giLCJmaWVsZCIsImRlbGV0ZSIsInJlZnJlc2hTZWN0b3IiLCJzZWN0b3IiLCJleGVjdXRpb25EZXRlY3RlZCIsIm9uU2VjdG9yVXBkYXRlIiwiZXJyb3IiLCJjb25zb2xlIiwicmVmcmVzaEFnZW50cyIsImFnZW50cyIsIkFycmF5IiwiaXNBcnJheSIsInNlY3RvckFnZW50cyIsImZpbHRlciIsImFnZW50IiwidG9Mb3dlckNhc2UiLCJvbkFnZW50c1VwZGF0ZSIsInJlZnJlc2hEaXNjdXNzaW9ucyIsImRpc2N1c3Npb25zIiwic2VjdG9yRGlzY3Vzc2lvbnMiLCJkaXNjdXNzaW9uIiwic3RhdHVzIiwib25EaXNjdXNzaW9uc1VwZGF0ZSIsImltbWVkaWF0ZVJlZnJlc2giLCJQcm9taXNlIiwiYWxsIiwicG9sbENhbGxiYWNrIiwiY2FsbGJhY2siLCJpbnRlcnZhbCIsInBhdXNlV2hlbkhpZGRlbiIsImltbWVkaWF0ZSIsImFsbG93TG93ZXJJbnRlcnZhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useExecutionRefresh.ts\n"));

/***/ })

});