"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/sectors/[id]/page",{

/***/ "(app-pages-browser)/./hooks/useExecutionRefresh.ts":
/*!**************************************!*\
  !*** ./hooks/useExecutionRefresh.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useExecutionRefresh: function() { return /* binding */ useExecutionRefresh; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./lib/api.ts\");\n/* harmony import */ var _usePolling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./usePolling */ \"(app-pages-browser)/./hooks/usePolling.ts\");\n/* __next_internal_client_entry_do_not_use__ useExecutionRefresh auto */ \n\n\n/**\r\n * Hook to detect execution completion and manage immediate refresh + fast polling\r\n * \r\n * Detects execution by comparing sector values (capital, pnl, utilization, trend)\r\n * When changes are detected, immediately refreshes all data and starts fast polling\r\n */ function useExecutionRefresh(param) {\n    let { sectorId, enabled = true, fastPollInterval = 650, normalPollInterval = 5000, callbacks = {} } = param;\n    const [isFastPolling, setIsFastPolling] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [highlightedFields, setHighlightedFields] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(new Set());\n    const previousSectorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const fastPollTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const executionDetectedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Track previous values for comparison\n    const previousValuesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    // Clear fast polling timeout\n    const clearFastPollTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (fastPollTimeoutRef.current) {\n            clearTimeout(fastPollTimeoutRef.current);\n            fastPollTimeoutRef.current = null;\n        }\n    }, []);\n    // Start fast polling after execution detection\n    const startFastPolling = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        var _callbacks_onExecutionDetected;\n        if (isFastPolling) return; // Already fast polling\n        setIsFastPolling(true);\n        executionDetectedRef.current = true;\n        (_callbacks_onExecutionDetected = callbacks.onExecutionDetected) === null || _callbacks_onExecutionDetected === void 0 ? void 0 : _callbacks_onExecutionDetected.call(callbacks);\n        // Stop fast polling after 30 seconds (enough time for values to stabilize)\n        clearFastPollTimeout();\n        fastPollTimeoutRef.current = setTimeout(()=>{\n            setIsFastPolling(false);\n            executionDetectedRef.current = false;\n            // Clear highlights after fast polling stops\n            setTimeout(()=>{\n                setHighlightedFields(new Set());\n            }, 1000);\n        }, 30000);\n    }, [\n        isFastPolling,\n        callbacks,\n        clearFastPollTimeout\n    ]);\n    // Detect execution by comparing sector values\n    const detectExecution = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((currentSector)=>{\n        var _prev_performance, _current_performance;\n        if (!currentSector) return false;\n        const prev = previousValuesRef.current;\n        const current = {\n            balance: currentSector.balance,\n            performance: currentSector.performance,\n            activeAgents: currentSector.activeAgents,\n            statusPercent: currentSector.statusPercent,\n            currentPrice: currentSector.currentPrice,\n            change: currentSector.change,\n            changePercent: currentSector.changePercent,\n            lastSimulatedPrice: currentSector.lastSimulatedPrice\n        };\n        // Check if any tracked values changed (indicating execution)\n        const fieldsToCheck = [\n            {\n                key: \"balance\",\n                prev: prev.balance,\n                curr: current.balance\n            },\n            {\n                key: \"totalPL\",\n                prev: (_prev_performance = prev.performance) === null || _prev_performance === void 0 ? void 0 : _prev_performance.totalPL,\n                curr: (_current_performance = current.performance) === null || _current_performance === void 0 ? void 0 : _current_performance.totalPL\n            },\n            {\n                key: \"activeAgents\",\n                prev: prev.activeAgents,\n                curr: current.activeAgents\n            },\n            {\n                key: \"statusPercent\",\n                prev: prev.statusPercent,\n                curr: current.statusPercent\n            },\n            {\n                key: \"currentPrice\",\n                prev: prev.currentPrice,\n                curr: current.currentPrice\n            },\n            {\n                key: \"change\",\n                prev: prev.change,\n                curr: current.change\n            },\n            {\n                key: \"changePercent\",\n                prev: prev.changePercent,\n                curr: current.changePercent\n            },\n            {\n                key: \"lastSimulatedPrice\",\n                prev: prev.lastSimulatedPrice,\n                curr: current.lastSimulatedPrice\n            }\n        ];\n        const changedFields = new Set();\n        let hasChanges = false;\n        for (const { key, prev, curr } of fieldsToCheck){\n            if (prev !== undefined && curr !== undefined && prev !== curr) {\n                hasChanges = true;\n                changedFields.add(key);\n            }\n        }\n        // Update previous values\n        previousValuesRef.current = {\n            balance: current.balance,\n            performance: current.performance,\n            activeAgents: current.activeAgents,\n            statusPercent: current.statusPercent,\n            currentPrice: current.currentPrice,\n            change: current.change,\n            changePercent: current.changePercent,\n            lastSimulatedPrice: current.lastSimulatedPrice\n        };\n        if (hasChanges && !executionDetectedRef.current) {\n            // Highlight changed fields\n            setHighlightedFields(changedFields);\n            // Clear highlights after animation duration\n            setTimeout(()=>{\n                setHighlightedFields((prev)=>{\n                    const next = new Set(prev);\n                    changedFields.forEach((field)=>next.delete(field));\n                    return next;\n                });\n            }, 2000);\n            return true;\n        }\n        return false;\n    }, []);\n    // Refresh sector data\n    const refreshSector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!sectorId) return null;\n        try {\n            var _callbacks_onSectorUpdate;\n            const sector = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.fetchSectorById)(sectorId);\n            if ((0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.isSkippedResult)(sector) || !sector) {\n                return previousSectorRef.current;\n            }\n            // Detect execution\n            const executionDetected = detectExecution(sector);\n            if (executionDetected) {\n                startFastPolling();\n            }\n            previousSectorRef.current = sector;\n            (_callbacks_onSectorUpdate = callbacks.onSectorUpdate) === null || _callbacks_onSectorUpdate === void 0 ? void 0 : _callbacks_onSectorUpdate.call(callbacks, sector);\n            return sector;\n        } catch (error) {\n            console.error(\"[useExecutionRefresh] Failed to refresh sector:\", error);\n            return previousSectorRef.current;\n        }\n    }, [\n        sectorId,\n        detectExecution,\n        startFastPolling,\n        callbacks\n    ]);\n    // Refresh agents data\n    const refreshAgents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!sectorId) return [];\n        try {\n            var _callbacks_onAgentsUpdate;\n            const agents = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.fetchAgents)();\n            if ((0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.isSkippedResult)(agents) || !Array.isArray(agents)) {\n                return [];\n            }\n            const sectorAgents = agents.filter((agent)=>agent.sectorId && agent.sectorId.toLowerCase() === sectorId.toLowerCase());\n            (_callbacks_onAgentsUpdate = callbacks.onAgentsUpdate) === null || _callbacks_onAgentsUpdate === void 0 ? void 0 : _callbacks_onAgentsUpdate.call(callbacks, sectorAgents);\n            return sectorAgents;\n        } catch (error) {\n            console.error(\"[useExecutionRefresh] Failed to refresh agents:\", error);\n            return [];\n        }\n    }, [\n        sectorId,\n        callbacks\n    ]);\n    // Refresh discussions data\n    const refreshDiscussions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!sectorId) return [];\n        try {\n            var _callbacks_onDiscussionsUpdate;\n            const discussions = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.fetchDiscussions)();\n            if ((0,_lib_api__WEBPACK_IMPORTED_MODULE_1__.isSkippedResult)(discussions) || !Array.isArray(discussions)) {\n                return [];\n            }\n            const sectorDiscussions = discussions.filter((discussion)=>discussion.sectorId && discussion.sectorId.toLowerCase() === sectorId.toLowerCase() && discussion.status !== \"closed\" && discussion.status !== \"archived\");\n            (_callbacks_onDiscussionsUpdate = callbacks.onDiscussionsUpdate) === null || _callbacks_onDiscussionsUpdate === void 0 ? void 0 : _callbacks_onDiscussionsUpdate.call(callbacks, sectorDiscussions);\n            return sectorDiscussions;\n        } catch (error) {\n            console.error(\"[useExecutionRefresh] Failed to refresh discussions:\", error);\n            return [];\n        }\n    }, [\n        sectorId,\n        callbacks\n    ]);\n    // Immediate refresh function (called when execution is detected)\n    const immediateRefresh = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!sectorId) return;\n        // Refresh all data immediately\n        await Promise.all([\n            refreshSector(),\n            refreshAgents(),\n            refreshDiscussions()\n        ]);\n    }, [\n        sectorId,\n        refreshSector,\n        refreshAgents,\n        refreshDiscussions\n    ]);\n    // Polling callback - uses fast or normal interval based on state\n    const pollCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!sectorId || !enabled) return;\n        await Promise.all([\n            refreshSector(),\n            refreshAgents(),\n            refreshDiscussions()\n        ]);\n    }, [\n        sectorId,\n        enabled,\n        refreshSector,\n        refreshAgents,\n        refreshDiscussions\n    ]);\n    // Use polling with dynamic interval\n    (0,_usePolling__WEBPACK_IMPORTED_MODULE_2__.usePolling)({\n        callback: pollCallback,\n        interval: isFastPolling ? fastPollInterval : normalPollInterval,\n        enabled: enabled && !!sectorId,\n        pauseWhenHidden: true,\n        immediate: false,\n        allowLowerInterval: true\n    });\n    // Cleanup on unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            clearFastPollTimeout();\n        };\n    }, [\n        clearFastPollTimeout\n    ]);\n    return {\n        isFastPolling,\n        highlightedFields,\n        immediateRefresh,\n        refreshSector,\n        refreshAgents,\n        refreshDiscussions\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUV4ZWN1dGlvblJlZnJlc2gudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7eUVBRWlFO0FBQzJCO0FBRWxEO0FBaUIxQzs7Ozs7Q0FLQyxHQUNNLFNBQVNTLG9CQUFvQixLQU1QO1FBTk8sRUFDbENDLFFBQVEsRUFDUkMsVUFBVSxJQUFJLEVBQ2RDLG1CQUFtQixHQUFHLEVBQ3RCQyxxQkFBcUIsSUFBSSxFQUN6QkMsWUFBWSxDQUFDLENBQUMsRUFDYSxHQU5PO0lBT2xDLE1BQU0sQ0FBQ0MsZUFBZUMsaUJBQWlCLEdBQUdkLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sQ0FBQ2UsbUJBQW1CQyxxQkFBcUIsR0FBR2hCLCtDQUFRQSxDQUFjLElBQUlpQjtJQUM1RSxNQUFNQyxvQkFBb0JuQiw2Q0FBTUEsQ0FBZ0I7SUFDaEQsTUFBTW9CLHFCQUFxQnBCLDZDQUFNQSxDQUF3QjtJQUN6RCxNQUFNcUIsdUJBQXVCckIsNkNBQU1BLENBQUM7SUFFcEMsdUNBQXVDO0lBQ3ZDLE1BQU1zQixvQkFBb0J0Qiw2Q0FBTUEsQ0FTN0IsQ0FBQztJQUVKLDZCQUE2QjtJQUM3QixNQUFNdUIsdUJBQXVCckIsa0RBQVdBLENBQUM7UUFDdkMsSUFBSWtCLG1CQUFtQkksT0FBTyxFQUFFO1lBQzlCQyxhQUFhTCxtQkFBbUJJLE9BQU87WUFDdkNKLG1CQUFtQkksT0FBTyxHQUFHO1FBQy9CO0lBQ0YsR0FBRyxFQUFFO0lBRUwsK0NBQStDO0lBQy9DLE1BQU1FLG1CQUFtQnhCLGtEQUFXQSxDQUFDO1lBS25DVztRQUpBLElBQUlDLGVBQWUsUUFBUSx1QkFBdUI7UUFFbERDLGlCQUFpQjtRQUNqQk0scUJBQXFCRyxPQUFPLEdBQUc7U0FDL0JYLGlDQUFBQSxVQUFVYyxtQkFBbUIsY0FBN0JkLHFEQUFBQSxvQ0FBQUE7UUFFQSwyRUFBMkU7UUFDM0VVO1FBQ0FILG1CQUFtQkksT0FBTyxHQUFHSSxXQUFXO1lBQ3RDYixpQkFBaUI7WUFDakJN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RSxNQUFNUyxlQUFlMUUsa0RBQVdBLENBQUM7UUFDL0IsSUFBSSxDQUFDTyxZQUFZLENBQUNDLFNBQVM7UUFFM0IsTUFBTWdFLFFBQVFDLEdBQUcsQ0FBQztZQUNoQnZCO1lBQ0FNO1lBQ0FTO1NBQ0Q7SUFDSCxHQUFHO1FBQUMxRDtRQUFVQztRQUFTMEM7UUFBZU07UUFBZVM7S0FBbUI7SUFFeEUsb0NBQW9DO0lBQ3BDNUQsdURBQVVBLENBQUM7UUFDVHNFLFVBQVVEO1FBQ1ZFLFVBQVVoRSxnQkFBZ0JILG1CQUFtQkM7UUFDN0NGLFNBQVNBLFdBQVcsQ0FBQyxDQUFDRDtRQUN0QnNFLGlCQUFpQjtRQUNqQkMsV0FBVztRQUNYQyxvQkFBb0I7SUFDdEI7SUFFQSxxQkFBcUI7SUFDckJsRixnREFBU0EsQ0FBQztRQUNSLE9BQU87WUFDTHdCO1FBQ0Y7SUFDRixHQUFHO1FBQUNBO0tBQXFCO0lBRXpCLE9BQU87UUFDTFQ7UUFDQUU7UUFDQXlEO1FBQ0FyQjtRQUNBTTtRQUNBUztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlRXhlY3V0aW9uUmVmcmVzaC50cz81NThkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IGZldGNoU2VjdG9yQnlJZCwgZmV0Y2hBZ2VudHMsIGZldGNoRGlzY3Vzc2lvbnMsIGlzU2tpcHBlZFJlc3VsdCB9IGZyb20gJ0AvbGliL2FwaSc7XHJcbmltcG9ydCB0eXBlIHsgU2VjdG9yLCBBZ2VudCwgRGlzY3Vzc2lvbiB9IGZyb20gJ0AvbGliL3R5cGVzJztcclxuaW1wb3J0IHsgdXNlUG9sbGluZyB9IGZyb20gJy4vdXNlUG9sbGluZyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEV4ZWN1dGlvblJlZnJlc2hDYWxsYmFja3Mge1xyXG4gIG9uU2VjdG9yVXBkYXRlPzogKHNlY3RvcjogU2VjdG9yKSA9PiB2b2lkO1xyXG4gIG9uQWdlbnRzVXBkYXRlPzogKGFnZW50czogQWdlbnRbXSkgPT4gdm9pZDtcclxuICBvbkRpc2N1c3Npb25zVXBkYXRlPzogKGRpc2N1c3Npb25zOiBEaXNjdXNzaW9uW10pID0+IHZvaWQ7XHJcbiAgb25FeGVjdXRpb25EZXRlY3RlZD86ICgpID0+IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlRXhlY3V0aW9uUmVmcmVzaE9wdGlvbnMge1xyXG4gIHNlY3RvcklkOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gIGVuYWJsZWQ/OiBib29sZWFuO1xyXG4gIGZhc3RQb2xsSW50ZXJ2YWw/OiBudW1iZXI7IC8vIEludGVydmFsIGZvciBmYXN0IHBvbGxpbmcgYWZ0ZXIgZXhlY3V0aW9uIChkZWZhdWx0OiA2NTBtcylcclxuICBub3JtYWxQb2xsSW50ZXJ2YWw/OiBudW1iZXI7IC8vIE5vcm1hbCBwb2xsaW5nIGludGVydmFsIChkZWZhdWx0OiA1MDAwbXMpXHJcbiAgY2FsbGJhY2tzPzogRXhlY3V0aW9uUmVmcmVzaENhbGxiYWNrcztcclxufVxyXG5cclxuLyoqXHJcbiAqIEhvb2sgdG8gZGV0ZWN0IGV4ZWN1dGlvbiBjb21wbGV0aW9uIGFuZCBtYW5hZ2UgaW1tZWRpYXRlIHJlZnJlc2ggKyBmYXN0IHBvbGxpbmdcclxuICogXHJcbiAqIERldGVjdHMgZXhlY3V0aW9uIGJ5IGNvbXBhcmluZyBzZWN0b3IgdmFsdWVzIChjYXBpdGFsLCBwbmwsIHV0aWxpemF0aW9uLCB0cmVuZClcclxuICogV2hlbiBjaGFuZ2VzIGFyZSBkZXRlY3RlZCwgaW1tZWRpYXRlbHkgcmVmcmVzaGVzIGFsbCBkYXRhIGFuZCBzdGFydHMgZmFzdCBwb2xsaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlRXhlY3V0aW9uUmVmcmVzaCh7XHJcbiAgc2VjdG9ySWQsXHJcbiAgZW5hYmxlZCA9IHRydWUsXHJcbiAgZmFzdFBvbGxJbnRlcnZhbCA9IDY1MCxcclxuICBub3JtYWxQb2xsSW50ZXJ2YWwgPSA1MDAwLFxyXG4gIGNhbGxiYWNrcyA9IHt9LFxyXG59OiBVc2VFeGVjdXRpb25SZWZyZXNoT3B0aW9ucykge1xyXG4gIGNvbnN0IFtpc0Zhc3RQb2xsaW5nLCBzZXRJc0Zhc3RQb2xsaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbaGlnaGxpZ2h0ZWRGaWVsZHMsIHNldEhpZ2hsaWdodGVkRmllbGRzXSA9IHVzZVN0YXRlPFNldDxzdHJpbmc+PihuZXcgU2V0KCkpO1xyXG4gIGNvbnN0IHByZXZpb3VzU2VjdG9yUmVmID0gdXNlUmVmPFNlY3RvciB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGZhc3RQb2xsVGltZW91dFJlZiA9IHVzZVJlZjxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGV4ZWN1dGlvbkRldGVjdGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcclxuXHJcbiAgLy8gVHJhY2sgcHJldmlvdXMgdmFsdWVzIGZvciBjb21wYXJpc29uXHJcbiAgY29uc3QgcHJldmlvdXNWYWx1ZXNSZWYgPSB1c2VSZWY8e1xyXG4gICAgYmFsYW5jZT86IG51bWJlcjtcclxuICAgIHBlcmZvcm1hbmNlPzogeyB0b3RhbFBMPzogbnVtYmVyIH07XHJcbiAgICBhY3RpdmVBZ2VudHM/OiBudW1iZXI7XHJcbiAgICBzdGF0dXNQZXJjZW50PzogbnVtYmVyO1xyXG4gICAgY3VycmVudFByaWNlPzogbnVtYmVyO1xyXG4gICAgY2hhbmdlPzogbnVtYmVyO1xyXG4gICAgY2hhbmdlUGVyY2VudD86IG51bWJlcjtcclxuICAgIGxhc3RTaW11bGF0ZWRQcmljZT86IG51bWJlciB8IG51bGw7XHJcbiAgfT4oe30pO1xyXG5cclxuICAvLyBDbGVhciBmYXN0IHBvbGxpbmcgdGltZW91dFxyXG4gIGNvbnN0IGNsZWFyRmFzdFBvbGxUaW1lb3V0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKGZhc3RQb2xsVGltZW91dFJlZi5jdXJyZW50KSB7XHJcbiAgICAgIGNsZWFyVGltZW91dChmYXN0UG9sbFRpbWVvdXRSZWYuY3VycmVudCk7XHJcbiAgICAgIGZhc3RQb2xsVGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgIH1cclxuICB9LCBbXSk7XHJcblxyXG4gIC8vIFN0YXJ0IGZhc3QgcG9sbGluZyBhZnRlciBleGVjdXRpb24gZGV0ZWN0aW9uXHJcbiAgY29uc3Qgc3RhcnRGYXN0UG9sbGluZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGlmIChpc0Zhc3RQb2xsaW5nKSByZXR1cm47IC8vIEFscmVhZHkgZmFzdCBwb2xsaW5nXHJcbiAgICBcclxuICAgIHNldElzRmFzdFBvbGxpbmcodHJ1ZSk7XHJcbiAgICBleGVjdXRpb25EZXRlY3RlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgIGNhbGxiYWNrcy5vbkV4ZWN1dGlvbkRldGVjdGVkPy4oKTtcclxuXHJcbiAgICAvLyBTdG9wIGZhc3QgcG9sbGluZyBhZnRlciAzMCBzZWNvbmRzIChlbm91Z2ggdGltZSBmb3IgdmFsdWVzIHRvIHN0YWJpbGl6ZSlcclxuICAgIGNsZWFyRmFzdFBvbGxUaW1lb3V0KCk7XHJcbiAgICBmYXN0UG9sbFRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBzZXRJc0Zhc3RQb2xsaW5nKGZhbHNlKTtcclxuICAgICAgZXhlY3V0aW9uRGV0ZWN0ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICAvLyBDbGVhciBoaWdobGlnaHRzIGFmdGVyIGZhc3QgcG9sbGluZyBzdG9wc1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBzZXRIaWdobGlnaHRlZEZpZWxkcyhuZXcgU2V0KCkpO1xyXG4gICAgICB9LCAxMDAwKTtcclxuICAgIH0sIDMwMDAwKTtcclxuICB9LCBbaXNGYXN0UG9sbGluZywgY2FsbGJhY2tzLCBjbGVhckZhc3RQb2xsVGltZW91dF0pO1xyXG5cclxuICAvLyBEZXRlY3QgZXhlY3V0aW9uIGJ5IGNvbXBhcmluZyBzZWN0b3IgdmFsdWVzXHJcbiAgY29uc3QgZGV0ZWN0RXhlY3V0aW9uID0gdXNlQ2FsbGJhY2soKGN1cnJlbnRTZWN0b3I6IFNlY3RvcikgPT4ge1xyXG4gICAgaWYgKCFjdXJyZW50U2VjdG9yKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgY29uc3QgcHJldiA9IHByZXZpb3VzVmFsdWVzUmVmLmN1cnJlbnQ7XHJcbiAgICBjb25zdCBjdXJyZW50ID0ge1xyXG4gICAgICBiYWxhbmNlOiBjdXJyZW50U2VjdG9yLmJhbGFuY2UsXHJcbiAgICAgIHBlcmZvcm1hbmNlOiBjdXJyZW50U2VjdG9yLnBlcmZvcm1hbmNlLFxyXG4gICAgICBhY3RpdmVBZ2VudHM6IGN1cnJlbnRTZWN0b3IuYWN0aXZlQWdlbnRzLFxyXG4gICAgICBzdGF0dXNQZXJjZW50OiBjdXJyZW50U2VjdG9yLnN0YXR1c1BlcmNlbnQsXHJcbiAgICAgIGN1cnJlbnRQcmljZTogY3VycmVudFNlY3Rvci5jdXJyZW50UHJpY2UsXHJcbiAgICAgIGNoYW5nZTogY3VycmVudFNlY3Rvci5jaGFuZ2UsXHJcbiAgICAgIGNoYW5nZVBlcmNlbnQ6IGN1cnJlbnRTZWN0b3IuY2hhbmdlUGVyY2VudCxcclxuICAgICAgbGFzdFNpbXVsYXRlZFByaWNlOiBjdXJyZW50U2VjdG9yLmxhc3RTaW11bGF0ZWRQcmljZSxcclxuICAgIH07XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgYW55IHRyYWNrZWQgdmFsdWVzIGNoYW5nZWQgKGluZGljYXRpbmcgZXhlY3V0aW9uKVxyXG4gICAgY29uc3QgZmllbGRzVG9DaGVjayA9IFtcclxuICAgICAgeyBrZXk6ICdiYWxhbmNlJywgcHJldjogcHJldi5iYWxhbmNlLCBjdXJyOiBjdXJyZW50LmJhbGFuY2UgfSxcclxuICAgICAgeyBrZXk6ICd0b3RhbFBMJywgcHJldjogcHJldi5wZXJmb3JtYW5jZT8udG90YWxQTCwgY3VycjogY3VycmVudC5wZXJmb3JtYW5jZT8udG90YWxQTCB9LFxyXG4gICAgICB7IGtleTogJ2FjdGl2ZUFnZW50cycsIHByZXY6IHByZXYuYWN0aXZlQWdlbnRzLCBjdXJyOiBjdXJyZW50LmFjdGl2ZUFnZW50cyB9LFxyXG4gICAgICB7IGtleTogJ3N0YXR1c1BlcmNlbnQnLCBwcmV2OiBwcmV2LnN0YXR1c1BlcmNlbnQsIGN1cnI6IGN1cnJlbnQuc3RhdHVzUGVyY2VudCB9LFxyXG4gICAgICB7IGtleTogJ2N1cnJlbnRQcmljZScsIHByZXY6IHByZXYuY3VycmVudFByaWNlLCBjdXJyOiBjdXJyZW50LmN1cnJlbnRQcmljZSB9LFxyXG4gICAgICB7IGtleTogJ2NoYW5nZScsIHByZXY6IHByZXYuY2hhbmdlLCBjdXJyOiBjdXJyZW50LmNoYW5nZSB9LFxyXG4gICAgICB7IGtleTogJ2NoYW5nZVBlcmNlbnQnLCBwcmV2OiBwcmV2LmNoYW5nZVBlcmNlbnQsIGN1cnI6IGN1cnJlbnQuY2hhbmdlUGVyY2VudCB9LFxyXG4gICAgICB7IGtleTogJ2xhc3RTaW11bGF0ZWRQcmljZScsIHByZXY6IHByZXYubGFzdFNpbXVsYXRlZFByaWNlLCBjdXJyOiBjdXJyZW50Lmxhc3RTaW11bGF0ZWRQcmljZSB9LFxyXG4gICAgXTtcclxuXHJcbiAgICBjb25zdCBjaGFuZ2VkRmllbGRzID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcbiAgICBsZXQgaGFzQ2hhbmdlcyA9IGZhbHNlO1xyXG5cclxuICAgIGZvciAoY29uc3QgeyBrZXksIHByZXYsIGN1cnIgfSBvZiBmaWVsZHNUb0NoZWNrKSB7XHJcbiAgICAgIGlmIChwcmV2ICE9PSB1bmRlZmluZWQgJiYgY3VyciAhPT0gdW5kZWZpbmVkICYmIHByZXYgIT09IGN1cnIpIHtcclxuICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgICBjaGFuZ2VkRmllbGRzLmFkZChrZXkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBkYXRlIHByZXZpb3VzIHZhbHVlc1xyXG4gICAgcHJldmlvdXNWYWx1ZXNSZWYuY3VycmVudCA9IHtcclxuICAgICAgYmFsYW5jZTogY3VycmVudC5iYWxhbmNlLFxyXG4gICAgICBwZXJmb3JtYW5jZTogY3VycmVudC5wZXJmb3JtYW5jZSxcclxuICAgICAgYWN0aXZlQWdlbnRzOiBjdXJyZW50LmFjdGl2ZUFnZW50cyxcclxuICAgICAgc3RhdHVzUGVyY2VudDogY3VycmVudC5zdGF0dXNQZXJjZW50LFxyXG4gICAgICBjdXJyZW50UHJpY2U6IGN1cnJlbnQuY3VycmVudFByaWNlLFxyXG4gICAgICBjaGFuZ2U6IGN1cnJlbnQuY2hhbmdlLFxyXG4gICAgICBjaGFuZ2VQZXJjZW50OiBjdXJyZW50LmNoYW5nZVBlcmNlbnQsXHJcbiAgICAgIGxhc3RTaW11bGF0ZWRQcmljZTogY3VycmVudC5sYXN0U2ltdWxhdGVkUHJpY2UsXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChoYXNDaGFuZ2VzICYmICFleGVjdXRpb25EZXRlY3RlZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgIC8vIEhpZ2hsaWdodCBjaGFuZ2VkIGZpZWxkc1xyXG4gICAgICBzZXRIaWdobGlnaHRlZEZpZWxkcyhjaGFuZ2VkRmllbGRzKTtcclxuICAgICAgLy8gQ2xlYXIgaGlnaGxpZ2h0cyBhZnRlciBhbmltYXRpb24gZHVyYXRpb25cclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgc2V0SGlnaGxpZ2h0ZWRGaWVsZHMocHJldiA9PiB7XHJcbiAgICAgICAgICBjb25zdCBuZXh0ID0gbmV3IFNldChwcmV2KTtcclxuICAgICAgICAgIGNoYW5nZWRGaWVsZHMuZm9yRWFjaChmaWVsZCA9PiBuZXh0LmRlbGV0ZShmaWVsZCkpO1xyXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sIDIwMDApO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8gUmVmcmVzaCBzZWN0b3IgZGF0YVxyXG4gIGNvbnN0IHJlZnJlc2hTZWN0b3IgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoIXNlY3RvcklkKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzZWN0b3IgPSBhd2FpdCBmZXRjaFNlY3RvckJ5SWQoc2VjdG9ySWQpO1xyXG4gICAgICBpZiAoaXNTa2lwcGVkUmVzdWx0KHNlY3RvcikgfHwgIXNlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiBwcmV2aW91c1NlY3RvclJlZi5jdXJyZW50O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZXRlY3QgZXhlY3V0aW9uXHJcbiAgICAgIGNvbnN0IGV4ZWN1dGlvbkRldGVjdGVkID0gZGV0ZWN0RXhlY3V0aW9uKHNlY3Rvcik7XHJcbiAgICAgIGlmIChleGVjdXRpb25EZXRlY3RlZCkge1xyXG4gICAgICAgIHN0YXJ0RmFzdFBvbGxpbmcoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHJldmlvdXNTZWN0b3JSZWYuY3VycmVudCA9IHNlY3RvcjtcclxuICAgICAgY2FsbGJhY2tzLm9uU2VjdG9yVXBkYXRlPy4oc2VjdG9yKTtcclxuICAgICAgcmV0dXJuIHNlY3RvcjtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1t1c2VFeGVjdXRpb25SZWZyZXNoXSBGYWlsZWQgdG8gcmVmcmVzaCBzZWN0b3I6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gcHJldmlvdXNTZWN0b3JSZWYuY3VycmVudDtcclxuICAgIH1cclxuICB9LCBbc2VjdG9ySWQsIGRldGVjdEV4ZWN1dGlvbiwgc3RhcnRGYXN0UG9sbGluZywgY2FsbGJhY2tzXSk7XHJcblxyXG4gIC8vIFJlZnJlc2ggYWdlbnRzIGRhdGFcclxuICBjb25zdCByZWZyZXNoQWdlbnRzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCFzZWN0b3JJZCkgcmV0dXJuIFtdO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGFnZW50cyA9IGF3YWl0IGZldGNoQWdlbnRzKCk7XHJcbiAgICAgIGlmIChpc1NraXBwZWRSZXN1bHQoYWdlbnRzKSB8fCAhQXJyYXkuaXNBcnJheShhZ2VudHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBzZWN0b3JBZ2VudHMgPSBhZ2VudHMuZmlsdGVyKGFnZW50ID0+IFxyXG4gICAgICAgIGFnZW50LnNlY3RvcklkICYmIGFnZW50LnNlY3RvcklkLnRvTG93ZXJDYXNlKCkgPT09IHNlY3RvcklkLnRvTG93ZXJDYXNlKClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNhbGxiYWNrcy5vbkFnZW50c1VwZGF0ZT8uKHNlY3RvckFnZW50cyk7XHJcbiAgICAgIHJldHVybiBzZWN0b3JBZ2VudHM7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdbdXNlRXhlY3V0aW9uUmVmcmVzaF0gRmFpbGVkIHRvIHJlZnJlc2ggYWdlbnRzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH0sIFtzZWN0b3JJZCwgY2FsbGJhY2tzXSk7XHJcblxyXG4gIC8vIFJlZnJlc2ggZGlzY3Vzc2lvbnMgZGF0YVxyXG4gIGNvbnN0IHJlZnJlc2hEaXNjdXNzaW9ucyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgIGlmICghc2VjdG9ySWQpIHJldHVybiBbXTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkaXNjdXNzaW9ucyA9IGF3YWl0IGZldGNoRGlzY3Vzc2lvbnMoKTtcclxuICAgICAgaWYgKGlzU2tpcHBlZFJlc3VsdChkaXNjdXNzaW9ucykgfHwgIUFycmF5LmlzQXJyYXkoZGlzY3Vzc2lvbnMpKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBzZWN0b3JEaXNjdXNzaW9ucyA9IGRpc2N1c3Npb25zLmZpbHRlcihkaXNjdXNzaW9uID0+XHJcbiAgICAgICAgZGlzY3Vzc2lvbi5zZWN0b3JJZCAmJiBcclxuICAgICAgICBkaXNjdXNzaW9uLnNlY3RvcklkLnRvTG93ZXJDYXNlKCkgPT09IHNlY3RvcklkLnRvTG93ZXJDYXNlKCkgJiZcclxuICAgICAgICBkaXNjdXNzaW9uLnN0YXR1cyAhPT0gJ2Nsb3NlZCcgJiZcclxuICAgICAgICBkaXNjdXNzaW9uLnN0YXR1cyAhPT0gJ2FyY2hpdmVkJ1xyXG4gICAgICApO1xyXG5cclxuICAgICAgY2FsbGJhY2tzLm9uRGlzY3Vzc2lvbnNVcGRhdGU/LihzZWN0b3JEaXNjdXNzaW9ucyk7XHJcbiAgICAgIHJldHVybiBzZWN0b3JEaXNjdXNzaW9ucztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1t1c2VFeGVjdXRpb25SZWZyZXNoXSBGYWlsZWQgdG8gcmVmcmVzaCBkaXNjdXNzaW9uczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9LCBbc2VjdG9ySWQsIGNhbGxiYWNrc10pO1xyXG5cclxuICAvLyBJbW1lZGlhdGUgcmVmcmVzaCBmdW5jdGlvbiAoY2FsbGVkIHdoZW4gZXhlY3V0aW9uIGlzIGRldGVjdGVkKVxyXG4gIGNvbnN0IGltbWVkaWF0ZVJlZnJlc2ggPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoIXNlY3RvcklkKSByZXR1cm47XHJcblxyXG4gICAgLy8gUmVmcmVzaCBhbGwgZGF0YSBpbW1lZGlhdGVseVxyXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICByZWZyZXNoU2VjdG9yKCksXHJcbiAgICAgIHJlZnJlc2hBZ2VudHMoKSxcclxuICAgICAgcmVmcmVzaERpc2N1c3Npb25zKCksXHJcbiAgICBdKTtcclxuICB9LCBbc2VjdG9ySWQsIHJlZnJlc2hTZWN0b3IsIHJlZnJlc2hBZ2VudHMsIHJlZnJlc2hEaXNjdXNzaW9uc10pO1xyXG5cclxuICAvLyBQb2xsaW5nIGNhbGxiYWNrIC0gdXNlcyBmYXN0IG9yIG5vcm1hbCBpbnRlcnZhbCBiYXNlZCBvbiBzdGF0ZVxyXG4gIGNvbnN0IHBvbGxDYWxsYmFjayA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgIGlmICghc2VjdG9ySWQgfHwgIWVuYWJsZWQpIHJldHVybjtcclxuXHJcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgIHJlZnJlc2hTZWN0b3IoKSxcclxuICAgICAgcmVmcmVzaEFnZW50cygpLFxyXG4gICAgICByZWZyZXNoRGlzY3Vzc2lvbnMoKSxcclxuICAgIF0pO1xyXG4gIH0sIFtzZWN0b3JJZCwgZW5hYmxlZCwgcmVmcmVzaFNlY3RvciwgcmVmcmVzaEFnZW50cywgcmVmcmVzaERpc2N1c3Npb25zXSk7XHJcblxyXG4gIC8vIFVzZSBwb2xsaW5nIHdpdGggZHluYW1pYyBpbnRlcnZhbFxyXG4gIHVzZVBvbGxpbmcoe1xyXG4gICAgY2FsbGJhY2s6IHBvbGxDYWxsYmFjayxcclxuICAgIGludGVydmFsOiBpc0Zhc3RQb2xsaW5nID8gZmFzdFBvbGxJbnRlcnZhbCA6IG5vcm1hbFBvbGxJbnRlcnZhbCxcclxuICAgIGVuYWJsZWQ6IGVuYWJsZWQgJiYgISFzZWN0b3JJZCxcclxuICAgIHBhdXNlV2hlbkhpZGRlbjogdHJ1ZSxcclxuICAgIGltbWVkaWF0ZTogZmFsc2UsXHJcbiAgICBhbGxvd0xvd2VySW50ZXJ2YWw6IHRydWUsXHJcbiAgfSk7XHJcblxyXG4gIC8vIENsZWFudXAgb24gdW5tb3VudFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjbGVhckZhc3RQb2xsVGltZW91dCgpO1xyXG4gICAgfTtcclxuICB9LCBbY2xlYXJGYXN0UG9sbFRpbWVvdXRdKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGlzRmFzdFBvbGxpbmcsXHJcbiAgICBoaWdobGlnaHRlZEZpZWxkcyxcclxuICAgIGltbWVkaWF0ZVJlZnJlc2gsXHJcbiAgICByZWZyZXNoU2VjdG9yLFxyXG4gICAgcmVmcmVzaEFnZW50cyxcclxuICAgIHJlZnJlc2hEaXNjdXNzaW9ucyxcclxuICB9O1xyXG59XHJcblxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsImZldGNoU2VjdG9yQnlJZCIsImZldGNoQWdlbnRzIiwiZmV0Y2hEaXNjdXNzaW9ucyIsImlzU2tpcHBlZFJlc3VsdCIsInVzZVBvbGxpbmciLCJ1c2VFeGVjdXRpb25SZWZyZXNoIiwic2VjdG9ySWQiLCJlbmFibGVkIiwiZmFzdFBvbGxJbnRlcnZhbCIsIm5vcm1hbFBvbGxJbnRlcnZhbCIsImNhbGxiYWNrcyIsImlzRmFzdFBvbGxpbmciLCJzZXRJc0Zhc3RQb2xsaW5nIiwiaGlnaGxpZ2h0ZWRGaWVsZHMiLCJzZXRIaWdobGlnaHRlZEZpZWxkcyIsIlNldCIsInByZXZpb3VzU2VjdG9yUmVmIiwiZmFzdFBvbGxUaW1lb3V0UmVmIiwiZXhlY3V0aW9uRGV0ZWN0ZWRSZWYiLCJwcmV2aW91c1ZhbHVlc1JlZiIsImNsZWFyRmFzdFBvbGxUaW1lb3V0IiwiY3VycmVudCIsImNsZWFyVGltZW91dCIsInN0YXJ0RmFzdFBvbGxpbmciLCJvbkV4ZWN1dGlvbkRldGVjdGVkIiwic2V0VGltZW91dCIsImRldGVjdEV4ZWN1dGlvbiIsImN1cnJlbnRTZWN0b3IiLCJwcmV2IiwiYmFsYW5jZSIsInBlcmZvcm1hbmNlIiwiYWN0aXZlQWdlbnRzIiwic3RhdHVzUGVyY2VudCIsImN1cnJlbnRQcmljZSIsImNoYW5nZSIsImNoYW5nZVBlcmNlbnQiLCJsYXN0U2ltdWxhdGVkUHJpY2UiLCJmaWVsZHNUb0NoZWNrIiwia2V5IiwiY3VyciIsInRvdGFsUEwiLCJjaGFuZ2VkRmllbGRzIiwiaGFzQ2hhbmdlcyIsInVuZGVmaW5lZCIsImFkZCIsIm5leHQiLCJmb3JFYWNoIiwiZmllbGQiLCJkZWxldGUiLCJyZWZyZXNoU2VjdG9yIiwic2VjdG9yIiwiZXhlY3V0aW9uRGV0ZWN0ZWQiLCJvblNlY3RvclVwZGF0ZSIsImVycm9yIiwiY29uc29sZSIsInJlZnJlc2hBZ2VudHMiLCJhZ2VudHMiLCJBcnJheSIsImlzQXJyYXkiLCJzZWN0b3JBZ2VudHMiLCJmaWx0ZXIiLCJhZ2VudCIsInRvTG93ZXJDYXNlIiwib25BZ2VudHNVcGRhdGUiLCJyZWZyZXNoRGlzY3Vzc2lvbnMiLCJkaXNjdXNzaW9ucyIsInNlY3RvckRpc2N1c3Npb25zIiwiZGlzY3Vzc2lvbiIsInN0YXR1cyIsIm9uRGlzY3Vzc2lvbnNVcGRhdGUiLCJpbW1lZGlhdGVSZWZyZXNoIiwiUHJvbWlzZSIsImFsbCIsInBvbGxDYWxsYmFjayIsImNhbGxiYWNrIiwiaW50ZXJ2YWwiLCJwYXVzZVdoZW5IaWRkZW4iLCJpbW1lZGlhdGUiLCJhbGxvd0xvd2VySW50ZXJ2YWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useExecutionRefresh.ts\n"));

/***/ })

});