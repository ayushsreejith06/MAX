"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/sectors/[id]/page",{

/***/ "(app-pages-browser)/./lib/stockData.ts":
/*!**************************!*\
  !*** ./lib/stockData.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchStockData: function() { return /* binding */ fetchStockData; },\n/* harmony export */   formatTimeRangeLabel: function() { return /* binding */ formatTimeRangeLabel; },\n/* harmony export */   getStockDataParams: function() { return /* binding */ getStockDataParams; }\n/* harmony export */ });\n/**\r\n * Stock Data API Utility\r\n * Fetches real stock market data using Yahoo Finance API\r\n */ /**\r\n * Generate realistic stock-like data as fallback\r\n */ function generateRealisticStockData(basePrice, range, interval) {\n    const now = new Date();\n    let numPoints = 100;\n    let minutesPerPoint = 5;\n    // Determine number of points and interval based on time range\n    switch(timeRange){\n        case \"1d\":\n            numPoints = 78; // Market hours: 6.5 hours * 12 (5-min intervals)\n            minutesPerPoint = 5;\n            break;\n        case \"1w\":\n            numPoints = 65; // 5 trading days * 13 points per day\n            minutesPerPoint = 390; // ~6.5 hours per point\n            break;\n        case \"1m\":\n            numPoints = 22; // ~22 trading days\n            minutesPerPoint = 1440; // 1 day per point\n            break;\n        case \"3m\":\n            numPoints = 66; // ~66 trading days\n            minutesPerPoint = 1440;\n            break;\n        case \"6m\":\n            numPoints = 130; // ~130 trading days\n            minutesPerPoint = 1440;\n            break;\n        case \"1y\":\n            numPoints = 252; // ~252 trading days\n            minutesPerPoint = 1440;\n            break;\n        case \"max\":\n            numPoints = 500;\n            minutesPerPoint = 1440;\n            break;\n    }\n    const dataPoints = [];\n    let currentPrice = basePrice;\n    let trend = 0; // Overall trend\n    let volatility = 0.02; // 2% volatility\n    // Add some realistic trend\n    const trendDirection = Math.random() > 0.5 ? 1 : -1;\n    const trendStrength = 0.0001 + Math.random() * 0.0005;\n    for(let i = numPoints - 1; i >= 0; i--){\n        const minutesAgo = i * minutesPerPoint;\n        const date = new Date(now.getTime() - minutesAgo * 60 * 1000);\n        // Random walk with trend\n        const randomChange = (Math.random() - 0.5) * 2 * volatility;\n        trend += trendDirection * trendStrength;\n        currentPrice = currentPrice * (1 + randomChange + trend);\n        // Ensure price doesn't go negative\n        currentPrice = Math.max(0.01, currentPrice);\n        // Format time\n        let time;\n        if (timeRange === \"1d\" || timeRange === \"1w\") {\n            const hours = date.getHours();\n            const minutes = date.getMinutes();\n            time = \"\".concat(hours.toString().padStart(2, \"0\"), \":\").concat(minutes.toString().padStart(2, \"0\"));\n        } else {\n            const month = (date.getMonth() + 1).toString().padStart(2, \"0\");\n            const day = date.getDate().toString().padStart(2, \"0\");\n            time = \"\".concat(month, \"/\").concat(day);\n        }\n        dataPoints.push({\n            time,\n            value: Number(currentPrice.toFixed(2)),\n            timestamp: date.getTime(),\n            date: date.toISOString().split(\"T\")[0]\n        });\n    }\n    return dataPoints.reverse(); // Return in chronological order\n}\n/**\r\n * Fetch stock data from Yahoo Finance API with retry logic\r\n * Uses yahoo-finance2-like endpoint (public API)\r\n */ async function fetchStockData(options) {\n    let retries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3, basePrice = arguments.length > 2 ? arguments[2] : void 0;\n    const { symbol, interval = \"1d\", range = \"1mo\" } = options;\n    // Validate symbol\n    if (!symbol || symbol.trim() === \"\" || symbol === \"N/A\") {\n        console.warn(\"Invalid symbol for stock data fetch:\", symbol);\n        // Generate realistic data if we have a base price\n        if (basePrice && basePrice > 0) {\n            return generateRealisticStockData(basePrice, range, interval);\n        }\n        return [];\n    }\n    // Clean and uppercase the symbol\n    const cleanSymbol = symbol.trim().toUpperCase();\n    for(let attempt = 0; attempt < retries; attempt++){\n        try {\n            var _data_chart_result, _data_chart, _result_indicators_quote, _result_indicators;\n            // Use Yahoo Finance API via a public proxy or direct API\n            // Using yahoo-finance2 compatible endpoint\n            const baseUrl = \"https://query1.finance.yahoo.com/v8/finance/chart\";\n            const url = \"\".concat(baseUrl, \"/\").concat(encodeURIComponent(cleanSymbol), \"?interval=\").concat(interval, \"&range=\").concat(range);\n            const controller = new AbortController();\n            const timeoutId = setTimeout(()=>controller.abort(), 8000); // 8 second timeout\n            const response = await fetch(url, {\n                headers: {\n                    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\",\n                    \"Accept\": \"application/json\"\n                },\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                throw new Error(\"Failed to fetch stock data: \".concat(response.status, \" \").concat(response.statusText));\n            }\n            const data = await response.json();\n            if (!(data === null || data === void 0 ? void 0 : (_data_chart = data.chart) === null || _data_chart === void 0 ? void 0 : (_data_chart_result = _data_chart.result) === null || _data_chart_result === void 0 ? void 0 : _data_chart_result[0])) {\n                throw new Error(\"Invalid stock data response: no chart data\");\n            }\n            const result = data.chart.result[0];\n            const timestamps = result.timestamp || [];\n            const quotes = ((_result_indicators = result.indicators) === null || _result_indicators === void 0 ? void 0 : (_result_indicators_quote = _result_indicators.quote) === null || _result_indicators_quote === void 0 ? void 0 : _result_indicators_quote[0]) || {};\n            const closes = quotes.close || [];\n            if (timestamps.length === 0 || closes.length === 0) {\n                console.warn(\"No price data available for symbol:\", cleanSymbol);\n                // Generate realistic data as fallback\n                if (basePrice && basePrice > 0) {\n                    return generateRealisticStockData(basePrice, range, interval);\n                }\n                return [];\n            }\n            // Convert to our format\n            const dataPoints = timestamps.map((timestamp, index)=>{\n                const date = new Date(timestamp * 1000);\n                const value = closes[index];\n                // Skip if value is null or undefined\n                if (value === null || value === undefined || !Number.isFinite(value)) {\n                    return null;\n                }\n                // Format time based on interval\n                let time;\n                if (interval === \"1d\" && (range === \"1d\" || range === \"5d\")) {\n                    // Intraday: show time\n                    const hours = date.getHours();\n                    const minutes = date.getMinutes();\n                    time = \"\".concat(hours.toString().padStart(2, \"0\"), \":\").concat(minutes.toString().padStart(2, \"0\"));\n                } else {\n                    // Daily/Weekly/Monthly: show date\n                    const month = (date.getMonth() + 1).toString().padStart(2, \"0\");\n                    const day = date.getDate().toString().padStart(2, \"0\");\n                    time = \"\".concat(month, \"/\").concat(day);\n                }\n                return {\n                    time,\n                    value: Number(value.toFixed(2)),\n                    timestamp: timestamp * 1000,\n                    date: date.toISOString().split(\"T\")[0]\n                };\n            }).filter((point)=>point !== null && point.value > 0);\n            if (dataPoints.length === 0) {\n                console.warn(\"No valid data points after filtering for symbol:\", cleanSymbol);\n                // Generate realistic data as fallback\n                if (basePrice && basePrice > 0) {\n                    return generateRealisticStockData(basePrice, range, interval);\n                }\n                return [];\n            }\n            return dataPoints;\n        } catch (error) {\n            const isLastAttempt = attempt === retries - 1;\n            // Handle errors\n            if (error instanceof Error) {\n                if (error.name === \"AbortError\" || error.message.includes(\"timeout\")) {\n                    console.warn(\"Stock data fetch timed out (attempt \".concat(attempt + 1, \"/\").concat(retries, \") for symbol:\"), cleanSymbol);\n                } else if (error.message.includes(\"CORS\") || error.message.includes(\"Failed to fetch\")) {\n                    console.warn(\"CORS error (attempt \".concat(attempt + 1, \"/\").concat(retries, \") for symbol:\"), cleanSymbol);\n                } else {\n                    console.error(\"Error fetching stock data (attempt \".concat(attempt + 1, \"/\").concat(retries, \") for symbol:\"), cleanSymbol, error);\n                }\n            }\n            // If this is the last attempt, generate realistic data as fallback\n            if (isLastAttempt) {\n                console.warn(\"All retry attempts failed, generating realistic stock data as fallback\");\n                if (basePrice && basePrice > 0) {\n                    return generateRealisticStockData(basePrice, range, interval);\n                }\n                return [];\n            }\n            // Wait before retrying (exponential backoff)\n            await new Promise((resolve)=>setTimeout(resolve, 1000 * (attempt + 1)));\n        }\n    }\n    return [];\n}\n/**\r\n * Get appropriate interval and range for a time period\r\n */ function getStockDataParams(timeRange1) {\n    switch(timeRange1){\n        case \"1d\":\n            return {\n                interval: \"1d\",\n                range: \"1d\"\n            };\n        case \"1w\":\n        case \"1 week\":\n            return {\n                interval: \"1d\",\n                range: \"5d\"\n            };\n        case \"1m\":\n        case \"1 month\":\n            return {\n                interval: \"1d\",\n                range: \"1mo\"\n            };\n        case \"3m\":\n        case \"3 months\":\n            return {\n                interval: \"1d\",\n                range: \"3mo\"\n            };\n        case \"6m\":\n        case \"6 months\":\n            return {\n                interval: \"1wk\",\n                range: \"6mo\"\n            };\n        case \"1y\":\n        case \"1 year\":\n            return {\n                interval: \"1wk\",\n                range: \"1y\"\n            };\n        case \"max\":\n            return {\n                interval: \"1mo\",\n                range: \"max\"\n            };\n        default:\n            return {\n                interval: \"1d\",\n                range: \"1mo\"\n            };\n    }\n}\n/**\r\n * Convert time range string to display label\r\n */ function formatTimeRangeLabel(timeRange1) {\n    switch(timeRange1){\n        case \"1d\":\n            return \"1 Day\";\n        case \"1w\":\n        case \"1 week\":\n            return \"1 Week\";\n        case \"1m\":\n        case \"1 month\":\n            return \"1 Month\";\n        case \"3m\":\n        case \"3 months\":\n            return \"3 Months\";\n        case \"6m\":\n        case \"6 months\":\n            return \"6 Months\";\n        case \"1y\":\n        case \"1 year\":\n            return \"1 Year\";\n        case \"max\":\n            return \"Max\";\n        default:\n            return timeRange1;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFPO1lBQU07UUFDeEMsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO2dCQUFFQyxVQUFVO2dCQUFPRCxPQUFPO1lBQU07UUFDekMsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO2dCQUFFQyxVQUFVO2dCQUFPRCxPQUFPO1lBQUs7UUFDeEMsS0FBSztZQUNILE9BQU87Z0JBQUVDLFVBQVU7Z0JBQU9ELE9BQU87WUFBTTtRQUN6QztZQUNFLE9BQU87Z0JBQUVDLFVBQVU7Z0JBQU1ELE9BQU87WUFBTTtJQUMxQztBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTNEYscUJBQXFCdEYsVUFBaUI7SUFDcEQsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1Q7WUFDRSxPQUFPQTtJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3N0b2NrRGF0YS50cz82OWU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBTdG9jayBEYXRhIEFQSSBVdGlsaXR5XHJcbiAqIEZldGNoZXMgcmVhbCBzdG9jayBtYXJrZXQgZGF0YSB1c2luZyBZYWhvbyBGaW5hbmNlIEFQSVxyXG4gKi9cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RvY2tEYXRhUG9pbnQge1xyXG4gIHRpbWU6IHN0cmluZzsgLy8gRm9ybWF0OiBcIkhIOk1NXCIgZm9yIGludHJhZGF5LCBcIllZWVktTU0tRERcIiBmb3IgZGFpbHlcclxuICB2YWx1ZTogbnVtYmVyO1xyXG4gIHRpbWVzdGFtcD86IG51bWJlcjsgLy8gVW5peCB0aW1lc3RhbXAgZm9yIHNvcnRpbmdcclxuICBkYXRlPzogc3RyaW5nOyAvLyBGdWxsIGRhdGUgc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RvY2tEYXRhT3B0aW9ucyB7XHJcbiAgc3ltYm9sOiBzdHJpbmc7XHJcbiAgaW50ZXJ2YWw/OiAnMWQnIHwgJzF3aycgfCAnMW1vJzsgLy8gRGFpbHksIFdlZWtseSwgTW9udGhseVxyXG4gIHJhbmdlPzogJzFkJyB8ICc1ZCcgfCAnMW1vJyB8ICczbW8nIHwgJzZtbycgfCAnMXknIHwgJzJ5JyB8ICc1eScgfCAnMTB5JyB8ICd5dGQnIHwgJ21heCc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSByZWFsaXN0aWMgc3RvY2stbGlrZSBkYXRhIGFzIGZhbGxiYWNrXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVJlYWxpc3RpY1N0b2NrRGF0YShcclxuICBiYXNlUHJpY2U6IG51bWJlcixcclxuICByYW5nZTogc3RyaW5nLFxyXG4gIGludGVydmFsOiAnMWQnIHwgJzF3aycgfCAnMW1vJ1xyXG4pOiBTdG9ja0RhdGFQb2ludFtdIHtcclxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gIGxldCBudW1Qb2ludHMgPSAxMDA7XHJcbiAgbGV0IG1pbnV0ZXNQZXJQb2ludCA9IDU7XHJcblxyXG4gIC8vIERldGVybWluZSBudW1iZXIgb2YgcG9pbnRzIGFuZCBpbnRlcnZhbCBiYXNlZCBvbiB0aW1lIHJhbmdlXHJcbiAgc3dpdGNoICh0aW1lUmFuZ2UpIHtcclxuICAgIGNhc2UgJzFkJzpcclxuICAgICAgbnVtUG9pbnRzID0gNzg7IC8vIE1hcmtldCBob3VyczogNi41IGhvdXJzICogMTIgKDUtbWluIGludGVydmFscylcclxuICAgICAgbWludXRlc1BlclBvaW50ID0gNTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICcxdyc6XHJcbiAgICAgIG51bVBvaW50cyA9IDY1OyAvLyA1IHRyYWRpbmcgZGF5cyAqIDEzIHBvaW50cyBwZXIgZGF5XHJcbiAgICAgIG1pbnV0ZXNQZXJQb2ludCA9IDM5MDsgLy8gfjYuNSBob3VycyBwZXIgcG9pbnRcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICcxbSc6XHJcbiAgICAgIG51bVBvaW50cyA9IDIyOyAvLyB+MjIgdHJhZGluZyBkYXlzXHJcbiAgICAgIG1pbnV0ZXNQZXJQb2ludCA9IDE0NDA7IC8vIDEgZGF5IHBlciBwb2ludFxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJzNtJzpcclxuICAgICAgbnVtUG9pbnRzID0gNjY7IC8vIH42NiB0cmFkaW5nIGRheXNcclxuICAgICAgbWludXRlc1BlclBvaW50ID0gMTQ0MDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICc2bSc6XHJcbiAgICAgIG51bVBvaW50cyA9IDEzMDsgLy8gfjEzMCB0cmFkaW5nIGRheXNcclxuICAgICAgbWludXRlc1BlclBvaW50ID0gMTQ0MDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICcxeSc6XHJcbiAgICAgIG51bVBvaW50cyA9IDI1MjsgLy8gfjI1MiB0cmFkaW5nIGRheXNcclxuICAgICAgbWludXRlc1BlclBvaW50ID0gMTQ0MDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdtYXgnOlxyXG4gICAgICBudW1Qb2ludHMgPSA1MDA7XHJcbiAgICAgIG1pbnV0ZXNQZXJQb2ludCA9IDE0NDA7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZGF0YVBvaW50czogU3RvY2tEYXRhUG9pbnRbXSA9IFtdO1xyXG4gIGxldCBjdXJyZW50UHJpY2UgPSBiYXNlUHJpY2U7XHJcbiAgbGV0IHRyZW5kID0gMDsgLy8gT3ZlcmFsbCB0cmVuZFxyXG4gIGxldCB2b2xhdGlsaXR5ID0gMC4wMjsgLy8gMiUgdm9sYXRpbGl0eVxyXG5cclxuICAvLyBBZGQgc29tZSByZWFsaXN0aWMgdHJlbmRcclxuICBjb25zdCB0cmVuZERpcmVjdGlvbiA9IE1hdGgucmFuZG9tKCkgPiAwLjUgPyAxIDogLTE7XHJcbiAgY29uc3QgdHJlbmRTdHJlbmd0aCA9IDAuMDAwMSArIE1hdGgucmFuZG9tKCkgKiAwLjAwMDU7XHJcblxyXG4gIGZvciAobGV0IGkgPSBudW1Qb2ludHMgLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgY29uc3QgbWludXRlc0FnbyA9IGkgKiBtaW51dGVzUGVyUG9pbnQ7XHJcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUobm93LmdldFRpbWUoKSAtIG1pbnV0ZXNBZ28gKiA2MCAqIDEwMDApO1xyXG5cclxuICAgIC8vIFJhbmRvbSB3YWxrIHdpdGggdHJlbmRcclxuICAgIGNvbnN0IHJhbmRvbUNoYW5nZSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIgKiB2b2xhdGlsaXR5O1xyXG4gICAgdHJlbmQgKz0gdHJlbmREaXJlY3Rpb24gKiB0cmVuZFN0cmVuZ3RoO1xyXG4gICAgY3VycmVudFByaWNlID0gY3VycmVudFByaWNlICogKDEgKyByYW5kb21DaGFuZ2UgKyB0cmVuZCk7XHJcblxyXG4gICAgLy8gRW5zdXJlIHByaWNlIGRvZXNuJ3QgZ28gbmVnYXRpdmVcclxuICAgIGN1cnJlbnRQcmljZSA9IE1hdGgubWF4KDAuMDEsIGN1cnJlbnRQcmljZSk7XHJcblxyXG4gICAgLy8gRm9ybWF0IHRpbWVcclxuICAgIGxldCB0aW1lOiBzdHJpbmc7XHJcbiAgICBpZiAodGltZVJhbmdlID09PSAnMWQnIHx8IHRpbWVSYW5nZSA9PT0gJzF3Jykge1xyXG4gICAgICBjb25zdCBob3VycyA9IGRhdGUuZ2V0SG91cnMoKTtcclxuICAgICAgY29uc3QgbWludXRlcyA9IGRhdGUuZ2V0TWludXRlcygpO1xyXG4gICAgICB0aW1lID0gYCR7aG91cnMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke21pbnV0ZXMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBtb250aCA9IChkYXRlLmdldE1vbnRoKCkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7XHJcbiAgICAgIGNvbnN0IGRheSA9IGRhdGUuZ2V0RGF0ZSgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcclxuICAgICAgdGltZSA9IGAke21vbnRofS8ke2RheX1gO1xyXG4gICAgfVxyXG5cclxuICAgIGRhdGFQb2ludHMucHVzaCh7XHJcbiAgICAgIHRpbWUsXHJcbiAgICAgIHZhbHVlOiBOdW1iZXIoY3VycmVudFByaWNlLnRvRml4ZWQoMikpLFxyXG4gICAgICB0aW1lc3RhbXA6IGRhdGUuZ2V0VGltZSgpLFxyXG4gICAgICBkYXRlOiBkYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRhdGFQb2ludHMucmV2ZXJzZSgpOyAvLyBSZXR1cm4gaW4gY2hyb25vbG9naWNhbCBvcmRlclxyXG59XHJcblxyXG4vKipcclxuICogRmV0Y2ggc3RvY2sgZGF0YSBmcm9tIFlhaG9vIEZpbmFuY2UgQVBJIHdpdGggcmV0cnkgbG9naWNcclxuICogVXNlcyB5YWhvby1maW5hbmNlMi1saWtlIGVuZHBvaW50IChwdWJsaWMgQVBJKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoU3RvY2tEYXRhKFxyXG4gIG9wdGlvbnM6IFN0b2NrRGF0YU9wdGlvbnMsXHJcbiAgcmV0cmllcyA9IDMsXHJcbiAgYmFzZVByaWNlPzogbnVtYmVyXHJcbik6IFByb21pc2U8U3RvY2tEYXRhUG9pbnRbXT4ge1xyXG4gIGNvbnN0IHsgc3ltYm9sLCBpbnRlcnZhbCA9ICcxZCcsIHJhbmdlID0gJzFtbycgfSA9IG9wdGlvbnM7XHJcblxyXG4gIC8vIFZhbGlkYXRlIHN5bWJvbFxyXG4gIGlmICghc3ltYm9sIHx8IHN5bWJvbC50cmltKCkgPT09ICcnIHx8IHN5bWJvbCA9PT0gJ04vQScpIHtcclxuICAgIGNvbnNvbGUud2FybignSW52YWxpZCBzeW1ib2wgZm9yIHN0b2NrIGRhdGEgZmV0Y2g6Jywgc3ltYm9sKTtcclxuICAgIC8vIEdlbmVyYXRlIHJlYWxpc3RpYyBkYXRhIGlmIHdlIGhhdmUgYSBiYXNlIHByaWNlXHJcbiAgICBpZiAoYmFzZVByaWNlICYmIGJhc2VQcmljZSA+IDApIHtcclxuICAgICAgcmV0dXJuIGdlbmVyYXRlUmVhbGlzdGljU3RvY2tEYXRhKGJhc2VQcmljZSwgcmFuZ2UsIGludGVydmFsKTtcclxuICAgIH1cclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIC8vIENsZWFuIGFuZCB1cHBlcmNhc2UgdGhlIHN5bWJvbFxyXG4gIGNvbnN0IGNsZWFuU3ltYm9sID0gc3ltYm9sLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xyXG5cclxuICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IHJldHJpZXM7IGF0dGVtcHQrKykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVXNlIFlhaG9vIEZpbmFuY2UgQVBJIHZpYSBhIHB1YmxpYyBwcm94eSBvciBkaXJlY3QgQVBJXHJcbiAgICAgIC8vIFVzaW5nIHlhaG9vLWZpbmFuY2UyIGNvbXBhdGlibGUgZW5kcG9pbnRcclxuICAgICAgY29uc3QgYmFzZVVybCA9ICdodHRwczovL3F1ZXJ5MS5maW5hbmNlLnlhaG9vLmNvbS92OC9maW5hbmNlL2NoYXJ0JztcclxuICAgICAgY29uc3QgdXJsID0gYCR7YmFzZVVybH0vJHtlbmNvZGVVUklDb21wb25lbnQoY2xlYW5TeW1ib2wpfT9pbnRlcnZhbD0ke2ludGVydmFsfSZyYW5nZT0ke3JhbmdlfWA7XHJcblxyXG4gICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgODAwMCk7IC8vIDggc2Vjb25kIHRpbWVvdXRcclxuXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ1VzZXItQWdlbnQnOiAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2JyxcclxuICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHN0b2NrIGRhdGE6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBpZiAoIWRhdGE/LmNoYXJ0Py5yZXN1bHQ/LlswXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdG9jayBkYXRhIHJlc3BvbnNlOiBubyBjaGFydCBkYXRhJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGRhdGEuY2hhcnQucmVzdWx0WzBdO1xyXG4gICAgICBjb25zdCB0aW1lc3RhbXBzID0gcmVzdWx0LnRpbWVzdGFtcCB8fCBbXTtcclxuICAgICAgY29uc3QgcXVvdGVzID0gcmVzdWx0LmluZGljYXRvcnM/LnF1b3RlPy5bMF0gfHwge307XHJcbiAgICAgIGNvbnN0IGNsb3NlcyA9IHF1b3Rlcy5jbG9zZSB8fCBbXTtcclxuXHJcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMCB8fCBjbG9zZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdObyBwcmljZSBkYXRhIGF2YWlsYWJsZSBmb3Igc3ltYm9sOicsIGNsZWFuU3ltYm9sKTtcclxuICAgICAgICAvLyBHZW5lcmF0ZSByZWFsaXN0aWMgZGF0YSBhcyBmYWxsYmFja1xyXG4gICAgICAgIGlmIChiYXNlUHJpY2UgJiYgYmFzZVByaWNlID4gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIGdlbmVyYXRlUmVhbGlzdGljU3RvY2tEYXRhKGJhc2VQcmljZSwgcmFuZ2UsIGludGVydmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IHRvIG91ciBmb3JtYXRcclxuICAgICAgY29uc3QgZGF0YVBvaW50czogU3RvY2tEYXRhUG9pbnRbXSA9IHRpbWVzdGFtcHNcclxuICAgICAgICAubWFwKCh0aW1lc3RhbXA6IG51bWJlciwgaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRpbWVzdGFtcCAqIDEwMDApO1xyXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBjbG9zZXNbaW5kZXhdO1xyXG5cclxuICAgICAgICAgIC8vIFNraXAgaWYgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWRcclxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEZvcm1hdCB0aW1lIGJhc2VkIG9uIGludGVydmFsXHJcbiAgICAgICAgICBsZXQgdGltZTogc3RyaW5nO1xyXG4gICAgICAgICAgaWYgKGludGVydmFsID09PSAnMWQnICYmIChyYW5nZSA9PT0gJzFkJyB8fCByYW5nZSA9PT0gJzVkJykpIHtcclxuICAgICAgICAgICAgLy8gSW50cmFkYXk6IHNob3cgdGltZVxyXG4gICAgICAgICAgICBjb25zdCBob3VycyA9IGRhdGUuZ2V0SG91cnMoKTtcclxuICAgICAgICAgICAgY29uc3QgbWludXRlcyA9IGRhdGUuZ2V0TWludXRlcygpO1xyXG4gICAgICAgICAgICB0aW1lID0gYCR7aG91cnMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke21pbnV0ZXMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEYWlseS9XZWVrbHkvTW9udGhseTogc2hvdyBkYXRlXHJcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoID0gKGRhdGUuZ2V0TW9udGgoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcclxuICAgICAgICAgICAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXRlKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xyXG4gICAgICAgICAgICB0aW1lID0gYCR7bW9udGh9LyR7ZGF5fWA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGltZSxcclxuICAgICAgICAgICAgdmFsdWU6IE51bWJlcih2YWx1ZS50b0ZpeGVkKDIpKSxcclxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAgKiAxMDAwLFxyXG4gICAgICAgICAgICBkYXRlOiBkYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuZmlsdGVyKChwb2ludDogU3RvY2tEYXRhUG9pbnQgfCBudWxsKTogcG9pbnQgaXMgU3RvY2tEYXRhUG9pbnQgPT4gcG9pbnQgIT09IG51bGwgJiYgcG9pbnQudmFsdWUgPiAwKTtcclxuXHJcbiAgICAgIGlmIChkYXRhUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignTm8gdmFsaWQgZGF0YSBwb2ludHMgYWZ0ZXIgZmlsdGVyaW5nIGZvciBzeW1ib2w6JywgY2xlYW5TeW1ib2wpO1xyXG4gICAgICAgIC8vIEdlbmVyYXRlIHJlYWxpc3RpYyBkYXRhIGFzIGZhbGxiYWNrXHJcbiAgICAgICAgaWYgKGJhc2VQcmljZSAmJiBiYXNlUHJpY2UgPiAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVSZWFsaXN0aWNTdG9ja0RhdGEoYmFzZVByaWNlLCByYW5nZSwgaW50ZXJ2YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBkYXRhUG9pbnRzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc3QgaXNMYXN0QXR0ZW1wdCA9IGF0dGVtcHQgPT09IHJldHJpZXMgLSAxO1xyXG5cclxuICAgICAgLy8gSGFuZGxlIGVycm9yc1xyXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicgfHwgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygndGltZW91dCcpKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFN0b2NrIGRhdGEgZmV0Y2ggdGltZWQgb3V0IChhdHRlbXB0ICR7YXR0ZW1wdCArIDF9LyR7cmV0cmllc30pIGZvciBzeW1ib2w6YCwgY2xlYW5TeW1ib2wpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnQ09SUycpIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0ZhaWxlZCB0byBmZXRjaCcpKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENPUlMgZXJyb3IgKGF0dGVtcHQgJHthdHRlbXB0ICsgMX0vJHtyZXRyaWVzfSkgZm9yIHN5bWJvbDpgLCBjbGVhblN5bWJvbCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHN0b2NrIGRhdGEgKGF0dGVtcHQgJHthdHRlbXB0ICsgMX0vJHtyZXRyaWVzfSkgZm9yIHN5bWJvbDpgLCBjbGVhblN5bWJvbCwgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgbGFzdCBhdHRlbXB0LCBnZW5lcmF0ZSByZWFsaXN0aWMgZGF0YSBhcyBmYWxsYmFja1xyXG4gICAgICBpZiAoaXNMYXN0QXR0ZW1wdCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignQWxsIHJldHJ5IGF0dGVtcHRzIGZhaWxlZCwgZ2VuZXJhdGluZyByZWFsaXN0aWMgc3RvY2sgZGF0YSBhcyBmYWxsYmFjaycpO1xyXG4gICAgICAgIGlmIChiYXNlUHJpY2UgJiYgYmFzZVByaWNlID4gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIGdlbmVyYXRlUmVhbGlzdGljU3RvY2tEYXRhKGJhc2VQcmljZSwgcmFuZ2UsIGludGVydmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBXYWl0IGJlZm9yZSByZXRyeWluZyAoZXhwb25lbnRpYWwgYmFja29mZilcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDAgKiAoYXR0ZW1wdCArIDEpKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYXBwcm9wcmlhdGUgaW50ZXJ2YWwgYW5kIHJhbmdlIGZvciBhIHRpbWUgcGVyaW9kXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvY2tEYXRhUGFyYW1zKHRpbWVSYW5nZTogc3RyaW5nKTogeyBpbnRlcnZhbDogJzFkJyB8ICcxd2snIHwgJzFtbyc7IHJhbmdlOiBzdHJpbmcgfSB7XHJcbiAgc3dpdGNoICh0aW1lUmFuZ2UpIHtcclxuICAgIGNhc2UgJzFkJzpcclxuICAgICAgcmV0dXJuIHsgaW50ZXJ2YWw6ICcxZCcsIHJhbmdlOiAnMWQnIH07XHJcbiAgICBjYXNlICcxdyc6XHJcbiAgICBjYXNlICcxIHdlZWsnOlxyXG4gICAgICByZXR1cm4geyBpbnRlcnZhbDogJzFkJywgcmFuZ2U6ICc1ZCcgfTtcclxuICAgIGNhc2UgJzFtJzpcclxuICAgIGNhc2UgJzEgbW9udGgnOlxyXG4gICAgICByZXR1cm4geyBpbnRlcnZhbDogJzFkJywgcmFuZ2U6ICcxbW8nIH07XHJcbiAgICBjYXNlICczbSc6XHJcbiAgICBjYXNlICczIG1vbnRocyc6XHJcbiAgICAgIHJldHVybiB7IGludGVydmFsOiAnMWQnLCByYW5nZTogJzNtbycgfTtcclxuICAgIGNhc2UgJzZtJzpcclxuICAgIGNhc2UgJzYgbW9udGhzJzpcclxuICAgICAgcmV0dXJuIHsgaW50ZXJ2YWw6ICcxd2snLCByYW5nZTogJzZtbycgfTtcclxuICAgIGNhc2UgJzF5JzpcclxuICAgIGNhc2UgJzEgeWVhcic6XHJcbiAgICAgIHJldHVybiB7IGludGVydmFsOiAnMXdrJywgcmFuZ2U6ICcxeScgfTtcclxuICAgIGNhc2UgJ21heCc6XHJcbiAgICAgIHJldHVybiB7IGludGVydmFsOiAnMW1vJywgcmFuZ2U6ICdtYXgnIH07XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4geyBpbnRlcnZhbDogJzFkJywgcmFuZ2U6ICcxbW8nIH07XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCB0aW1lIHJhbmdlIHN0cmluZyB0byBkaXNwbGF5IGxhYmVsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VGltZVJhbmdlTGFiZWwodGltZVJhbmdlOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIHN3aXRjaCAodGltZVJhbmdlKSB7XHJcbiAgICBjYXNlICcxZCc6XHJcbiAgICAgIHJldHVybiAnMSBEYXknO1xyXG4gICAgY2FzZSAnMXcnOlxyXG4gICAgY2FzZSAnMSB3ZWVrJzpcclxuICAgICAgcmV0dXJuICcxIFdlZWsnO1xyXG4gICAgY2FzZSAnMW0nOlxyXG4gICAgY2FzZSAnMSBtb250aCc6XHJcbiAgICAgIHJldHVybiAnMSBNb250aCc7XHJcbiAgICBjYXNlICczbSc6XHJcbiAgICBjYXNlICczIG1vbnRocyc6XHJcbiAgICAgIHJldHVybiAnMyBNb250aHMnO1xyXG4gICAgY2FzZSAnNm0nOlxyXG4gICAgY2FzZSAnNiBtb250aHMnOlxyXG4gICAgICByZXR1cm4gJzYgTW9udGhzJztcclxuICAgIGNhc2UgJzF5JzpcclxuICAgIGNhc2UgJzEgeWVhcic6XHJcbiAgICAgIHJldHVybiAnMSBZZWFyJztcclxuICAgIGNhc2UgJ21heCc6XHJcbiAgICAgIHJldHVybiAnTWF4JztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiB0aW1lUmFuZ2U7XHJcbiAgfVxyXG59XHJcblxyXG4iXSwibmFtZXMiOlsiZ2VuZXJhdGVSZWFsaXN0aWNTdG9ja0RhdGEiLCJiYXNlUHJpY2UiLCJyYW5nZSIsImludGVydmFsIiwibm93IiwiRGF0ZSIsIm51bVBvaW50cyIsIm1pbnV0ZXNQZXJQb2ludCIsInRpbWVSYW5nZSIsImRhdGFQb2ludHMiLCJjdXJyZW50UHJpY2UiLCJ0cmVuZCIsInZvbGF0aWxpdHkiLCJ0cmVuZERpcmVjdGlvbiIsIk1hdGgiLCJyYW5kb20iLCJ0cmVuZFN0cmVuZ3RoIiwiaSIsIm1pbnV0ZXNBZ28iLCJkYXRlIiwiZ2V0VGltZSIsInJhbmRvbUNoYW5nZSIsIm1heCIsInRpbWUiLCJob3VycyIsImdldEhvdXJzIiwibWludXRlcyIsImdldE1pbnV0ZXMiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwibW9udGgiLCJnZXRNb250aCIsImRheSIsImdldERhdGUiLCJwdXNoIiwidmFsdWUiLCJOdW1iZXIiLCJ0b0ZpeGVkIiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJzcGxpdCIsInJldmVyc2UiLCJmZXRjaFN0b2NrRGF0YSIsIm9wdGlvbnMiLCJyZXRyaWVzIiwic3ltYm9sIiwidHJpbSIsImNvbnNvbGUiLCJ3YXJuIiwiY2xlYW5TeW1ib2wiLCJ0b1VwcGVyQ2FzZSIsImF0dGVtcHQiLCJkYXRhIiwicmVzdWx0IiwiYmFzZVVybCIsInVybCIsImVuY29kZVVSSUNvbXBvbmVudCIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsInNpZ25hbCIsImNsZWFyVGltZW91dCIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwianNvbiIsImNoYXJ0IiwidGltZXN0YW1wcyIsInF1b3RlcyIsImluZGljYXRvcnMiLCJxdW90ZSIsImNsb3NlcyIsImNsb3NlIiwibGVuZ3RoIiwibWFwIiwiaW5kZXgiLCJ1bmRlZmluZWQiLCJpc0Zpbml0ZSIsImZpbHRlciIsInBvaW50IiwiZXJyb3IiLCJpc0xhc3RBdHRlbXB0IiwibmFtZSIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsIlByb21pc2UiLCJyZXNvbHZlIiwiZ2V0U3RvY2tEYXRhUGFyYW1zIiwiZm9ybWF0VGltZVJhbmdlTGFiZWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/stockData.ts\n"));

/***/ })

});