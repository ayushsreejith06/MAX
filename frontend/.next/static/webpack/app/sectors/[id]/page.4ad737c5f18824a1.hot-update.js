"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/sectors/[id]/page",{

/***/ "(app-pages-browser)/./lib/stockData.ts":
/*!**************************!*\
  !*** ./lib/stockData.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchStockData: function() { return /* binding */ fetchStockData; },\n/* harmony export */   formatTimeRangeLabel: function() { return /* binding */ formatTimeRangeLabel; },\n/* harmony export */   getStockDataParams: function() { return /* binding */ getStockDataParams; }\n/* harmony export */ });\n/**\r\n * Stock Data API Utility\r\n * Fetches real stock market data using Yahoo Finance API\r\n */ /**\r\n * Generate realistic stock-like data as fallback\r\n */ function generateRealisticStockData(basePrice, range, interval) {\n    const now = new Date();\n    let numPoints = 100;\n    let minutesPerPoint = 5;\n    // Determine number of points and interval based on time range\n    switch(range){\n        case \"1d\":\n            numPoints = 78; // Market hours: 6.5 hours * 12 (5-min intervals)\n            minutesPerPoint = 5;\n            break;\n        case \"5d\":\n        case \"1w\":\n            numPoints = 65; // 5 trading days * 13 points per day\n            minutesPerPoint = 390; // ~6.5 hours per point\n            break;\n        case \"1mo\":\n        case \"1m\":\n            numPoints = 22; // ~22 trading days\n            minutesPerPoint = 1440; // 1 day per point\n            break;\n        case \"3mo\":\n        case \"3m\":\n            numPoints = 66; // ~66 trading days\n            minutesPerPoint = 1440;\n            break;\n        case \"6mo\":\n        case \"6m\":\n            numPoints = 130; // ~130 trading days\n            minutesPerPoint = 1440;\n            break;\n        case \"1y\":\n            numPoints = 252; // ~252 trading days\n            minutesPerPoint = 1440;\n            break;\n        case \"max\":\n            numPoints = 500;\n            minutesPerPoint = 1440;\n            break;\n        default:\n            numPoints = 100;\n            minutesPerPoint = 1440;\n    }\n    const dataPoints = [];\n    let currentPrice = basePrice;\n    let trend = 0; // Overall trend\n    let volatility = 0.02; // 2% volatility\n    // Add some realistic trend\n    const trendDirection = Math.random() > 0.5 ? 1 : -1;\n    const trendStrength = 0.0001 + Math.random() * 0.0005;\n    for(let i = numPoints - 1; i >= 0; i--){\n        const minutesAgo = i * minutesPerPoint;\n        const date = new Date(now.getTime() - minutesAgo * 60 * 1000);\n        // Random walk with trend\n        const randomChange = (Math.random() - 0.5) * 2 * volatility;\n        trend += trendDirection * trendStrength;\n        currentPrice = currentPrice * (1 + randomChange + trend);\n        // Ensure price doesn't go negative\n        currentPrice = Math.max(0.01, currentPrice);\n        // Format time\n        let time;\n        if (timeRange === \"1d\" || timeRange === \"1w\") {\n            const hours = date.getHours();\n            const minutes = date.getMinutes();\n            time = \"\".concat(hours.toString().padStart(2, \"0\"), \":\").concat(minutes.toString().padStart(2, \"0\"));\n        } else {\n            const month = (date.getMonth() + 1).toString().padStart(2, \"0\");\n            const day = date.getDate().toString().padStart(2, \"0\");\n            time = \"\".concat(month, \"/\").concat(day);\n        }\n        dataPoints.push({\n            time,\n            value: Number(currentPrice.toFixed(2)),\n            timestamp: date.getTime(),\n            date: date.toISOString().split(\"T\")[0]\n        });\n    }\n    return dataPoints.reverse(); // Return in chronological order\n}\n/**\r\n * Fetch stock data from Yahoo Finance API with retry logic\r\n * Uses yahoo-finance2-like endpoint (public API)\r\n */ async function fetchStockData(options) {\n    let retries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3, basePrice = arguments.length > 2 ? arguments[2] : void 0;\n    const { symbol, interval = \"1d\", range = \"1mo\" } = options;\n    // Validate symbol\n    if (!symbol || symbol.trim() === \"\" || symbol === \"N/A\") {\n        console.warn(\"Invalid symbol for stock data fetch:\", symbol);\n        // Generate realistic data if we have a base price\n        if (basePrice && basePrice > 0) {\n            return generateRealisticStockData(basePrice, range, interval);\n        }\n        return [];\n    }\n    // Clean and uppercase the symbol\n    const cleanSymbol = symbol.trim().toUpperCase();\n    for(let attempt = 0; attempt < retries; attempt++){\n        try {\n            var _data_chart_result, _data_chart, _result_indicators_quote, _result_indicators;\n            // Use Yahoo Finance API via a public proxy or direct API\n            // Using yahoo-finance2 compatible endpoint\n            const baseUrl = \"https://query1.finance.yahoo.com/v8/finance/chart\";\n            const url = \"\".concat(baseUrl, \"/\").concat(encodeURIComponent(cleanSymbol), \"?interval=\").concat(interval, \"&range=\").concat(range);\n            const controller = new AbortController();\n            const timeoutId = setTimeout(()=>controller.abort(), 8000); // 8 second timeout\n            const response = await fetch(url, {\n                headers: {\n                    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\",\n                    \"Accept\": \"application/json\"\n                },\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                throw new Error(\"Failed to fetch stock data: \".concat(response.status, \" \").concat(response.statusText));\n            }\n            const data = await response.json();\n            if (!(data === null || data === void 0 ? void 0 : (_data_chart = data.chart) === null || _data_chart === void 0 ? void 0 : (_data_chart_result = _data_chart.result) === null || _data_chart_result === void 0 ? void 0 : _data_chart_result[0])) {\n                throw new Error(\"Invalid stock data response: no chart data\");\n            }\n            const result = data.chart.result[0];\n            const timestamps = result.timestamp || [];\n            const quotes = ((_result_indicators = result.indicators) === null || _result_indicators === void 0 ? void 0 : (_result_indicators_quote = _result_indicators.quote) === null || _result_indicators_quote === void 0 ? void 0 : _result_indicators_quote[0]) || {};\n            const closes = quotes.close || [];\n            if (timestamps.length === 0 || closes.length === 0) {\n                console.warn(\"No price data available for symbol:\", cleanSymbol);\n                // Generate realistic data as fallback\n                if (basePrice && basePrice > 0) {\n                    return generateRealisticStockData(basePrice, range, interval);\n                }\n                return [];\n            }\n            // Convert to our format\n            const dataPoints = timestamps.map((timestamp, index)=>{\n                const date = new Date(timestamp * 1000);\n                const value = closes[index];\n                // Skip if value is null or undefined\n                if (value === null || value === undefined || !Number.isFinite(value)) {\n                    return null;\n                }\n                // Format time based on interval\n                let time;\n                if (interval === \"1d\" && (range === \"1d\" || range === \"5d\")) {\n                    // Intraday: show time\n                    const hours = date.getHours();\n                    const minutes = date.getMinutes();\n                    time = \"\".concat(hours.toString().padStart(2, \"0\"), \":\").concat(minutes.toString().padStart(2, \"0\"));\n                } else {\n                    // Daily/Weekly/Monthly: show date\n                    const month = (date.getMonth() + 1).toString().padStart(2, \"0\");\n                    const day = date.getDate().toString().padStart(2, \"0\");\n                    time = \"\".concat(month, \"/\").concat(day);\n                }\n                return {\n                    time,\n                    value: Number(value.toFixed(2)),\n                    timestamp: timestamp * 1000,\n                    date: date.toISOString().split(\"T\")[0]\n                };\n            }).filter((point)=>point !== null && point.value > 0);\n            if (dataPoints.length === 0) {\n                console.warn(\"No valid data points after filtering for symbol:\", cleanSymbol);\n                // Generate realistic data as fallback\n                if (basePrice && basePrice > 0) {\n                    return generateRealisticStockData(basePrice, range, interval);\n                }\n                return [];\n            }\n            return dataPoints;\n        } catch (error) {\n            const isLastAttempt = attempt === retries - 1;\n            // Handle errors\n            if (error instanceof Error) {\n                if (error.name === \"AbortError\" || error.message.includes(\"timeout\")) {\n                    console.warn(\"Stock data fetch timed out (attempt \".concat(attempt + 1, \"/\").concat(retries, \") for symbol:\"), cleanSymbol);\n                } else if (error.message.includes(\"CORS\") || error.message.includes(\"Failed to fetch\")) {\n                    console.warn(\"CORS error (attempt \".concat(attempt + 1, \"/\").concat(retries, \") for symbol:\"), cleanSymbol);\n                } else {\n                    console.error(\"Error fetching stock data (attempt \".concat(attempt + 1, \"/\").concat(retries, \") for symbol:\"), cleanSymbol, error);\n                }\n            }\n            // If this is the last attempt, generate realistic data as fallback\n            if (isLastAttempt) {\n                console.warn(\"All retry attempts failed, generating realistic stock data as fallback\");\n                if (basePrice && basePrice > 0) {\n                    return generateRealisticStockData(basePrice, range, interval);\n                }\n                return [];\n            }\n            // Wait before retrying (exponential backoff)\n            await new Promise((resolve)=>setTimeout(resolve, 1000 * (attempt + 1)));\n        }\n    }\n    return [];\n}\n/**\r\n * Get appropriate interval and range for a time period\r\n */ function getStockDataParams(timeRange1) {\n    switch(timeRange1){\n        case \"1d\":\n            return {\n                interval: \"1d\",\n                range: \"1d\"\n            };\n        case \"1w\":\n        case \"1 week\":\n            return {\n                interval: \"1d\",\n                range: \"5d\"\n            };\n        case \"1m\":\n        case \"1 month\":\n            return {\n                interval: \"1d\",\n                range: \"1mo\"\n            };\n        case \"3m\":\n        case \"3 months\":\n            return {\n                interval: \"1d\",\n                range: \"3mo\"\n            };\n        case \"6m\":\n        case \"6 months\":\n            return {\n                interval: \"1wk\",\n                range: \"6mo\"\n            };\n        case \"1y\":\n        case \"1 year\":\n            return {\n                interval: \"1wk\",\n                range: \"1y\"\n            };\n        case \"max\":\n            return {\n                interval: \"1mo\",\n                range: \"max\"\n            };\n        default:\n            return {\n                interval: \"1d\",\n                range: \"1mo\"\n            };\n    }\n}\n/**\r\n * Convert time range string to display label\r\n */ function formatTimeRangeLabel(timeRange1) {\n    switch(timeRange1){\n        case \"1d\":\n            return \"1 Day\";\n        case \"1w\":\n        case \"1 week\":\n            return \"1 Week\";\n        case \"1m\":\n        case \"1 month\":\n            return \"1 Month\";\n        case \"3m\":\n        case \"3 months\":\n            return \"3 Months\";\n        case \"6m\":\n        case \"6 months\":\n            return \"6 Months\";\n        case \"1y\":\n        case \"1 year\":\n            return \"1 Year\";\n        case \"max\":\n            return \"Max\";\n        default:\n            return timeRange1;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O2dCQUFNRCxPQUFPO1lBQU07UUFDeEMsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO2dCQUFFQyxVQUFVO2dCQUFNRCxPQUFPO1lBQU07UUFDeEMsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO2dCQUFFQyxVQUFVO2dCQUFPRCxPQUFPO1lBQU07UUFDekMsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO2dCQUFFQyxVQUFVO2dCQUFPRCxPQUFPO1lBQUs7UUFDeEMsS0FBSztZQUNILE9BQU87Z0JBQUVDLFVBQVU7Z0JBQU9ELE9BQU87WUFBTTtRQUN6QztZQUNFLE9BQU87Z0JBQUVDLFVBQVU7Z0JBQU1ELE9BQU87WUFBTTtJQUMxQztBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTNEYscUJBQXFCdkUsVUFBaUI7SUFDcEQsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1Q7WUFDRSxPQUFPQTtJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3N0b2NrRGF0YS50cz82OWU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBTdG9jayBEYXRhIEFQSSBVdGlsaXR5XHJcbiAqIEZldGNoZXMgcmVhbCBzdG9jayBtYXJrZXQgZGF0YSB1c2luZyBZYWhvbyBGaW5hbmNlIEFQSVxyXG4gKi9cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RvY2tEYXRhUG9pbnQge1xyXG4gIHRpbWU6IHN0cmluZzsgLy8gRm9ybWF0OiBcIkhIOk1NXCIgZm9yIGludHJhZGF5LCBcIllZWVktTU0tRERcIiBmb3IgZGFpbHlcclxuICB2YWx1ZTogbnVtYmVyO1xyXG4gIHRpbWVzdGFtcD86IG51bWJlcjsgLy8gVW5peCB0aW1lc3RhbXAgZm9yIHNvcnRpbmdcclxuICBkYXRlPzogc3RyaW5nOyAvLyBGdWxsIGRhdGUgc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RvY2tEYXRhT3B0aW9ucyB7XHJcbiAgc3ltYm9sOiBzdHJpbmc7XHJcbiAgaW50ZXJ2YWw/OiAnMWQnIHwgJzF3aycgfCAnMW1vJzsgLy8gRGFpbHksIFdlZWtseSwgTW9udGhseVxyXG4gIHJhbmdlPzogJzFkJyB8ICc1ZCcgfCAnMW1vJyB8ICczbW8nIHwgJzZtbycgfCAnMXknIHwgJzJ5JyB8ICc1eScgfCAnMTB5JyB8ICd5dGQnIHwgJ21heCc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSByZWFsaXN0aWMgc3RvY2stbGlrZSBkYXRhIGFzIGZhbGxiYWNrXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVJlYWxpc3RpY1N0b2NrRGF0YShcclxuICBiYXNlUHJpY2U6IG51bWJlcixcclxuICByYW5nZTogc3RyaW5nLFxyXG4gIGludGVydmFsOiAnMWQnIHwgJzF3aycgfCAnMW1vJ1xyXG4pOiBTdG9ja0RhdGFQb2ludFtdIHtcclxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gIGxldCBudW1Qb2ludHMgPSAxMDA7XHJcbiAgbGV0IG1pbnV0ZXNQZXJQb2ludCA9IDU7XHJcblxyXG4gIC8vIERldGVybWluZSBudW1iZXIgb2YgcG9pbnRzIGFuZCBpbnRlcnZhbCBiYXNlZCBvbiB0aW1lIHJhbmdlXHJcbiAgc3dpdGNoIChyYW5nZSkge1xyXG4gICAgY2FzZSAnMWQnOlxyXG4gICAgICBudW1Qb2ludHMgPSA3ODsgLy8gTWFya2V0IGhvdXJzOiA2LjUgaG91cnMgKiAxMiAoNS1taW4gaW50ZXJ2YWxzKVxyXG4gICAgICBtaW51dGVzUGVyUG9pbnQgPSA1O1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJzVkJzpcclxuICAgIGNhc2UgJzF3JzpcclxuICAgICAgbnVtUG9pbnRzID0gNjU7IC8vIDUgdHJhZGluZyBkYXlzICogMTMgcG9pbnRzIHBlciBkYXlcclxuICAgICAgbWludXRlc1BlclBvaW50ID0gMzkwOyAvLyB+Ni41IGhvdXJzIHBlciBwb2ludFxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJzFtbyc6XHJcbiAgICBjYXNlICcxbSc6XHJcbiAgICAgIG51bVBvaW50cyA9IDIyOyAvLyB+MjIgdHJhZGluZyBkYXlzXHJcbiAgICAgIG1pbnV0ZXNQZXJQb2ludCA9IDE0NDA7IC8vIDEgZGF5IHBlciBwb2ludFxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJzNtbyc6XHJcbiAgICBjYXNlICczbSc6XHJcbiAgICAgIG51bVBvaW50cyA9IDY2OyAvLyB+NjYgdHJhZGluZyBkYXlzXHJcbiAgICAgIG1pbnV0ZXNQZXJQb2ludCA9IDE0NDA7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnNm1vJzpcclxuICAgIGNhc2UgJzZtJzpcclxuICAgICAgbnVtUG9pbnRzID0gMTMwOyAvLyB+MTMwIHRyYWRpbmcgZGF5c1xyXG4gICAgICBtaW51dGVzUGVyUG9pbnQgPSAxNDQwO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJzF5JzpcclxuICAgICAgbnVtUG9pbnRzID0gMjUyOyAvLyB+MjUyIHRyYWRpbmcgZGF5c1xyXG4gICAgICBtaW51dGVzUGVyUG9pbnQgPSAxNDQwO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ21heCc6XHJcbiAgICAgIG51bVBvaW50cyA9IDUwMDtcclxuICAgICAgbWludXRlc1BlclBvaW50ID0gMTQ0MDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBudW1Qb2ludHMgPSAxMDA7XHJcbiAgICAgIG1pbnV0ZXNQZXJQb2ludCA9IDE0NDA7XHJcbiAgfVxyXG5cclxuICBjb25zdCBkYXRhUG9pbnRzOiBTdG9ja0RhdGFQb2ludFtdID0gW107XHJcbiAgbGV0IGN1cnJlbnRQcmljZSA9IGJhc2VQcmljZTtcclxuICBsZXQgdHJlbmQgPSAwOyAvLyBPdmVyYWxsIHRyZW5kXHJcbiAgbGV0IHZvbGF0aWxpdHkgPSAwLjAyOyAvLyAyJSB2b2xhdGlsaXR5XHJcblxyXG4gIC8vIEFkZCBzb21lIHJlYWxpc3RpYyB0cmVuZFxyXG4gIGNvbnN0IHRyZW5kRGlyZWN0aW9uID0gTWF0aC5yYW5kb20oKSA+IDAuNSA/IDEgOiAtMTtcclxuICBjb25zdCB0cmVuZFN0cmVuZ3RoID0gMC4wMDAxICsgTWF0aC5yYW5kb20oKSAqIDAuMDAwNTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IG51bVBvaW50cyAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICBjb25zdCBtaW51dGVzQWdvID0gaSAqIG1pbnV0ZXNQZXJQb2ludDtcclxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShub3cuZ2V0VGltZSgpIC0gbWludXRlc0FnbyAqIDYwICogMTAwMCk7XHJcblxyXG4gICAgLy8gUmFuZG9tIHdhbGsgd2l0aCB0cmVuZFxyXG4gICAgY29uc3QgcmFuZG9tQ2hhbmdlID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMiAqIHZvbGF0aWxpdHk7XHJcbiAgICB0cmVuZCArPSB0cmVuZERpcmVjdGlvbiAqIHRyZW5kU3RyZW5ndGg7XHJcbiAgICBjdXJyZW50UHJpY2UgPSBjdXJyZW50UHJpY2UgKiAoMSArIHJhbmRvbUNoYW5nZSArIHRyZW5kKTtcclxuXHJcbiAgICAvLyBFbnN1cmUgcHJpY2UgZG9lc24ndCBnbyBuZWdhdGl2ZVxyXG4gICAgY3VycmVudFByaWNlID0gTWF0aC5tYXgoMC4wMSwgY3VycmVudFByaWNlKTtcclxuXHJcbiAgICAvLyBGb3JtYXQgdGltZVxyXG4gICAgbGV0IHRpbWU6IHN0cmluZztcclxuICAgIGlmICh0aW1lUmFuZ2UgPT09ICcxZCcgfHwgdGltZVJhbmdlID09PSAnMXcnKSB7XHJcbiAgICAgIGNvbnN0IGhvdXJzID0gZGF0ZS5nZXRIb3VycygpO1xyXG4gICAgICBjb25zdCBtaW51dGVzID0gZGF0ZS5nZXRNaW51dGVzKCk7XHJcbiAgICAgIHRpbWUgPSBgJHtob3Vycy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9OiR7bWludXRlcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IG1vbnRoID0gKGRhdGUuZ2V0TW9udGgoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcclxuICAgICAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXRlKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xyXG4gICAgICB0aW1lID0gYCR7bW9udGh9LyR7ZGF5fWA7XHJcbiAgICB9XHJcblxyXG4gICAgZGF0YVBvaW50cy5wdXNoKHtcclxuICAgICAgdGltZSxcclxuICAgICAgdmFsdWU6IE51bWJlcihjdXJyZW50UHJpY2UudG9GaXhlZCgyKSksXHJcbiAgICAgIHRpbWVzdGFtcDogZGF0ZS5nZXRUaW1lKCksXHJcbiAgICAgIGRhdGU6IGRhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZGF0YVBvaW50cy5yZXZlcnNlKCk7IC8vIFJldHVybiBpbiBjaHJvbm9sb2dpY2FsIG9yZGVyXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGZXRjaCBzdG9jayBkYXRhIGZyb20gWWFob28gRmluYW5jZSBBUEkgd2l0aCByZXRyeSBsb2dpY1xyXG4gKiBVc2VzIHlhaG9vLWZpbmFuY2UyLWxpa2UgZW5kcG9pbnQgKHB1YmxpYyBBUEkpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hTdG9ja0RhdGEoXHJcbiAgb3B0aW9uczogU3RvY2tEYXRhT3B0aW9ucyxcclxuICByZXRyaWVzID0gMyxcclxuICBiYXNlUHJpY2U/OiBudW1iZXJcclxuKTogUHJvbWlzZTxTdG9ja0RhdGFQb2ludFtdPiB7XHJcbiAgY29uc3QgeyBzeW1ib2wsIGludGVydmFsID0gJzFkJywgcmFuZ2UgPSAnMW1vJyB9ID0gb3B0aW9ucztcclxuXHJcbiAgLy8gVmFsaWRhdGUgc3ltYm9sXHJcbiAgaWYgKCFzeW1ib2wgfHwgc3ltYm9sLnRyaW0oKSA9PT0gJycgfHwgc3ltYm9sID09PSAnTi9BJykge1xyXG4gICAgY29uc29sZS53YXJuKCdJbnZhbGlkIHN5bWJvbCBmb3Igc3RvY2sgZGF0YSBmZXRjaDonLCBzeW1ib2wpO1xyXG4gICAgLy8gR2VuZXJhdGUgcmVhbGlzdGljIGRhdGEgaWYgd2UgaGF2ZSBhIGJhc2UgcHJpY2VcclxuICAgIGlmIChiYXNlUHJpY2UgJiYgYmFzZVByaWNlID4gMCkge1xyXG4gICAgICByZXR1cm4gZ2VuZXJhdGVSZWFsaXN0aWNTdG9ja0RhdGEoYmFzZVByaWNlLCByYW5nZSwgaW50ZXJ2YWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2xlYW4gYW5kIHVwcGVyY2FzZSB0aGUgc3ltYm9sXHJcbiAgY29uc3QgY2xlYW5TeW1ib2wgPSBzeW1ib2wudHJpbSgpLnRvVXBwZXJDYXNlKCk7XHJcblxyXG4gIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgcmV0cmllczsgYXR0ZW1wdCsrKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBVc2UgWWFob28gRmluYW5jZSBBUEkgdmlhIGEgcHVibGljIHByb3h5IG9yIGRpcmVjdCBBUElcclxuICAgICAgLy8gVXNpbmcgeWFob28tZmluYW5jZTIgY29tcGF0aWJsZSBlbmRwb2ludFxyXG4gICAgICBjb25zdCBiYXNlVXJsID0gJ2h0dHBzOi8vcXVlcnkxLmZpbmFuY2UueWFob28uY29tL3Y4L2ZpbmFuY2UvY2hhcnQnO1xyXG4gICAgICBjb25zdCB1cmwgPSBgJHtiYXNlVXJsfS8ke2VuY29kZVVSSUNvbXBvbmVudChjbGVhblN5bWJvbCl9P2ludGVydmFsPSR7aW50ZXJ2YWx9JnJhbmdlPSR7cmFuZ2V9YDtcclxuXHJcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCA4MDAwKTsgLy8gOCBzZWNvbmQgdGltZW91dFxyXG5cclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnVXNlci1BZ2VudCc6ICdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYnLFxyXG4gICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggc3RvY2sgZGF0YTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGlmICghZGF0YT8uY2hhcnQ/LnJlc3VsdD8uWzBdKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0b2NrIGRhdGEgcmVzcG9uc2U6IG5vIGNoYXJ0IGRhdGEnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gZGF0YS5jaGFydC5yZXN1bHRbMF07XHJcbiAgICAgIGNvbnN0IHRpbWVzdGFtcHMgPSByZXN1bHQudGltZXN0YW1wIHx8IFtdO1xyXG4gICAgICBjb25zdCBxdW90ZXMgPSByZXN1bHQuaW5kaWNhdG9ycz8ucXVvdGU/LlswXSB8fCB7fTtcclxuICAgICAgY29uc3QgY2xvc2VzID0gcXVvdGVzLmNsb3NlIHx8IFtdO1xyXG5cclxuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAwIHx8IGNsb3Nlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ05vIHByaWNlIGRhdGEgYXZhaWxhYmxlIGZvciBzeW1ib2w6JywgY2xlYW5TeW1ib2wpO1xyXG4gICAgICAgIC8vIEdlbmVyYXRlIHJlYWxpc3RpYyBkYXRhIGFzIGZhbGxiYWNrXHJcbiAgICAgICAgaWYgKGJhc2VQcmljZSAmJiBiYXNlUHJpY2UgPiAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVSZWFsaXN0aWNTdG9ja0RhdGEoYmFzZVByaWNlLCByYW5nZSwgaW50ZXJ2YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnZlcnQgdG8gb3VyIGZvcm1hdFxyXG4gICAgICBjb25zdCBkYXRhUG9pbnRzOiBTdG9ja0RhdGFQb2ludFtdID0gdGltZXN0YW1wc1xyXG4gICAgICAgIC5tYXAoKHRpbWVzdGFtcDogbnVtYmVyLCBpbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodGltZXN0YW1wICogMTAwMCk7XHJcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNsb3Nlc1tpbmRleF07XHJcblxyXG4gICAgICAgICAgLy8gU2tpcCBpZiB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZFxyXG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRm9ybWF0IHRpbWUgYmFzZWQgb24gaW50ZXJ2YWxcclxuICAgICAgICAgIGxldCB0aW1lOiBzdHJpbmc7XHJcbiAgICAgICAgICBpZiAoaW50ZXJ2YWwgPT09ICcxZCcgJiYgKHJhbmdlID09PSAnMWQnIHx8IHJhbmdlID09PSAnNWQnKSkge1xyXG4gICAgICAgICAgICAvLyBJbnRyYWRheTogc2hvdyB0aW1lXHJcbiAgICAgICAgICAgIGNvbnN0IGhvdXJzID0gZGF0ZS5nZXRIb3VycygpO1xyXG4gICAgICAgICAgICBjb25zdCBtaW51dGVzID0gZGF0ZS5nZXRNaW51dGVzKCk7XHJcbiAgICAgICAgICAgIHRpbWUgPSBgJHtob3Vycy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9OiR7bWludXRlcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERhaWx5L1dlZWtseS9Nb250aGx5OiBzaG93IGRhdGVcclxuICAgICAgICAgICAgY29uc3QgbW9udGggPSAoZGF0ZS5nZXRNb250aCgpICsgMSkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xyXG4gICAgICAgICAgICBjb25zdCBkYXkgPSBkYXRlLmdldERhdGUoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7XHJcbiAgICAgICAgICAgIHRpbWUgPSBgJHttb250aH0vJHtkYXl9YDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0aW1lLFxyXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyKHZhbHVlLnRvRml4ZWQoMikpLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCAqIDEwMDAsXHJcbiAgICAgICAgICAgIGRhdGU6IGRhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5maWx0ZXIoKHBvaW50OiBTdG9ja0RhdGFQb2ludCB8IG51bGwpOiBwb2ludCBpcyBTdG9ja0RhdGFQb2ludCA9PiBwb2ludCAhPT0gbnVsbCAmJiBwb2ludC52YWx1ZSA+IDApO1xyXG5cclxuICAgICAgaWYgKGRhdGFQb2ludHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdObyB2YWxpZCBkYXRhIHBvaW50cyBhZnRlciBmaWx0ZXJpbmcgZm9yIHN5bWJvbDonLCBjbGVhblN5bWJvbCk7XHJcbiAgICAgICAgLy8gR2VuZXJhdGUgcmVhbGlzdGljIGRhdGEgYXMgZmFsbGJhY2tcclxuICAgICAgICBpZiAoYmFzZVByaWNlICYmIGJhc2VQcmljZSA+IDApIHtcclxuICAgICAgICAgIHJldHVybiBnZW5lcmF0ZVJlYWxpc3RpY1N0b2NrRGF0YShiYXNlUHJpY2UsIHJhbmdlLCBpbnRlcnZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGRhdGFQb2ludHM7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zdCBpc0xhc3RBdHRlbXB0ID0gYXR0ZW1wdCA9PT0gcmV0cmllcyAtIDE7XHJcblxyXG4gICAgICAvLyBIYW5kbGUgZXJyb3JzXHJcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJyB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCd0aW1lb3V0JykpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihgU3RvY2sgZGF0YSBmZXRjaCB0aW1lZCBvdXQgKGF0dGVtcHQgJHthdHRlbXB0ICsgMX0vJHtyZXRyaWVzfSkgZm9yIHN5bWJvbDpgLCBjbGVhblN5bWJvbCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdDT1JTJykgfHwgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnRmFpbGVkIHRvIGZldGNoJykpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihgQ09SUyBlcnJvciAoYXR0ZW1wdCAke2F0dGVtcHQgKyAxfS8ke3JldHJpZXN9KSBmb3Igc3ltYm9sOmAsIGNsZWFuU3ltYm9sKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgc3RvY2sgZGF0YSAoYXR0ZW1wdCAke2F0dGVtcHQgKyAxfS8ke3JldHJpZXN9KSBmb3Igc3ltYm9sOmAsIGNsZWFuU3ltYm9sLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB0aGlzIGlzIHRoZSBsYXN0IGF0dGVtcHQsIGdlbmVyYXRlIHJlYWxpc3RpYyBkYXRhIGFzIGZhbGxiYWNrXHJcbiAgICAgIGlmIChpc0xhc3RBdHRlbXB0KSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdBbGwgcmV0cnkgYXR0ZW1wdHMgZmFpbGVkLCBnZW5lcmF0aW5nIHJlYWxpc3RpYyBzdG9jayBkYXRhIGFzIGZhbGxiYWNrJyk7XHJcbiAgICAgICAgaWYgKGJhc2VQcmljZSAmJiBiYXNlUHJpY2UgPiAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVSZWFsaXN0aWNTdG9ja0RhdGEoYmFzZVByaWNlLCByYW5nZSwgaW50ZXJ2YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5aW5nIChleHBvbmVudGlhbCBiYWNrb2ZmKVxyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCAqIChhdHRlbXB0ICsgMSkpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhcHByb3ByaWF0ZSBpbnRlcnZhbCBhbmQgcmFuZ2UgZm9yIGEgdGltZSBwZXJpb2RcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdG9ja0RhdGFQYXJhbXModGltZVJhbmdlOiBzdHJpbmcpOiB7IGludGVydmFsOiAnMWQnIHwgJzF3aycgfCAnMW1vJzsgcmFuZ2U6IHN0cmluZyB9IHtcclxuICBzd2l0Y2ggKHRpbWVSYW5nZSkge1xyXG4gICAgY2FzZSAnMWQnOlxyXG4gICAgICByZXR1cm4geyBpbnRlcnZhbDogJzFkJywgcmFuZ2U6ICcxZCcgfTtcclxuICAgIGNhc2UgJzF3JzpcclxuICAgIGNhc2UgJzEgd2Vlayc6XHJcbiAgICAgIHJldHVybiB7IGludGVydmFsOiAnMWQnLCByYW5nZTogJzVkJyB9O1xyXG4gICAgY2FzZSAnMW0nOlxyXG4gICAgY2FzZSAnMSBtb250aCc6XHJcbiAgICAgIHJldHVybiB7IGludGVydmFsOiAnMWQnLCByYW5nZTogJzFtbycgfTtcclxuICAgIGNhc2UgJzNtJzpcclxuICAgIGNhc2UgJzMgbW9udGhzJzpcclxuICAgICAgcmV0dXJuIHsgaW50ZXJ2YWw6ICcxZCcsIHJhbmdlOiAnM21vJyB9O1xyXG4gICAgY2FzZSAnNm0nOlxyXG4gICAgY2FzZSAnNiBtb250aHMnOlxyXG4gICAgICByZXR1cm4geyBpbnRlcnZhbDogJzF3aycsIHJhbmdlOiAnNm1vJyB9O1xyXG4gICAgY2FzZSAnMXknOlxyXG4gICAgY2FzZSAnMSB5ZWFyJzpcclxuICAgICAgcmV0dXJuIHsgaW50ZXJ2YWw6ICcxd2snLCByYW5nZTogJzF5JyB9O1xyXG4gICAgY2FzZSAnbWF4JzpcclxuICAgICAgcmV0dXJuIHsgaW50ZXJ2YWw6ICcxbW8nLCByYW5nZTogJ21heCcgfTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiB7IGludGVydmFsOiAnMWQnLCByYW5nZTogJzFtbycgfTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IHRpbWUgcmFuZ2Ugc3RyaW5nIHRvIGRpc3BsYXkgbGFiZWxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUaW1lUmFuZ2VMYWJlbCh0aW1lUmFuZ2U6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgc3dpdGNoICh0aW1lUmFuZ2UpIHtcclxuICAgIGNhc2UgJzFkJzpcclxuICAgICAgcmV0dXJuICcxIERheSc7XHJcbiAgICBjYXNlICcxdyc6XHJcbiAgICBjYXNlICcxIHdlZWsnOlxyXG4gICAgICByZXR1cm4gJzEgV2Vlayc7XHJcbiAgICBjYXNlICcxbSc6XHJcbiAgICBjYXNlICcxIG1vbnRoJzpcclxuICAgICAgcmV0dXJuICcxIE1vbnRoJztcclxuICAgIGNhc2UgJzNtJzpcclxuICAgIGNhc2UgJzMgbW9udGhzJzpcclxuICAgICAgcmV0dXJuICczIE1vbnRocyc7XHJcbiAgICBjYXNlICc2bSc6XHJcbiAgICBjYXNlICc2IG1vbnRocyc6XHJcbiAgICAgIHJldHVybiAnNiBNb250aHMnO1xyXG4gICAgY2FzZSAnMXknOlxyXG4gICAgY2FzZSAnMSB5ZWFyJzpcclxuICAgICAgcmV0dXJuICcxIFllYXInO1xyXG4gICAgY2FzZSAnbWF4JzpcclxuICAgICAgcmV0dXJuICdNYXgnO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIHRpbWVSYW5nZTtcclxuICB9XHJcbn1cclxuXHJcbiJdLCJuYW1lcyI6WyJnZW5lcmF0ZVJlYWxpc3RpY1N0b2NrRGF0YSIsImJhc2VQcmljZSIsInJhbmdlIiwiaW50ZXJ2YWwiLCJub3ciLCJEYXRlIiwibnVtUG9pbnRzIiwibWludXRlc1BlclBvaW50IiwiZGF0YVBvaW50cyIsImN1cnJlbnRQcmljZSIsInRyZW5kIiwidm9sYXRpbGl0eSIsInRyZW5kRGlyZWN0aW9uIiwiTWF0aCIsInJhbmRvbSIsInRyZW5kU3RyZW5ndGgiLCJpIiwibWludXRlc0FnbyIsImRhdGUiLCJnZXRUaW1lIiwicmFuZG9tQ2hhbmdlIiwibWF4IiwidGltZSIsInRpbWVSYW5nZSIsImhvdXJzIiwiZ2V0SG91cnMiLCJtaW51dGVzIiwiZ2V0TWludXRlcyIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJtb250aCIsImdldE1vbnRoIiwiZGF5IiwiZ2V0RGF0ZSIsInB1c2giLCJ2YWx1ZSIsIk51bWJlciIsInRvRml4ZWQiLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwicmV2ZXJzZSIsImZldGNoU3RvY2tEYXRhIiwib3B0aW9ucyIsInJldHJpZXMiLCJzeW1ib2wiLCJ0cmltIiwiY29uc29sZSIsIndhcm4iLCJjbGVhblN5bWJvbCIsInRvVXBwZXJDYXNlIiwiYXR0ZW1wdCIsImRhdGEiLCJyZXN1bHQiLCJiYXNlVXJsIiwidXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJhYm9ydCIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0Iiwib2siLCJFcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJqc29uIiwiY2hhcnQiLCJ0aW1lc3RhbXBzIiwicXVvdGVzIiwiaW5kaWNhdG9ycyIsInF1b3RlIiwiY2xvc2VzIiwiY2xvc2UiLCJsZW5ndGgiLCJtYXAiLCJpbmRleCIsInVuZGVmaW5lZCIsImlzRmluaXRlIiwiZmlsdGVyIiwicG9pbnQiLCJlcnJvciIsImlzTGFzdEF0dGVtcHQiLCJuYW1lIiwibWVzc2FnZSIsImluY2x1ZGVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJnZXRTdG9ja0RhdGFQYXJhbXMiLCJmb3JtYXRUaW1lUmFuZ2VMYWJlbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/stockData.ts\n"));

/***/ })

});