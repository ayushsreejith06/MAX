"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/sectors/[id]/page",{

/***/ "(app-pages-browser)/./lib/stockData.ts":
/*!**************************!*\
  !*** ./lib/stockData.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchStockData: function() { return /* binding */ fetchStockData; },\n/* harmony export */   formatTimeRangeLabel: function() { return /* binding */ formatTimeRangeLabel; },\n/* harmony export */   getStockDataParams: function() { return /* binding */ getStockDataParams; }\n/* harmony export */ });\n/**\r\n * Stock Data API Utility\r\n * Fetches real stock market data using Yahoo Finance API\r\n */ /**\r\n * Generate realistic stock-like data as fallback\r\n */ function generateRealisticStockData(basePrice, timeRange, interval) {\n    const now = new Date();\n    let numPoints = 100;\n    let minutesPerPoint = 5;\n    // Determine number of points and interval based on time range\n    switch(timeRange){\n        case \"1d\":\n            numPoints = 78; // Market hours: 6.5 hours * 12 (5-min intervals)\n            minutesPerPoint = 5;\n            break;\n        case \"1w\":\n            numPoints = 65; // 5 trading days * 13 points per day\n            minutesPerPoint = 390; // ~6.5 hours per point\n            break;\n        case \"1m\":\n            numPoints = 22; // ~22 trading days\n            minutesPerPoint = 1440; // 1 day per point\n            break;\n        case \"3m\":\n            numPoints = 66; // ~66 trading days\n            minutesPerPoint = 1440;\n            break;\n        case \"6m\":\n            numPoints = 130; // ~130 trading days\n            minutesPerPoint = 1440;\n            break;\n        case \"1y\":\n            numPoints = 252; // ~252 trading days\n            minutesPerPoint = 1440;\n            break;\n        case \"max\":\n            numPoints = 500;\n            minutesPerPoint = 1440;\n            break;\n    }\n    const dataPoints = [];\n    let currentPrice = basePrice;\n    let trend = 0; // Overall trend\n    let volatility = 0.02; // 2% volatility\n    // Add some realistic trend\n    const trendDirection = Math.random() > 0.5 ? 1 : -1;\n    const trendStrength = 0.0001 + Math.random() * 0.0005;\n    for(let i = numPoints - 1; i >= 0; i--){\n        const minutesAgo = i * minutesPerPoint;\n        const date = new Date(now.getTime() - minutesAgo * 60 * 1000);\n        // Random walk with trend\n        const randomChange = (Math.random() - 0.5) * 2 * volatility;\n        trend += trendDirection * trendStrength;\n        currentPrice = currentPrice * (1 + randomChange + trend);\n        // Ensure price doesn't go negative\n        currentPrice = Math.max(0.01, currentPrice);\n        // Format time\n        let time;\n        if (timeRange === \"1d\" || timeRange === \"1w\") {\n            const hours = date.getHours();\n            const minutes = date.getMinutes();\n            time = \"\".concat(hours.toString().padStart(2, \"0\"), \":\").concat(minutes.toString().padStart(2, \"0\"));\n        } else {\n            const month = (date.getMonth() + 1).toString().padStart(2, \"0\");\n            const day = date.getDate().toString().padStart(2, \"0\");\n            time = \"\".concat(month, \"/\").concat(day);\n        }\n        dataPoints.push({\n            time,\n            value: Number(currentPrice.toFixed(2)),\n            timestamp: date.getTime(),\n            date: date.toISOString().split(\"T\")[0]\n        });\n    }\n    return dataPoints.reverse(); // Return in chronological order\n}\n/**\r\n * Fetch stock data from Yahoo Finance API with retry logic\r\n * Uses yahoo-finance2-like endpoint (public API)\r\n */ async function fetchStockData(options) {\n    let retries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3, basePrice = arguments.length > 2 ? arguments[2] : void 0;\n    const { symbol, interval = \"1d\", range = \"1mo\" } = options;\n    // Validate symbol\n    if (!symbol || symbol.trim() === \"\" || symbol === \"N/A\") {\n        console.warn(\"Invalid symbol for stock data fetch:\", symbol);\n        // Generate realistic data if we have a base price\n        if (basePrice && basePrice > 0) {\n            return generateRealisticStockData(basePrice, range, interval);\n        }\n        return [];\n    }\n    // Clean and uppercase the symbol\n    const cleanSymbol = symbol.trim().toUpperCase();\n    for(let attempt = 0; attempt < retries; attempt++){\n        try {\n            var _data_chart_result, _data_chart, _result_indicators_quote, _result_indicators;\n            // Use Yahoo Finance API via a public proxy or direct API\n            // Using yahoo-finance2 compatible endpoint\n            const baseUrl = \"https://query1.finance.yahoo.com/v8/finance/chart\";\n            const url = \"\".concat(baseUrl, \"/\").concat(encodeURIComponent(cleanSymbol), \"?interval=\").concat(interval, \"&range=\").concat(range);\n            const controller = new AbortController();\n            const timeoutId = setTimeout(()=>controller.abort(), 8000); // 8 second timeout\n            const response = await fetch(url, {\n                headers: {\n                    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\",\n                    \"Accept\": \"application/json\"\n                },\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                throw new Error(\"Failed to fetch stock data: \".concat(response.status, \" \").concat(response.statusText));\n            }\n            const data = await response.json();\n            if (!(data === null || data === void 0 ? void 0 : (_data_chart = data.chart) === null || _data_chart === void 0 ? void 0 : (_data_chart_result = _data_chart.result) === null || _data_chart_result === void 0 ? void 0 : _data_chart_result[0])) {\n                throw new Error(\"Invalid stock data response: no chart data\");\n            }\n            const result = data.chart.result[0];\n            const timestamps = result.timestamp || [];\n            const quotes = ((_result_indicators = result.indicators) === null || _result_indicators === void 0 ? void 0 : (_result_indicators_quote = _result_indicators.quote) === null || _result_indicators_quote === void 0 ? void 0 : _result_indicators_quote[0]) || {};\n            const closes = quotes.close || [];\n            if (timestamps.length === 0 || closes.length === 0) {\n                console.warn(\"No price data available for symbol:\", cleanSymbol);\n                // Generate realistic data as fallback\n                if (basePrice && basePrice > 0) {\n                    return generateRealisticStockData(basePrice, range, interval);\n                }\n                return [];\n            }\n            // Convert to our format\n            const dataPoints = timestamps.map((timestamp, index)=>{\n                const date = new Date(timestamp * 1000);\n                const value = closes[index];\n                // Skip if value is null or undefined\n                if (value === null || value === undefined || !Number.isFinite(value)) {\n                    return null;\n                }\n                // Format time based on interval\n                let time;\n                if (interval === \"1d\" && (range === \"1d\" || range === \"5d\")) {\n                    // Intraday: show time\n                    const hours = date.getHours();\n                    const minutes = date.getMinutes();\n                    time = \"\".concat(hours.toString().padStart(2, \"0\"), \":\").concat(minutes.toString().padStart(2, \"0\"));\n                } else {\n                    // Daily/Weekly/Monthly: show date\n                    const month = (date.getMonth() + 1).toString().padStart(2, \"0\");\n                    const day = date.getDate().toString().padStart(2, \"0\");\n                    time = \"\".concat(month, \"/\").concat(day);\n                }\n                return {\n                    time,\n                    value: Number(value.toFixed(2)),\n                    timestamp: timestamp * 1000,\n                    date: date.toISOString().split(\"T\")[0]\n                };\n            }).filter((point)=>point !== null && point.value > 0);\n            if (dataPoints.length === 0) {\n                console.warn(\"No valid data points after filtering for symbol:\", cleanSymbol);\n                // Generate realistic data as fallback\n                if (basePrice && basePrice > 0) {\n                    return generateRealisticStockData(basePrice, range, interval);\n                }\n                return [];\n            }\n            return dataPoints;\n        } catch (error) {\n            const isLastAttempt = attempt === retries - 1;\n            // Handle errors\n            if (error instanceof Error) {\n                if (error.name === \"AbortError\" || error.message.includes(\"timeout\")) {\n                    console.warn(\"Stock data fetch timed out (attempt \".concat(attempt + 1, \"/\").concat(retries, \") for symbol:\"), cleanSymbol);\n                } else if (error.message.includes(\"CORS\") || error.message.includes(\"Failed to fetch\")) {\n                    console.warn(\"CORS error (attempt \".concat(attempt + 1, \"/\").concat(retries, \") for symbol:\"), cleanSymbol);\n                } else {\n                    console.error(\"Error fetching stock data (attempt \".concat(attempt + 1, \"/\").concat(retries, \") for symbol:\"), cleanSymbol, error);\n                }\n            }\n            // If this is the last attempt, generate realistic data as fallback\n            if (isLastAttempt) {\n                console.warn(\"All retry attempts failed, generating realistic stock data as fallback\");\n                if (basePrice && basePrice > 0) {\n                    return generateRealisticStockData(basePrice, range, interval);\n                }\n                return [];\n            }\n            // Wait before retrying (exponential backoff)\n            await new Promise((resolve)=>setTimeout(resolve, 1000 * (attempt + 1)));\n        }\n    }\n    return [];\n}\n/**\r\n * Get appropriate interval and range for a time period\r\n */ function getStockDataParams(timeRange) {\n    switch(timeRange){\n        case \"1d\":\n            return {\n                interval: \"1d\",\n                range: \"1d\"\n            };\n        case \"1w\":\n        case \"1 week\":\n            return {\n                interval: \"1d\",\n                range: \"5d\"\n            };\n        case \"1m\":\n        case \"1 month\":\n            return {\n                interval: \"1d\",\n                range: \"1mo\"\n            };\n        case \"3m\":\n        case \"3 months\":\n            return {\n                interval: \"1d\",\n                range: \"3mo\"\n            };\n        case \"6m\":\n        case \"6 months\":\n            return {\n                interval: \"1wk\",\n                range: \"6mo\"\n            };\n        case \"1y\":\n        case \"1 year\":\n            return {\n                interval: \"1wk\",\n                range: \"1y\"\n            };\n        case \"max\":\n            return {\n                interval: \"1mo\",\n                range: \"max\"\n            };\n        default:\n            return {\n                interval: \"1d\",\n                range: \"1mo\"\n            };\n    }\n}\n/**\r\n * Convert time range string to display label\r\n */ function formatTimeRangeLabel(timeRange) {\n    switch(timeRange){\n        case \"1d\":\n            return \"1 Day\";\n        case \"1w\":\n        case \"1 week\":\n            return \"1 Week\";\n        case \"1m\":\n        case \"1 month\":\n            return \"1 Month\";\n        case \"3m\":\n        case \"3 months\":\n            return \"3 Months\";\n        case \"6m\":\n        case \"6 months\":\n            return \"6 Months\";\n        case \"1y\":\n        case \"1 year\":\n            return \"1 Year\";\n        case \"max\":\n            return \"Max\";\n        default:\n            return timeRange;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUUxQyxVQUFVO2dCQUFNMEMsT0FBTztZQUFNO1FBQ3hDLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztnQkFBRTFDLFVBQVU7Z0JBQU8wQyxPQUFPO1lBQU07UUFDekMsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO2dCQUFFMUMsVUFBVTtnQkFBTzBDLE9BQU87WUFBSztRQUN4QyxLQUFLO1lBQ0gsT0FBTztnQkFBRTFDLFVBQVU7Z0JBQU8wQyxPQUFPO1lBQU07UUFDekM7WUFDRSxPQUFPO2dCQUFFMUMsVUFBVTtnQkFBTTBDLE9BQU87WUFBTTtJQUMxQztBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTaUQscUJBQXFCNUYsU0FBaUI7SUFDcEQsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1Q7WUFDRSxPQUFPQTtJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3N0b2NrRGF0YS50cz82OWU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBTdG9jayBEYXRhIEFQSSBVdGlsaXR5XHJcbiAqIEZldGNoZXMgcmVhbCBzdG9jayBtYXJrZXQgZGF0YSB1c2luZyBZYWhvbyBGaW5hbmNlIEFQSVxyXG4gKi9cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RvY2tEYXRhUG9pbnQge1xyXG4gIHRpbWU6IHN0cmluZzsgLy8gRm9ybWF0OiBcIkhIOk1NXCIgZm9yIGludHJhZGF5LCBcIllZWVktTU0tRERcIiBmb3IgZGFpbHlcclxuICB2YWx1ZTogbnVtYmVyO1xyXG4gIHRpbWVzdGFtcD86IG51bWJlcjsgLy8gVW5peCB0aW1lc3RhbXAgZm9yIHNvcnRpbmdcclxuICBkYXRlPzogc3RyaW5nOyAvLyBGdWxsIGRhdGUgc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RvY2tEYXRhT3B0aW9ucyB7XHJcbiAgc3ltYm9sOiBzdHJpbmc7XHJcbiAgaW50ZXJ2YWw/OiAnMWQnIHwgJzF3aycgfCAnMW1vJzsgLy8gRGFpbHksIFdlZWtseSwgTW9udGhseVxyXG4gIHJhbmdlPzogJzFkJyB8ICc1ZCcgfCAnMW1vJyB8ICczbW8nIHwgJzZtbycgfCAnMXknIHwgJzJ5JyB8ICc1eScgfCAnMTB5JyB8ICd5dGQnIHwgJ21heCc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSByZWFsaXN0aWMgc3RvY2stbGlrZSBkYXRhIGFzIGZhbGxiYWNrXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVJlYWxpc3RpY1N0b2NrRGF0YShcclxuICBiYXNlUHJpY2U6IG51bWJlcixcclxuICB0aW1lUmFuZ2U6IHN0cmluZyxcclxuICBpbnRlcnZhbDogJzFkJyB8ICcxd2snIHwgJzFtbydcclxuKTogU3RvY2tEYXRhUG9pbnRbXSB7XHJcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICBsZXQgbnVtUG9pbnRzID0gMTAwO1xyXG4gIGxldCBtaW51dGVzUGVyUG9pbnQgPSA1O1xyXG5cclxuICAvLyBEZXRlcm1pbmUgbnVtYmVyIG9mIHBvaW50cyBhbmQgaW50ZXJ2YWwgYmFzZWQgb24gdGltZSByYW5nZVxyXG4gIHN3aXRjaCAodGltZVJhbmdlKSB7XHJcbiAgICBjYXNlICcxZCc6XHJcbiAgICAgIG51bVBvaW50cyA9IDc4OyAvLyBNYXJrZXQgaG91cnM6IDYuNSBob3VycyAqIDEyICg1LW1pbiBpbnRlcnZhbHMpXHJcbiAgICAgIG1pbnV0ZXNQZXJQb2ludCA9IDU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnMXcnOlxyXG4gICAgICBudW1Qb2ludHMgPSA2NTsgLy8gNSB0cmFkaW5nIGRheXMgKiAxMyBwb2ludHMgcGVyIGRheVxyXG4gICAgICBtaW51dGVzUGVyUG9pbnQgPSAzOTA7IC8vIH42LjUgaG91cnMgcGVyIHBvaW50XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnMW0nOlxyXG4gICAgICBudW1Qb2ludHMgPSAyMjsgLy8gfjIyIHRyYWRpbmcgZGF5c1xyXG4gICAgICBtaW51dGVzUGVyUG9pbnQgPSAxNDQwOyAvLyAxIGRheSBwZXIgcG9pbnRcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICczbSc6XHJcbiAgICAgIG51bVBvaW50cyA9IDY2OyAvLyB+NjYgdHJhZGluZyBkYXlzXHJcbiAgICAgIG1pbnV0ZXNQZXJQb2ludCA9IDE0NDA7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnNm0nOlxyXG4gICAgICBudW1Qb2ludHMgPSAxMzA7IC8vIH4xMzAgdHJhZGluZyBkYXlzXHJcbiAgICAgIG1pbnV0ZXNQZXJQb2ludCA9IDE0NDA7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnMXknOlxyXG4gICAgICBudW1Qb2ludHMgPSAyNTI7IC8vIH4yNTIgdHJhZGluZyBkYXlzXHJcbiAgICAgIG1pbnV0ZXNQZXJQb2ludCA9IDE0NDA7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnbWF4JzpcclxuICAgICAgbnVtUG9pbnRzID0gNTAwO1xyXG4gICAgICBtaW51dGVzUGVyUG9pbnQgPSAxNDQwO1xyXG4gICAgICBicmVhaztcclxuICB9XHJcblxyXG4gIGNvbnN0IGRhdGFQb2ludHM6IFN0b2NrRGF0YVBvaW50W10gPSBbXTtcclxuICBsZXQgY3VycmVudFByaWNlID0gYmFzZVByaWNlO1xyXG4gIGxldCB0cmVuZCA9IDA7IC8vIE92ZXJhbGwgdHJlbmRcclxuICBsZXQgdm9sYXRpbGl0eSA9IDAuMDI7IC8vIDIlIHZvbGF0aWxpdHlcclxuXHJcbiAgLy8gQWRkIHNvbWUgcmVhbGlzdGljIHRyZW5kXHJcbiAgY29uc3QgdHJlbmREaXJlY3Rpb24gPSBNYXRoLnJhbmRvbSgpID4gMC41ID8gMSA6IC0xO1xyXG4gIGNvbnN0IHRyZW5kU3RyZW5ndGggPSAwLjAwMDEgKyBNYXRoLnJhbmRvbSgpICogMC4wMDA1O1xyXG5cclxuICBmb3IgKGxldCBpID0gbnVtUG9pbnRzIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgIGNvbnN0IG1pbnV0ZXNBZ28gPSBpICogbWludXRlc1BlclBvaW50O1xyXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgLSBtaW51dGVzQWdvICogNjAgKiAxMDAwKTtcclxuXHJcbiAgICAvLyBSYW5kb20gd2FsayB3aXRoIHRyZW5kXHJcbiAgICBjb25zdCByYW5kb21DaGFuZ2UgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyICogdm9sYXRpbGl0eTtcclxuICAgIHRyZW5kICs9IHRyZW5kRGlyZWN0aW9uICogdHJlbmRTdHJlbmd0aDtcclxuICAgIGN1cnJlbnRQcmljZSA9IGN1cnJlbnRQcmljZSAqICgxICsgcmFuZG9tQ2hhbmdlICsgdHJlbmQpO1xyXG5cclxuICAgIC8vIEVuc3VyZSBwcmljZSBkb2Vzbid0IGdvIG5lZ2F0aXZlXHJcbiAgICBjdXJyZW50UHJpY2UgPSBNYXRoLm1heCgwLjAxLCBjdXJyZW50UHJpY2UpO1xyXG5cclxuICAgIC8vIEZvcm1hdCB0aW1lXHJcbiAgICBsZXQgdGltZTogc3RyaW5nO1xyXG4gICAgaWYgKHRpbWVSYW5nZSA9PT0gJzFkJyB8fCB0aW1lUmFuZ2UgPT09ICcxdycpIHtcclxuICAgICAgY29uc3QgaG91cnMgPSBkYXRlLmdldEhvdXJzKCk7XHJcbiAgICAgIGNvbnN0IG1pbnV0ZXMgPSBkYXRlLmdldE1pbnV0ZXMoKTtcclxuICAgICAgdGltZSA9IGAke2hvdXJzLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX06JHttaW51dGVzLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX1gO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgbW9udGggPSAoZGF0ZS5nZXRNb250aCgpICsgMSkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xyXG4gICAgICBjb25zdCBkYXkgPSBkYXRlLmdldERhdGUoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7XHJcbiAgICAgIHRpbWUgPSBgJHttb250aH0vJHtkYXl9YDtcclxuICAgIH1cclxuXHJcbiAgICBkYXRhUG9pbnRzLnB1c2goe1xyXG4gICAgICB0aW1lLFxyXG4gICAgICB2YWx1ZTogTnVtYmVyKGN1cnJlbnRQcmljZS50b0ZpeGVkKDIpKSxcclxuICAgICAgdGltZXN0YW1wOiBkYXRlLmdldFRpbWUoKSxcclxuICAgICAgZGF0ZTogZGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBkYXRhUG9pbnRzLnJldmVyc2UoKTsgLy8gUmV0dXJuIGluIGNocm9ub2xvZ2ljYWwgb3JkZXJcclxufVxyXG5cclxuLyoqXHJcbiAqIEZldGNoIHN0b2NrIGRhdGEgZnJvbSBZYWhvbyBGaW5hbmNlIEFQSSB3aXRoIHJldHJ5IGxvZ2ljXHJcbiAqIFVzZXMgeWFob28tZmluYW5jZTItbGlrZSBlbmRwb2ludCAocHVibGljIEFQSSlcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFN0b2NrRGF0YShcclxuICBvcHRpb25zOiBTdG9ja0RhdGFPcHRpb25zLFxyXG4gIHJldHJpZXMgPSAzLFxyXG4gIGJhc2VQcmljZT86IG51bWJlclxyXG4pOiBQcm9taXNlPFN0b2NrRGF0YVBvaW50W10+IHtcclxuICBjb25zdCB7IHN5bWJvbCwgaW50ZXJ2YWwgPSAnMWQnLCByYW5nZSA9ICcxbW8nIH0gPSBvcHRpb25zO1xyXG5cclxuICAvLyBWYWxpZGF0ZSBzeW1ib2xcclxuICBpZiAoIXN5bWJvbCB8fCBzeW1ib2wudHJpbSgpID09PSAnJyB8fCBzeW1ib2wgPT09ICdOL0EnKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgc3ltYm9sIGZvciBzdG9jayBkYXRhIGZldGNoOicsIHN5bWJvbCk7XHJcbiAgICAvLyBHZW5lcmF0ZSByZWFsaXN0aWMgZGF0YSBpZiB3ZSBoYXZlIGEgYmFzZSBwcmljZVxyXG4gICAgaWYgKGJhc2VQcmljZSAmJiBiYXNlUHJpY2UgPiAwKSB7XHJcbiAgICAgIHJldHVybiBnZW5lcmF0ZVJlYWxpc3RpY1N0b2NrRGF0YShiYXNlUHJpY2UsIHJhbmdlLCBpbnRlcnZhbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICAvLyBDbGVhbiBhbmQgdXBwZXJjYXNlIHRoZSBzeW1ib2xcclxuICBjb25zdCBjbGVhblN5bWJvbCA9IHN5bWJvbC50cmltKCkudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCByZXRyaWVzOyBhdHRlbXB0KyspIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFVzZSBZYWhvbyBGaW5hbmNlIEFQSSB2aWEgYSBwdWJsaWMgcHJveHkgb3IgZGlyZWN0IEFQSVxyXG4gICAgICAvLyBVc2luZyB5YWhvby1maW5hbmNlMiBjb21wYXRpYmxlIGVuZHBvaW50XHJcbiAgICAgIGNvbnN0IGJhc2VVcmwgPSAnaHR0cHM6Ly9xdWVyeTEuZmluYW5jZS55YWhvby5jb20vdjgvZmluYW5jZS9jaGFydCc7XHJcbiAgICAgIGNvbnN0IHVybCA9IGAke2Jhc2VVcmx9LyR7ZW5jb2RlVVJJQ29tcG9uZW50KGNsZWFuU3ltYm9sKX0/aW50ZXJ2YWw9JHtpbnRlcnZhbH0mcmFuZ2U9JHtyYW5nZX1gO1xyXG5cclxuICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIDgwMDApOyAvLyA4IHNlY29uZCB0aW1lb3V0XHJcblxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdVc2VyLUFnZW50JzogJ01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNicsXHJcbiAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcclxuXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBzdG9jayBkYXRhOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgaWYgKCFkYXRhPy5jaGFydD8ucmVzdWx0Py5bMF0pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RvY2sgZGF0YSByZXNwb25zZTogbm8gY2hhcnQgZGF0YScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBkYXRhLmNoYXJ0LnJlc3VsdFswXTtcclxuICAgICAgY29uc3QgdGltZXN0YW1wcyA9IHJlc3VsdC50aW1lc3RhbXAgfHwgW107XHJcbiAgICAgIGNvbnN0IHF1b3RlcyA9IHJlc3VsdC5pbmRpY2F0b3JzPy5xdW90ZT8uWzBdIHx8IHt9O1xyXG4gICAgICBjb25zdCBjbG9zZXMgPSBxdW90ZXMuY2xvc2UgfHwgW107XHJcblxyXG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDAgfHwgY2xvc2VzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignTm8gcHJpY2UgZGF0YSBhdmFpbGFibGUgZm9yIHN5bWJvbDonLCBjbGVhblN5bWJvbCk7XHJcbiAgICAgICAgLy8gR2VuZXJhdGUgcmVhbGlzdGljIGRhdGEgYXMgZmFsbGJhY2tcclxuICAgICAgICBpZiAoYmFzZVByaWNlICYmIGJhc2VQcmljZSA+IDApIHtcclxuICAgICAgICAgIHJldHVybiBnZW5lcmF0ZVJlYWxpc3RpY1N0b2NrRGF0YShiYXNlUHJpY2UsIHJhbmdlLCBpbnRlcnZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCB0byBvdXIgZm9ybWF0XHJcbiAgICAgIGNvbnN0IGRhdGFQb2ludHM6IFN0b2NrRGF0YVBvaW50W10gPSB0aW1lc3RhbXBzXHJcbiAgICAgICAgLm1hcCgodGltZXN0YW1wOiBudW1iZXIsIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXAgKiAxMDAwKTtcclxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2xvc2VzW2luZGV4XTtcclxuXHJcbiAgICAgICAgICAvLyBTa2lwIGlmIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkXHJcbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGb3JtYXQgdGltZSBiYXNlZCBvbiBpbnRlcnZhbFxyXG4gICAgICAgICAgbGV0IHRpbWU6IHN0cmluZztcclxuICAgICAgICAgIGlmIChpbnRlcnZhbCA9PT0gJzFkJyAmJiAocmFuZ2UgPT09ICcxZCcgfHwgcmFuZ2UgPT09ICc1ZCcpKSB7XHJcbiAgICAgICAgICAgIC8vIEludHJhZGF5OiBzaG93IHRpbWVcclxuICAgICAgICAgICAgY29uc3QgaG91cnMgPSBkYXRlLmdldEhvdXJzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBkYXRlLmdldE1pbnV0ZXMoKTtcclxuICAgICAgICAgICAgdGltZSA9IGAke2hvdXJzLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX06JHttaW51dGVzLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX1gO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRGFpbHkvV2Vla2x5L01vbnRobHk6IHNob3cgZGF0ZVxyXG4gICAgICAgICAgICBjb25zdCBtb250aCA9IChkYXRlLmdldE1vbnRoKCkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRheSA9IGRhdGUuZ2V0RGF0ZSgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcclxuICAgICAgICAgICAgdGltZSA9IGAke21vbnRofS8ke2RheX1gO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRpbWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIodmFsdWUudG9GaXhlZCgyKSksXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wICogMTAwMCxcclxuICAgICAgICAgICAgZGF0ZTogZGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmZpbHRlcigocG9pbnQ6IFN0b2NrRGF0YVBvaW50IHwgbnVsbCk6IHBvaW50IGlzIFN0b2NrRGF0YVBvaW50ID0+IHBvaW50ICE9PSBudWxsICYmIHBvaW50LnZhbHVlID4gMCk7XHJcblxyXG4gICAgICBpZiAoZGF0YVBvaW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ05vIHZhbGlkIGRhdGEgcG9pbnRzIGFmdGVyIGZpbHRlcmluZyBmb3Igc3ltYm9sOicsIGNsZWFuU3ltYm9sKTtcclxuICAgICAgICAvLyBHZW5lcmF0ZSByZWFsaXN0aWMgZGF0YSBhcyBmYWxsYmFja1xyXG4gICAgICAgIGlmIChiYXNlUHJpY2UgJiYgYmFzZVByaWNlID4gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIGdlbmVyYXRlUmVhbGlzdGljU3RvY2tEYXRhKGJhc2VQcmljZSwgcmFuZ2UsIGludGVydmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZGF0YVBvaW50cztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnN0IGlzTGFzdEF0dGVtcHQgPSBhdHRlbXB0ID09PSByZXRyaWVzIC0gMTtcclxuXHJcbiAgICAgIC8vIEhhbmRsZSBlcnJvcnNcclxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3RpbWVvdXQnKSkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKGBTdG9jayBkYXRhIGZldGNoIHRpbWVkIG91dCAoYXR0ZW1wdCAke2F0dGVtcHQgKyAxfS8ke3JldHJpZXN9KSBmb3Igc3ltYm9sOmAsIGNsZWFuU3ltYm9sKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0NPUlMnKSB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdGYWlsZWQgdG8gZmV0Y2gnKSkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKGBDT1JTIGVycm9yIChhdHRlbXB0ICR7YXR0ZW1wdCArIDF9LyR7cmV0cmllc30pIGZvciBzeW1ib2w6YCwgY2xlYW5TeW1ib2wpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBzdG9jayBkYXRhIChhdHRlbXB0ICR7YXR0ZW1wdCArIDF9LyR7cmV0cmllc30pIGZvciBzeW1ib2w6YCwgY2xlYW5TeW1ib2wsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGxhc3QgYXR0ZW1wdCwgZ2VuZXJhdGUgcmVhbGlzdGljIGRhdGEgYXMgZmFsbGJhY2tcclxuICAgICAgaWYgKGlzTGFzdEF0dGVtcHQpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0FsbCByZXRyeSBhdHRlbXB0cyBmYWlsZWQsIGdlbmVyYXRpbmcgcmVhbGlzdGljIHN0b2NrIGRhdGEgYXMgZmFsbGJhY2snKTtcclxuICAgICAgICBpZiAoYmFzZVByaWNlICYmIGJhc2VQcmljZSA+IDApIHtcclxuICAgICAgICAgIHJldHVybiBnZW5lcmF0ZVJlYWxpc3RpY1N0b2NrRGF0YShiYXNlUHJpY2UsIHJhbmdlLCBpbnRlcnZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlpbmcgKGV4cG9uZW50aWFsIGJhY2tvZmYpXHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwICogKGF0dGVtcHQgKyAxKSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFtdO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGFwcHJvcHJpYXRlIGludGVydmFsIGFuZCByYW5nZSBmb3IgYSB0aW1lIHBlcmlvZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0b2NrRGF0YVBhcmFtcyh0aW1lUmFuZ2U6IHN0cmluZyk6IHsgaW50ZXJ2YWw6ICcxZCcgfCAnMXdrJyB8ICcxbW8nOyByYW5nZTogc3RyaW5nIH0ge1xyXG4gIHN3aXRjaCAodGltZVJhbmdlKSB7XHJcbiAgICBjYXNlICcxZCc6XHJcbiAgICAgIHJldHVybiB7IGludGVydmFsOiAnMWQnLCByYW5nZTogJzFkJyB9O1xyXG4gICAgY2FzZSAnMXcnOlxyXG4gICAgY2FzZSAnMSB3ZWVrJzpcclxuICAgICAgcmV0dXJuIHsgaW50ZXJ2YWw6ICcxZCcsIHJhbmdlOiAnNWQnIH07XHJcbiAgICBjYXNlICcxbSc6XHJcbiAgICBjYXNlICcxIG1vbnRoJzpcclxuICAgICAgcmV0dXJuIHsgaW50ZXJ2YWw6ICcxZCcsIHJhbmdlOiAnMW1vJyB9O1xyXG4gICAgY2FzZSAnM20nOlxyXG4gICAgY2FzZSAnMyBtb250aHMnOlxyXG4gICAgICByZXR1cm4geyBpbnRlcnZhbDogJzFkJywgcmFuZ2U6ICczbW8nIH07XHJcbiAgICBjYXNlICc2bSc6XHJcbiAgICBjYXNlICc2IG1vbnRocyc6XHJcbiAgICAgIHJldHVybiB7IGludGVydmFsOiAnMXdrJywgcmFuZ2U6ICc2bW8nIH07XHJcbiAgICBjYXNlICcxeSc6XHJcbiAgICBjYXNlICcxIHllYXInOlxyXG4gICAgICByZXR1cm4geyBpbnRlcnZhbDogJzF3aycsIHJhbmdlOiAnMXknIH07XHJcbiAgICBjYXNlICdtYXgnOlxyXG4gICAgICByZXR1cm4geyBpbnRlcnZhbDogJzFtbycsIHJhbmdlOiAnbWF4JyB9O1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIHsgaW50ZXJ2YWw6ICcxZCcsIHJhbmdlOiAnMW1vJyB9O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgdGltZSByYW5nZSBzdHJpbmcgdG8gZGlzcGxheSBsYWJlbFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRpbWVSYW5nZUxhYmVsKHRpbWVSYW5nZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICBzd2l0Y2ggKHRpbWVSYW5nZSkge1xyXG4gICAgY2FzZSAnMWQnOlxyXG4gICAgICByZXR1cm4gJzEgRGF5JztcclxuICAgIGNhc2UgJzF3JzpcclxuICAgIGNhc2UgJzEgd2Vlayc6XHJcbiAgICAgIHJldHVybiAnMSBXZWVrJztcclxuICAgIGNhc2UgJzFtJzpcclxuICAgIGNhc2UgJzEgbW9udGgnOlxyXG4gICAgICByZXR1cm4gJzEgTW9udGgnO1xyXG4gICAgY2FzZSAnM20nOlxyXG4gICAgY2FzZSAnMyBtb250aHMnOlxyXG4gICAgICByZXR1cm4gJzMgTW9udGhzJztcclxuICAgIGNhc2UgJzZtJzpcclxuICAgIGNhc2UgJzYgbW9udGhzJzpcclxuICAgICAgcmV0dXJuICc2IE1vbnRocyc7XHJcbiAgICBjYXNlICcxeSc6XHJcbiAgICBjYXNlICcxIHllYXInOlxyXG4gICAgICByZXR1cm4gJzEgWWVhcic7XHJcbiAgICBjYXNlICdtYXgnOlxyXG4gICAgICByZXR1cm4gJ01heCc7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gdGltZVJhbmdlO1xyXG4gIH1cclxufVxyXG5cclxuIl0sIm5hbWVzIjpbImdlbmVyYXRlUmVhbGlzdGljU3RvY2tEYXRhIiwiYmFzZVByaWNlIiwidGltZVJhbmdlIiwiaW50ZXJ2YWwiLCJub3ciLCJEYXRlIiwibnVtUG9pbnRzIiwibWludXRlc1BlclBvaW50IiwiZGF0YVBvaW50cyIsImN1cnJlbnRQcmljZSIsInRyZW5kIiwidm9sYXRpbGl0eSIsInRyZW5kRGlyZWN0aW9uIiwiTWF0aCIsInJhbmRvbSIsInRyZW5kU3RyZW5ndGgiLCJpIiwibWludXRlc0FnbyIsImRhdGUiLCJnZXRUaW1lIiwicmFuZG9tQ2hhbmdlIiwibWF4IiwidGltZSIsImhvdXJzIiwiZ2V0SG91cnMiLCJtaW51dGVzIiwiZ2V0TWludXRlcyIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJtb250aCIsImdldE1vbnRoIiwiZGF5IiwiZ2V0RGF0ZSIsInB1c2giLCJ2YWx1ZSIsIk51bWJlciIsInRvRml4ZWQiLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwicmV2ZXJzZSIsImZldGNoU3RvY2tEYXRhIiwib3B0aW9ucyIsInJldHJpZXMiLCJzeW1ib2wiLCJyYW5nZSIsInRyaW0iLCJjb25zb2xlIiwid2FybiIsImNsZWFuU3ltYm9sIiwidG9VcHBlckNhc2UiLCJhdHRlbXB0IiwiZGF0YSIsInJlc3VsdCIsImJhc2VVcmwiLCJ1cmwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGltZW91dElkIiwic2V0VGltZW91dCIsImFib3J0IiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJzaWduYWwiLCJjbGVhclRpbWVvdXQiLCJvayIsIkVycm9yIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImpzb24iLCJjaGFydCIsInRpbWVzdGFtcHMiLCJxdW90ZXMiLCJpbmRpY2F0b3JzIiwicXVvdGUiLCJjbG9zZXMiLCJjbG9zZSIsImxlbmd0aCIsIm1hcCIsImluZGV4IiwidW5kZWZpbmVkIiwiaXNGaW5pdGUiLCJmaWx0ZXIiLCJwb2ludCIsImVycm9yIiwiaXNMYXN0QXR0ZW1wdCIsIm5hbWUiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsImdldFN0b2NrRGF0YVBhcmFtcyIsImZvcm1hdFRpbWVSYW5nZUxhYmVsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/stockData.ts\n"));

/***/ })

});