"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/discussions/[id]/page",{

/***/ "(app-pages-browser)/./lib/statusColors.ts":
/*!*****************************!*\
  !*** ./lib/statusColors.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   STATUS_COLORS: function() { return /* binding */ STATUS_COLORS; },\n/* harmony export */   getStatusColor: function() { return /* binding */ getStatusColor; },\n/* harmony export */   getStatusLabel: function() { return /* binding */ getStatusLabel; },\n/* harmony export */   statusColorMap: function() { return /* binding */ statusColorMap; },\n/* harmony export */   statusColorMap20: function() { return /* binding */ statusColorMap20; }\n/* harmony export */ });\n/**\r\n * Centralized status color definitions\r\n * Ensures consistent colors across all pages:\r\n * - DECIDED: Green (sage-green)\r\n * - IN PROGRESS: Orange (warning-amber)\r\n */ const STATUS_COLORS = {\n    // Main status colors\n    in_progress: \"bg-warning-amber/15 text-warning-amber border border-warning-amber/40\",\n    awaiting_execution: \"bg-warning-amber/15 text-warning-amber border border-warning-amber/40\",\n    decided: \"bg-sage-green/15 text-sage-green border border-sage-green/40\",\n    // Alternative opacity variants (for different contexts)\n    in_progress_20: \"bg-warning-amber/20 text-warning-amber border-warning-amber/50\",\n    awaiting_execution_20: \"bg-warning-amber/20 text-warning-amber border-warning-amber/50\",\n    decided_20: \"bg-sage-green/20 text-sage-green border-sage-green/50\",\n    // Legacy status mappings (all map to decided or in_progress)\n    open: \"bg-warning-amber/15 text-warning-amber border border-warning-amber/40\",\n    active: \"bg-warning-amber/15 text-warning-amber border border-warning-amber/40\",\n    created: \"bg-warning-amber/15 text-warning-amber border border-warning-amber/40\",\n    closed: \"bg-sage-green/15 text-sage-green border border-sage-green/40\",\n    finalized: \"bg-sage-green/15 text-sage-green border border-sage-green/40\",\n    accepted: \"bg-sage-green/15 text-sage-green border border-sage-green/40\",\n    completed: \"bg-sage-green/15 text-sage-green border border-sage-green/40\",\n    archived: \"bg-shadow-grey/50 text-floral-white/70 border border-floral-white/10\",\n    rejected: \"bg-error-red/20 text-error-red border-error-red/50\"\n};\n/**\r\n * Get status color classes for a given status\r\n * Normalizes status to either 'in_progress' (orange) or 'decided' (green)\r\n */ function getStatusColor(status) {\n    let variant = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"default\";\n    if (!status) {\n        return STATUS_COLORS.in_progress;\n    }\n    const statusLower = status.toLowerCase();\n    // Normalize to in_progress (orange)\n    if (statusLower === \"in_progress\" || statusLower === \"open\" || statusLower === \"active\" || statusLower === \"created\" || statusLower === \"OPEN\" || statusLower === \"ACTIVE\" || statusLower === \"CREATED\") {\n        return variant === \"20\" ? STATUS_COLORS.in_progress_20 : STATUS_COLORS.in_progress;\n    }\n    // Normalize to decided (green)\n    if (statusLower === \"decided\" || statusLower === \"closed\" || statusLower === \"finalized\" || statusLower === \"accepted\" || statusLower === \"completed\" || statusLower === \"DECIDED\" || statusLower === \"CLOSED\" || statusLower === \"FINALIZED\" || statusLower === \"ACCEPTED\" || statusLower === \"COMPLETED\") {\n        return variant === \"20\" ? STATUS_COLORS.decided_20 : STATUS_COLORS.decided;\n    }\n    // Handle other statuses\n    if (statusLower === \"archived\") {\n        return STATUS_COLORS.archived;\n    }\n    if (statusLower === \"rejected\") {\n        return STATUS_COLORS.rejected;\n    }\n    // Default to in_progress (orange) for unknown statuses\n    return variant === \"20\" ? STATUS_COLORS.in_progress_20 : STATUS_COLORS.in_progress;\n}\n/**\r\n * Get status label for a given status\r\n */ function getStatusLabel(status) {\n    if (!status) {\n        return \"In Progress\";\n    }\n    const statusLower = status.toLowerCase();\n    // Normalize to in_progress\n    if (statusLower === \"in_progress\" || statusLower === \"open\" || statusLower === \"active\" || statusLower === \"created\" || statusLower === \"OPEN\" || statusLower === \"ACTIVE\" || statusLower === \"CREATED\") {\n        return \"In Progress\";\n    }\n    // Normalize to decided\n    if (statusLower === \"decided\" || statusLower === \"closed\" || statusLower === \"finalized\" || statusLower === \"accepted\" || statusLower === \"completed\" || statusLower === \"DECIDED\" || statusLower === \"CLOSED\" || statusLower === \"FINALIZED\" || statusLower === \"ACCEPTED\" || statusLower === \"COMPLETED\") {\n        return \"Decided\";\n    }\n    // Return capitalized version for other statuses\n    return status.charAt(0).toUpperCase() + status.slice(1).toLowerCase();\n}\n/**\r\n * Status color map for direct lookup (for backward compatibility)\r\n */ const statusColorMap = {\n    in_progress: STATUS_COLORS.in_progress,\n    decided: STATUS_COLORS.decided,\n    open: STATUS_COLORS.in_progress,\n    active: STATUS_COLORS.in_progress,\n    created: STATUS_COLORS.in_progress,\n    closed: STATUS_COLORS.decided,\n    finalized: STATUS_COLORS.decided,\n    accepted: STATUS_COLORS.decided,\n    completed: STATUS_COLORS.decided,\n    archived: STATUS_COLORS.archived,\n    rejected: STATUS_COLORS.rejected\n};\n/**\r\n * Status color map with 20% opacity variant\r\n */ const statusColorMap20 = {\n    in_progress: STATUS_COLORS.in_progress_20,\n    decided: STATUS_COLORS.decided_20,\n    open: STATUS_COLORS.in_progress_20,\n    active: STATUS_COLORS.in_progress_20,\n    created: STATUS_COLORS.in_progress_20,\n    closed: STATUS_COLORS.decided_20,\n    finalized: STATUS_COLORS.decided_20,\n    accepted: STATUS_COLORS.decided_20,\n    completed: STATUS_COLORS.decided_20,\n    archived: STATUS_COLORS.archived,\n    rejected: STATUS_COLORS.rejected\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zdGF0dXNDb2xvcnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVNLE1BQU1BLGdCQUFnQjtJQUMzQixxQkFBcUI7SUFDckJDLGFBQWE7SUFDYkMsb0JBQW9CO0lBQ3BCQyxTQUFTO0lBRVQsd0RBQXdEO0lBQ3hEQyxnQkFBZ0I7SUFDaEJDLHVCQUF1QjtJQUN2QkMsWUFBWTtJQUVaLDZEQUE2RDtJQUM3REMsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLFNBQVM7SUFDVEMsUUFBUTtJQUNSQyxXQUFXO0lBQ1hDLFVBQVU7SUFDVkMsV0FBVztJQUNYQyxVQUFVO0lBQ1ZDLFVBQVU7QUFDWixFQUFXO0FBRVg7OztDQUdDLEdBQ00sU0FBU0MsZUFBZUMsTUFBaUM7UUFBRUMsVUFBQUEsaUVBQTRCO0lBQzVGLElBQUksQ0FBQ0QsUUFBUTtRQUNYLE9BQU9qQixjQUFjQyxXQUFXO0lBQ2xDO0lBRUEsTUFBTWtCLGNBQWNGLE9BQU9HLFdBQVc7SUFFdEMsb0NBQW9DO0lBQ3BDLElBQUlELGdCQUFnQixpQkFBaUJBLGdCQUFnQixVQUFVQSxnQkFBZ0IsWUFBWUEsZ0JBQWdCLGFBQWFBLGdCQUFnQixVQUFVQSxnQkFBZ0IsWUFBWUEsZ0JBQWdCLFdBQVc7UUFDdk0sT0FBT0QsWUFBWSxPQUFPbEIsY0FBY0ksY0FBYyxHQUFHSixjQUFjQyxXQUFXO0lBQ3BGO0lBRUEsK0JBQStCO0lBQy9CLElBQUlrQixnQkFBZ0IsYUFBYUEsZ0JBQWdCLFlBQVlBLGdCQUFnQixlQUFlQSxnQkFBZ0IsY0FBY0EsZ0JBQWdCLGVBQ3RJQSxnQkFBZ0IsYUFBYUEsZ0JBQWdCLFlBQVlBLGdCQUFnQixlQUFlQSxnQkFBZ0IsY0FBY0EsZ0JBQWdCLGFBQWE7UUFDckosT0FBT0QsWUFBWSxPQUFPbEIsY0FBY00sVUFBVSxHQUFHTixjQUFjRyxPQUFPO0lBQzVFO0lBRUEsd0JBQXdCO0lBQ3hCLElBQUlnQixnQkFBZ0IsWUFBWTtRQUM5QixPQUFPbkIsY0FBY2MsUUFBUTtJQUMvQjtJQUVBLElBQUlLLGdCQUFnQixZQUFZO1FBQzlCLE9BQU9uQixjQUFjZSxRQUFRO0lBQy9CO0lBRUEsdURBQXVEO0lBQ3ZELE9BQU9HLFlBQVksT0FBT2xCLGNBQWNJLGNBQWMsR0FBR0osY0FBY0MsV0FBVztBQUNwRjtBQUVBOztDQUVDLEdBQ00sU0FBU29CLGVBQWVKLE1BQWlDO0lBQzlELElBQUksQ0FBQ0EsUUFBUTtRQUNYLE9BQU87SUFDVDtJQUVBLE1BQU1FLGNBQWNGLE9BQU9HLFdBQVc7SUFFdEMsMkJBQTJCO0lBQzNCLElBQUlELGdCQUFnQixpQkFBaUJBLGdCQUFnQixVQUFVQSxnQkFBZ0IsWUFBWUEsZ0JBQWdCLGFBQ3ZHQSxnQkFBZ0IsVUFBVUEsZ0JBQWdCLFlBQVlBLGdCQUFnQixXQUFXO1FBQ25GLE9BQU87SUFDVDtJQUVBLHVCQUF1QjtJQUN2QixJQUFJQSxnQkFBZ0IsYUFBYUEsZ0JBQWdCLFlBQVlBLGdCQUFnQixlQUFlQSxnQkFBZ0IsY0FBY0EsZ0JBQWdCLGVBQ3RJQSxnQkFBZ0IsYUFBYUEsZ0JBQWdCLFlBQVlBLGdCQUFnQixlQUFlQSxnQkFBZ0IsY0FBY0EsZ0JBQWdCLGFBQWE7UUFDckosT0FBTztJQUNUO0lBRUEsZ0RBQWdEO0lBQ2hELE9BQU9GLE9BQU9LLE1BQU0sQ0FBQyxHQUFHQyxXQUFXLEtBQUtOLE9BQU9PLEtBQUssQ0FBQyxHQUFHSixXQUFXO0FBQ3JFO0FBRUE7O0NBRUMsR0FDTSxNQUFNSyxpQkFBeUM7SUFDcER4QixhQUFhRCxjQUFjQyxXQUFXO0lBQ3RDRSxTQUFTSCxjQUFjRyxPQUFPO0lBQzlCSSxNQUFNUCxjQUFjQyxXQUFXO0lBQy9CTyxRQUFRUixjQUFjQyxXQUFXO0lBQ2pDUSxTQUFTVCxjQUFjQyxXQUFXO0lBQ2xDUyxRQUFRVixjQUFjRyxPQUFPO0lBQzdCUSxXQUFXWCxjQUFjRyxPQUFPO0lBQ2hDUyxVQUFVWixjQUFjRyxPQUFPO0lBQy9CVSxXQUFXYixjQUFjRyxPQUFPO0lBQ2hDVyxVQUFVZCxjQUFjYyxRQUFRO0lBQ2hDQyxVQUFVZixjQUFjZSxRQUFRO0FBQ2xDLEVBQUU7QUFFRjs7Q0FFQyxHQUNNLE1BQU1XLG1CQUEyQztJQUN0RHpCLGFBQWFELGNBQWNJLGNBQWM7SUFDekNELFNBQVNILGNBQWNNLFVBQVU7SUFDakNDLE1BQU1QLGNBQWNJLGNBQWM7SUFDbENJLFFBQVFSLGNBQWNJLGNBQWM7SUFDcENLLFNBQVNULGNBQWNJLGNBQWM7SUFDckNNLFFBQVFWLGNBQWNNLFVBQVU7SUFDaENLLFdBQVdYLGNBQWNNLFVBQVU7SUFDbkNNLFVBQVVaLGNBQWNNLFVBQVU7SUFDbENPLFdBQVdiLGNBQWNNLFVBQVU7SUFDbkNRLFVBQVVkLGNBQWNjLFFBQVE7SUFDaENDLFVBQVVmLGNBQWNlLFFBQVE7QUFDbEMsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvc3RhdHVzQ29sb3JzLnRzP2QwZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENlbnRyYWxpemVkIHN0YXR1cyBjb2xvciBkZWZpbml0aW9uc1xyXG4gKiBFbnN1cmVzIGNvbnNpc3RlbnQgY29sb3JzIGFjcm9zcyBhbGwgcGFnZXM6XHJcbiAqIC0gREVDSURFRDogR3JlZW4gKHNhZ2UtZ3JlZW4pXHJcbiAqIC0gSU4gUFJPR1JFU1M6IE9yYW5nZSAod2FybmluZy1hbWJlcilcclxuICovXHJcblxyXG5leHBvcnQgY29uc3QgU1RBVFVTX0NPTE9SUyA9IHtcclxuICAvLyBNYWluIHN0YXR1cyBjb2xvcnNcclxuICBpbl9wcm9ncmVzczogJ2JnLXdhcm5pbmctYW1iZXIvMTUgdGV4dC13YXJuaW5nLWFtYmVyIGJvcmRlciBib3JkZXItd2FybmluZy1hbWJlci80MCcsXHJcbiAgYXdhaXRpbmdfZXhlY3V0aW9uOiAnYmctd2FybmluZy1hbWJlci8xNSB0ZXh0LXdhcm5pbmctYW1iZXIgYm9yZGVyIGJvcmRlci13YXJuaW5nLWFtYmVyLzQwJywgLy8gV2FpdGluZyBmb3IgZXhlY3V0aW9uIC0gc2ltaWxhciB0byBpbl9wcm9ncmVzc1xyXG4gIGRlY2lkZWQ6ICdiZy1zYWdlLWdyZWVuLzE1IHRleHQtc2FnZS1ncmVlbiBib3JkZXIgYm9yZGVyLXNhZ2UtZ3JlZW4vNDAnLFxyXG4gIFxyXG4gIC8vIEFsdGVybmF0aXZlIG9wYWNpdHkgdmFyaWFudHMgKGZvciBkaWZmZXJlbnQgY29udGV4dHMpXHJcbiAgaW5fcHJvZ3Jlc3NfMjA6ICdiZy13YXJuaW5nLWFtYmVyLzIwIHRleHQtd2FybmluZy1hbWJlciBib3JkZXItd2FybmluZy1hbWJlci81MCcsXHJcbiAgYXdhaXRpbmdfZXhlY3V0aW9uXzIwOiAnYmctd2FybmluZy1hbWJlci8yMCB0ZXh0LXdhcm5pbmctYW1iZXIgYm9yZGVyLXdhcm5pbmctYW1iZXIvNTAnLFxyXG4gIGRlY2lkZWRfMjA6ICdiZy1zYWdlLWdyZWVuLzIwIHRleHQtc2FnZS1ncmVlbiBib3JkZXItc2FnZS1ncmVlbi81MCcsXHJcbiAgXHJcbiAgLy8gTGVnYWN5IHN0YXR1cyBtYXBwaW5ncyAoYWxsIG1hcCB0byBkZWNpZGVkIG9yIGluX3Byb2dyZXNzKVxyXG4gIG9wZW46ICdiZy13YXJuaW5nLWFtYmVyLzE1IHRleHQtd2FybmluZy1hbWJlciBib3JkZXIgYm9yZGVyLXdhcm5pbmctYW1iZXIvNDAnLCAvLyBNYXBzIHRvIGluX3Byb2dyZXNzXHJcbiAgYWN0aXZlOiAnYmctd2FybmluZy1hbWJlci8xNSB0ZXh0LXdhcm5pbmctYW1iZXIgYm9yZGVyIGJvcmRlci13YXJuaW5nLWFtYmVyLzQwJywgLy8gTWFwcyB0byBpbl9wcm9ncmVzc1xyXG4gIGNyZWF0ZWQ6ICdiZy13YXJuaW5nLWFtYmVyLzE1IHRleHQtd2FybmluZy1hbWJlciBib3JkZXIgYm9yZGVyLXdhcm5pbmctYW1iZXIvNDAnLCAvLyBNYXBzIHRvIGluX3Byb2dyZXNzXHJcbiAgY2xvc2VkOiAnYmctc2FnZS1ncmVlbi8xNSB0ZXh0LXNhZ2UtZ3JlZW4gYm9yZGVyIGJvcmRlci1zYWdlLWdyZWVuLzQwJywgLy8gTWFwcyB0byBkZWNpZGVkXHJcbiAgZmluYWxpemVkOiAnYmctc2FnZS1ncmVlbi8xNSB0ZXh0LXNhZ2UtZ3JlZW4gYm9yZGVyIGJvcmRlci1zYWdlLWdyZWVuLzQwJywgLy8gTWFwcyB0byBkZWNpZGVkXHJcbiAgYWNjZXB0ZWQ6ICdiZy1zYWdlLWdyZWVuLzE1IHRleHQtc2FnZS1ncmVlbiBib3JkZXIgYm9yZGVyLXNhZ2UtZ3JlZW4vNDAnLCAvLyBNYXBzIHRvIGRlY2lkZWRcclxuICBjb21wbGV0ZWQ6ICdiZy1zYWdlLWdyZWVuLzE1IHRleHQtc2FnZS1ncmVlbiBib3JkZXIgYm9yZGVyLXNhZ2UtZ3JlZW4vNDAnLCAvLyBNYXBzIHRvIGRlY2lkZWRcclxuICBhcmNoaXZlZDogJ2JnLXNoYWRvdy1ncmV5LzUwIHRleHQtZmxvcmFsLXdoaXRlLzcwIGJvcmRlciBib3JkZXItZmxvcmFsLXdoaXRlLzEwJyxcclxuICByZWplY3RlZDogJ2JnLWVycm9yLXJlZC8yMCB0ZXh0LWVycm9yLXJlZCBib3JkZXItZXJyb3ItcmVkLzUwJyxcclxufSBhcyBjb25zdDtcclxuXHJcbi8qKlxyXG4gKiBHZXQgc3RhdHVzIGNvbG9yIGNsYXNzZXMgZm9yIGEgZ2l2ZW4gc3RhdHVzXHJcbiAqIE5vcm1hbGl6ZXMgc3RhdHVzIHRvIGVpdGhlciAnaW5fcHJvZ3Jlc3MnIChvcmFuZ2UpIG9yICdkZWNpZGVkJyAoZ3JlZW4pXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdHVzQ29sb3Ioc3RhdHVzOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLCB2YXJpYW50OiAnZGVmYXVsdCcgfCAnMjAnID0gJ2RlZmF1bHQnKTogc3RyaW5nIHtcclxuICBpZiAoIXN0YXR1cykge1xyXG4gICAgcmV0dXJuIFNUQVRVU19DT0xPUlMuaW5fcHJvZ3Jlc3M7XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IHN0YXR1c0xvd2VyID0gc3RhdHVzLnRvTG93ZXJDYXNlKCk7XHJcbiAgXHJcbiAgLy8gTm9ybWFsaXplIHRvIGluX3Byb2dyZXNzIChvcmFuZ2UpXHJcbiAgaWYgKHN0YXR1c0xvd2VyID09PSAnaW5fcHJvZ3Jlc3MnIHx8IHN0YXR1c0xvd2VyID09PSAnb3BlbicgfHwgc3RhdHVzTG93ZXIgPT09ICdhY3RpdmUnIHx8IHN0YXR1c0xvd2VyID09PSAnY3JlYXRlZCcgfHwgc3RhdHVzTG93ZXIgPT09ICdPUEVOJyB8fCBzdGF0dXNMb3dlciA9PT0gJ0FDVElWRScgfHwgc3RhdHVzTG93ZXIgPT09ICdDUkVBVEVEJykge1xyXG4gICAgcmV0dXJuIHZhcmlhbnQgPT09ICcyMCcgPyBTVEFUVVNfQ09MT1JTLmluX3Byb2dyZXNzXzIwIDogU1RBVFVTX0NPTE9SUy5pbl9wcm9ncmVzcztcclxuICB9XHJcbiAgXHJcbiAgLy8gTm9ybWFsaXplIHRvIGRlY2lkZWQgKGdyZWVuKVxyXG4gIGlmIChzdGF0dXNMb3dlciA9PT0gJ2RlY2lkZWQnIHx8IHN0YXR1c0xvd2VyID09PSAnY2xvc2VkJyB8fCBzdGF0dXNMb3dlciA9PT0gJ2ZpbmFsaXplZCcgfHwgc3RhdHVzTG93ZXIgPT09ICdhY2NlcHRlZCcgfHwgc3RhdHVzTG93ZXIgPT09ICdjb21wbGV0ZWQnIHx8IFxyXG4gICAgICBzdGF0dXNMb3dlciA9PT0gJ0RFQ0lERUQnIHx8IHN0YXR1c0xvd2VyID09PSAnQ0xPU0VEJyB8fCBzdGF0dXNMb3dlciA9PT0gJ0ZJTkFMSVpFRCcgfHwgc3RhdHVzTG93ZXIgPT09ICdBQ0NFUFRFRCcgfHwgc3RhdHVzTG93ZXIgPT09ICdDT01QTEVURUQnKSB7XHJcbiAgICByZXR1cm4gdmFyaWFudCA9PT0gJzIwJyA/IFNUQVRVU19DT0xPUlMuZGVjaWRlZF8yMCA6IFNUQVRVU19DT0xPUlMuZGVjaWRlZDtcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIG90aGVyIHN0YXR1c2VzXHJcbiAgaWYgKHN0YXR1c0xvd2VyID09PSAnYXJjaGl2ZWQnKSB7XHJcbiAgICByZXR1cm4gU1RBVFVTX0NPTE9SUy5hcmNoaXZlZDtcclxuICB9XHJcbiAgXHJcbiAgaWYgKHN0YXR1c0xvd2VyID09PSAncmVqZWN0ZWQnKSB7XHJcbiAgICByZXR1cm4gU1RBVFVTX0NPTE9SUy5yZWplY3RlZDtcclxuICB9XHJcbiAgXHJcbiAgLy8gRGVmYXVsdCB0byBpbl9wcm9ncmVzcyAob3JhbmdlKSBmb3IgdW5rbm93biBzdGF0dXNlc1xyXG4gIHJldHVybiB2YXJpYW50ID09PSAnMjAnID8gU1RBVFVTX0NPTE9SUy5pbl9wcm9ncmVzc18yMCA6IFNUQVRVU19DT0xPUlMuaW5fcHJvZ3Jlc3M7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgc3RhdHVzIGxhYmVsIGZvciBhIGdpdmVuIHN0YXR1c1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXR1c0xhYmVsKHN0YXR1czogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XHJcbiAgaWYgKCFzdGF0dXMpIHtcclxuICAgIHJldHVybiAnSW4gUHJvZ3Jlc3MnO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBzdGF0dXNMb3dlciA9IHN0YXR1cy50b0xvd2VyQ2FzZSgpO1xyXG4gIFxyXG4gIC8vIE5vcm1hbGl6ZSB0byBpbl9wcm9ncmVzc1xyXG4gIGlmIChzdGF0dXNMb3dlciA9PT0gJ2luX3Byb2dyZXNzJyB8fCBzdGF0dXNMb3dlciA9PT0gJ29wZW4nIHx8IHN0YXR1c0xvd2VyID09PSAnYWN0aXZlJyB8fCBzdGF0dXNMb3dlciA9PT0gJ2NyZWF0ZWQnIHx8IFxyXG4gICAgICBzdGF0dXNMb3dlciA9PT0gJ09QRU4nIHx8IHN0YXR1c0xvd2VyID09PSAnQUNUSVZFJyB8fCBzdGF0dXNMb3dlciA9PT0gJ0NSRUFURUQnKSB7XHJcbiAgICByZXR1cm4gJ0luIFByb2dyZXNzJztcclxuICB9XHJcbiAgXHJcbiAgLy8gTm9ybWFsaXplIHRvIGRlY2lkZWRcclxuICBpZiAoc3RhdHVzTG93ZXIgPT09ICdkZWNpZGVkJyB8fCBzdGF0dXNMb3dlciA9PT0gJ2Nsb3NlZCcgfHwgc3RhdHVzTG93ZXIgPT09ICdmaW5hbGl6ZWQnIHx8IHN0YXR1c0xvd2VyID09PSAnYWNjZXB0ZWQnIHx8IHN0YXR1c0xvd2VyID09PSAnY29tcGxldGVkJyB8fFxyXG4gICAgICBzdGF0dXNMb3dlciA9PT0gJ0RFQ0lERUQnIHx8IHN0YXR1c0xvd2VyID09PSAnQ0xPU0VEJyB8fCBzdGF0dXNMb3dlciA9PT0gJ0ZJTkFMSVpFRCcgfHwgc3RhdHVzTG93ZXIgPT09ICdBQ0NFUFRFRCcgfHwgc3RhdHVzTG93ZXIgPT09ICdDT01QTEVURUQnKSB7XHJcbiAgICByZXR1cm4gJ0RlY2lkZWQnO1xyXG4gIH1cclxuICBcclxuICAvLyBSZXR1cm4gY2FwaXRhbGl6ZWQgdmVyc2lvbiBmb3Igb3RoZXIgc3RhdHVzZXNcclxuICByZXR1cm4gc3RhdHVzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RhdHVzLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdGF0dXMgY29sb3IgbWFwIGZvciBkaXJlY3QgbG9va3VwIChmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcclxuICovXHJcbmV4cG9ydCBjb25zdCBzdGF0dXNDb2xvck1hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuICBpbl9wcm9ncmVzczogU1RBVFVTX0NPTE9SUy5pbl9wcm9ncmVzcyxcclxuICBkZWNpZGVkOiBTVEFUVVNfQ09MT1JTLmRlY2lkZWQsXHJcbiAgb3BlbjogU1RBVFVTX0NPTE9SUy5pbl9wcm9ncmVzcyxcclxuICBhY3RpdmU6IFNUQVRVU19DT0xPUlMuaW5fcHJvZ3Jlc3MsXHJcbiAgY3JlYXRlZDogU1RBVFVTX0NPTE9SUy5pbl9wcm9ncmVzcyxcclxuICBjbG9zZWQ6IFNUQVRVU19DT0xPUlMuZGVjaWRlZCxcclxuICBmaW5hbGl6ZWQ6IFNUQVRVU19DT0xPUlMuZGVjaWRlZCxcclxuICBhY2NlcHRlZDogU1RBVFVTX0NPTE9SUy5kZWNpZGVkLFxyXG4gIGNvbXBsZXRlZDogU1RBVFVTX0NPTE9SUy5kZWNpZGVkLFxyXG4gIGFyY2hpdmVkOiBTVEFUVVNfQ09MT1JTLmFyY2hpdmVkLFxyXG4gIHJlamVjdGVkOiBTVEFUVVNfQ09MT1JTLnJlamVjdGVkLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN0YXR1cyBjb2xvciBtYXAgd2l0aCAyMCUgb3BhY2l0eSB2YXJpYW50XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3RhdHVzQ29sb3JNYXAyMDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuICBpbl9wcm9ncmVzczogU1RBVFVTX0NPTE9SUy5pbl9wcm9ncmVzc18yMCxcclxuICBkZWNpZGVkOiBTVEFUVVNfQ09MT1JTLmRlY2lkZWRfMjAsXHJcbiAgb3BlbjogU1RBVFVTX0NPTE9SUy5pbl9wcm9ncmVzc18yMCxcclxuICBhY3RpdmU6IFNUQVRVU19DT0xPUlMuaW5fcHJvZ3Jlc3NfMjAsXHJcbiAgY3JlYXRlZDogU1RBVFVTX0NPTE9SUy5pbl9wcm9ncmVzc18yMCxcclxuICBjbG9zZWQ6IFNUQVRVU19DT0xPUlMuZGVjaWRlZF8yMCxcclxuICBmaW5hbGl6ZWQ6IFNUQVRVU19DT0xPUlMuZGVjaWRlZF8yMCxcclxuICBhY2NlcHRlZDogU1RBVFVTX0NPTE9SUy5kZWNpZGVkXzIwLFxyXG4gIGNvbXBsZXRlZDogU1RBVFVTX0NPTE9SUy5kZWNpZGVkXzIwLFxyXG4gIGFyY2hpdmVkOiBTVEFUVVNfQ09MT1JTLmFyY2hpdmVkLFxyXG4gIHJlamVjdGVkOiBTVEFUVVNfQ09MT1JTLnJlamVjdGVkLFxyXG59O1xyXG5cclxuIl0sIm5hbWVzIjpbIlNUQVRVU19DT0xPUlMiLCJpbl9wcm9ncmVzcyIsImF3YWl0aW5nX2V4ZWN1dGlvbiIsImRlY2lkZWQiLCJpbl9wcm9ncmVzc18yMCIsImF3YWl0aW5nX2V4ZWN1dGlvbl8yMCIsImRlY2lkZWRfMjAiLCJvcGVuIiwiYWN0aXZlIiwiY3JlYXRlZCIsImNsb3NlZCIsImZpbmFsaXplZCIsImFjY2VwdGVkIiwiY29tcGxldGVkIiwiYXJjaGl2ZWQiLCJyZWplY3RlZCIsImdldFN0YXR1c0NvbG9yIiwic3RhdHVzIiwidmFyaWFudCIsInN0YXR1c0xvd2VyIiwidG9Mb3dlckNhc2UiLCJnZXRTdGF0dXNMYWJlbCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJzdGF0dXNDb2xvck1hcCIsInN0YXR1c0NvbG9yTWFwMjAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/statusColors.ts\n"));

/***/ })

});